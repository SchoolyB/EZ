# The EZ Programming Language Standard

**Version:** 1.2-draft
**Date:** February 12, 2026
**Status:** Working Draft
**EZ Version:** 2.0.0

---

> **Notice**
>
> This specification was generated by Claude through systematic review of the EZ language source code and passing integration tests. It represents a best-effort documentation of the language's syntax, semantics, and standard library as implemented.
>
> **This document is subject to change** as the EZ language evolves. It is not guaranteed to be complete or fully accurate in all edge cases.
>
> **Primary Purpose:** This specification is intended primarily to provide context for AI agents and language models to learn and understand the EZ programming language. It serves as a reference for AI-assisted development, code generation, and tooling support. While human developers may find it useful, the official EZ documentation at [https://schoolyb.github.io/EZ-Language-Webapp/docs](https://schoolyb.github.io/EZ-Language-Webapp/docs) should be consulted for tutorials and usage guidance.

---

## Table of Contents

1. [Introduction](#1-introduction)
2. [Notation](#2-notation)
3. [Lexical Structure](#3-lexical-structure)
4. [Types](#4-types)
5. [Variables and Constants](#5-variables-and-constants)
6. [Expressions](#6-expressions)
7. [Statements](#7-statements)
8. [Functions](#8-functions)
9. [Modules](#9-modules)
10. [Standard Library](#10-standard-library)
11. [Error Handling](#11-error-handling)
12. [Memory Model](#12-memory-model)
13. [Program Execution](#13-program-execution)

---

## 1. Introduction

### 1.1 Purpose

This document defines the EZ programming language. It serves as the authoritative reference for the language's syntax, semantics, and behavior. Implementations of EZ must conform to this specification.

### 1.2 Overview

EZ is a statically-typed, interpreted programming language designed for clarity and ease of use. The language emphasizes:

- **Simplicity**: A minimal set of orthogonal features
- **Clarity**: Explicit syntax that reads naturally
- **Safety**: Static type checking and runtime bounds checking

### 1.3 Conformance

A conforming EZ implementation must:

1. Accept all programs that conform to this specification
2. Reject all programs that violate this specification with appropriate error messages
3. Execute conforming programs with the semantics defined herein

---

## 2. Notation

### 2.1 Grammar Notation

This specification uses Extended Backus-Naur Form (EBNF) to describe syntax:

```
production  = name "=" expression "." ;
expression  = term { "|" term } ;
term        = factor { factor } ;
factor      = name | literal | "[" expression "]" | "(" expression ")" | "{" expression "}" ;
```

Where:
- `[ x ]` denotes zero or one occurrence of x
- `{ x }` denotes zero or more occurrences of x
- `( x | y )` denotes grouping with alternation
- `"text"` denotes literal text

### 2.2 Terminology

- **Must**: Indicates an absolute requirement
- **Must not**: Indicates an absolute prohibition
- **Should**: Indicates a recommendation
- **May**: Indicates optional behavior

---

## 3. Lexical Structure

### 3.1 Source Encoding

EZ source files must be encoded in UTF-8. However, identifiers are restricted to ASCII characters.

### 3.2 Line Terminators

Line terminators are the ASCII line feed character (LF, U+000A) or the ASCII carriage return character (CR, U+000D) optionally followed by a line feed.

### 3.3 Comments

EZ supports two forms of comments:

**Single-line comments** begin with `//` and extend to the end of the line:

```ez
// This is a single-line comment
temp x int = 42  // inline comment
```

**Multi-line comments** begin with `/*` and end with `*/`:

```ez
/* This is a
   multi-line comment */
```

Multi-line comments do not nest. A `/*` inside a multi-line comment has no special meaning.

### 3.4 Identifiers

Identifiers name program entities such as variables, functions, types, and modules.

```
identifier = letter { letter | digit | "_" } .
letter     = "A" ... "Z" | "a" ... "z" .
digit      = "0" ... "9" .
```

Identifiers must:
- Begin with an ASCII letter
- Contain only ASCII letters, digits, and underscores
- Not be a reserved keyword

Valid identifiers: `x`, `count`, `myVariable`, `point_2d`, `MAX_SIZE`

Invalid identifiers: `2fast`, `my-var`, `café`, `_private`

### 3.5 Keywords

The following words are reserved and may not be used as identifiers:

```
as_long_as   bool        break       byte        cast
char         const       continue    default     do
ensure       enum        error       false       float
for          for_each    if          import      in
int          is          loop        map         module
new          nil         not_in      or          otherwise
private      range       return      string      struct
temp         true        uint        using       when
```

### 3.6 Operators and Punctuation

```
+    -    *    /    %
==   !=   <    >    <=   >=
&&   ||   !
=    +=   -=   *=   /=
++   --
(    )    {    }    [    ]
,    :    .    ->   &
```

### 3.7 Literals

#### 3.7.1 Integer Literals

Integer literals represent integer values.

```
int_literal    = decimal_lit | hex_lit | octal_lit .
decimal_lit    = digit { [ "_" ] digit } .
hex_lit        = "0" ( "x" | "X" ) hex_digit { [ "_" ] hex_digit } .
hex_digit      = digit | "A" ... "F" | "a" ... "f" .
octal_lit      = "0" ( "o" | "O" ) octal_digit { [ "_" ] octal_digit } .
octal_digit    = "0" ... "7" .
```

Underscores may be used for readability but:
- Must not appear at the beginning or end
- Must not appear consecutively
- Must not appear adjacent to the decimal point

Examples: `42`, `1_000_000`, `0xFF`, `0xDEAD_BEEF`, `0o777`, `0o1_2_3`

#### 3.7.2 Floating-Point Literals

Floating-point literals represent floating-point values.

```
float_literal = digit { digit } "." digit { digit } .
```

Examples: `3.14159`, `0.5`, `100.0`

#### 3.7.3 String Literals

String literals represent string values.

```
string_literal = '"' { string_char | escape_seq | interpolation } '"' .
string_char    = /* any UTF-8 character except '"', '\', or newline */ .
escape_seq     = "\" ( "n" | "r" | "t" | "\" | '"' ) .
interpolation  = "${" expression "}" .
```

Escape sequences:
- `\n` - line feed (U+000A)
- `\r` - carriage return (U+000D)
- `\t` - horizontal tab (U+0009)
- `\\` - backslash
- `\"` - double quote
- `\xNN` - hex byte value (e.g., `\x48` = 'H', `\x0a` = newline)

String interpolation allows embedding expressions within strings:

```ez
temp name string = "World"
temp greeting string = "Hello, ${name}!"  // "Hello, World!"
```

#### 3.7.4 Raw String Literals

Raw string literals are enclosed in backticks and do not process escape sequences or string interpolation:

```
raw_string_literal = "`" { raw_string_char } "`" .
raw_string_char    = /* any UTF-8 character except "`" */ .
```

Raw strings:
- Do not process escape sequences (`\n` is a literal backslash followed by `n`)
- Do not process string interpolation (`${x}` is literal text)
- May span multiple lines
- Cannot contain backticks (no escape mechanism)

```ez
temp path string = `C:\Users\test\file.txt`
temp pattern string = `\d+\.\d+`
temp multi string = `line1
line2
line3`
```

#### 3.7.5 Character Literals

Character literals represent single character values.

```
char_literal = "'" ( char_char | escape_seq ) "'" .
char_char    = /* any UTF-8 character except "'", '\', or newline */ .
```

Examples: `'A'`, `'\n'`, `'\t'`

Character literals must contain exactly one character (or escape sequence).

#### 3.7.6 Boolean Literals

```
bool_literal = "true" | "false" .
```

#### 3.7.7 Nil Literal

```
nil_literal = "nil" .
```

The literal `nil` represents the absence of a value.

---

## 4. Types

EZ is statically typed. Every variable and expression has a type known at check time.

### 4.1 Primitive Types

#### 4.1.1 Integer Type (`int`)

The `int` type represents arbitrary-precision signed integers. There is no overflow or underflow; integers grow as needed to accommodate any value.

```ez
temp small int = 42
temp large int = 9223372036854775808  // Exceeds 64-bit, still valid
```

#### 4.1.2 Unsigned Integer Type (`uint`)

The `uint` type represents arbitrary-precision unsigned (non-negative) integers. Like `int`, there is no overflow; values grow as needed.

```ez
temp count uint = 100
temp big uint = 18446744073709551615  // Max 64-bit unsigned, still valid
```

Assigning a negative value to a `uint` produces a check-time error.

#### 4.1.3 Floating-Point Type (`float`)

The `float` type represents 64-bit IEEE 754 double-precision floating-point numbers.

Division by zero with floating-point operands produces a runtime error (not IEEE 754 infinity or NaN).

```ez
temp pi float = 3.14159
temp negative float = -2.5
```

#### 4.1.4 String Type (`string`)

The `string` type represents a sequence of characters. Strings are UTF-8 encoded and are treated as arrays of `char` values.

```ez
temp greeting string = "Hello, World!"
temp first_char char = greeting[0]  // 'H'
```

#### 4.1.5 Boolean Type (`bool`)

The `bool` type has exactly two values: `true` and `false`.

```ez
temp flag bool = true
temp result bool = 10 > 5  // true
```

#### 4.1.6 Character Type (`char`)

The `char` type represents a single character.

```ez
temp letter char = 'A'
temp newline char = '\n'
```

Characters can be converted to their integer code point using `int()`.

#### 4.1.7 Byte Type (`byte`)

The `byte` type represents an 8-bit unsigned integer with values from 0 to 255.

```ez
temp b byte = 0xFF  // 255
temp c byte = 128   // decimal also works
```

Assigning a value outside the range 0-255 to a `byte` is a check-time error.

#### 4.1.8 Nil Type (`nil`)

The `nil` type has a single value, also written `nil`. It represents the absence of a value and is used in error handling.

### 4.2 Composite Types

#### 4.2.1 Arrays

Arrays are ordered collections of elements of the same type.

**Dynamic arrays** have variable length:

```
array_type = "[" type "]" .
```

```ez
temp numbers [int] = {1, 2, 3, 4, 5}
temp empty [string] = {}
```

**Fixed-size arrays** have a length specified at declaration:

```
fixed_array_type = "[" type "," size "]" .
```

```ez
const fixed [int, 3] = {10, 20, 30}
```

**Multi-dimensional arrays**:

```ez
temp matrix [[int]] = {{1, 2}, {3, 4}}
temp cube [[[int]]] = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}
```

Array indexing is zero-based. Accessing an index outside the valid range produces a runtime error.

#### 4.2.2 Maps

Maps are unordered collections of key-value pairs.

```
map_type = "map" "[" key_type ":" value_type "]" .
```

```ez
temp ages map[string:int] = {
    "alice": 30,
    "bob": 25
}
```

Keys must be of a hashable type: `int`, `uint`, `float`, `string`, `bool`, `char`, or `byte`.

Accessing a key that does not exist produces a runtime error.

#### 4.2.3 Structs

Structs are user-defined composite types with named fields.

```
struct_decl = "const" identifier "struct" "{" { field_decl } "}" .
field_decl  = identifier type .
```

```ez
const Point struct {
    x int
    y int
}

const Person struct {
    name string
    age int
    active bool
}
```

Struct instantiation uses named field syntax:

```ez
temp origin Point = Point{x: 0, y: 0}
temp p Point = Point{}  // Zero-initialized: x=0, y=0
```

Fields are accessed using dot notation:

```ez
temp x_value int = origin.x
origin.x = 10  // Modification (if variable is temp)
```

#### 4.2.4 Enums

Enums define a type with a fixed set of named values.

**Integer enums** (default, auto-incrementing from 0):

```ez
const Direction enum {
    NORTH    // 0
    EAST     // 1
    SOUTH    // 2
    WEST     // 3
}
```

**Flags enums** (powers of 2, annotated with `#flags`):

```ez
#flags
const Permissions enum {
    READ      // 1
    WRITE     // 2
    EXECUTE   // 4
    DELETE    // 8
}
```

**String enums** (explicit string values):

```ez
const Status enum {
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    DONE = "done"
}
```

Enum values are accessed using dot notation:

```ez
temp dir int = Direction.NORTH
temp status string = Status.TODO
```

### 4.3 Type Inference

EZ is a statically-typed language that generally requires explicit type annotations. However, **partial type inference** is supported in specific contexts where the type can be unambiguously determined from the initializer.

Type inference is permitted when assigning from:

1. **Function return values** - The variable's type is inferred from the function's return type
2. **Struct literals** - The type is known from the struct name
3. **Built-in constructors** - `new(Type)` and `copy(value)`
4. **Array literals** - When element types are consistent

```ez
// Inferred from function return type
do sum(a int, b int) -> int {
    return a + b
}
temp result = sum(1, 2)        // Inferred: int
println(typeof(result))        // Output: int

// Inferred from struct literal
const p = Point{x: 1, y: 2}    // Inferred: Point

// Inferred from built-in constructors
temp val = new(Person)         // Inferred: Person
temp dup = copy(val)           // Inferred: Person

// Inferred from array literal
temp arr = {1, 2, 3}           // Inferred: [int]

// Multiple return values
do divide(a, b int) -> (int, int) {
    return a / b, a % b
}
temp quotient, remainder = divide(10, 3)  // Both inferred: int
```

**Note:** Type inference does not apply to standalone literals without context. Explicit types are required when the type cannot be determined:

```ez
temp x int = 42                // Explicit type required for standalone literal
temp name string = "Alice"     // Explicit type required
```

### 4.4 Type Conversions

Explicit type conversions are performed using type constructors:

```ez
temp i int = int('A')       // 65 - char to int (code point)
temp f float = float(42)    // 42.0 - int to float
temp s string = string(123) // "123" - int to string
temp c char = char(65)      // 'A' - int to char
```

Conversions that would lose information or are invalid produce check-time or runtime errors.

#### 4.4.1 The `cast` Keyword

The `cast` keyword provides explicit type conversion for values and arrays:

```
cast_expr = "cast" "(" expression "," type ")" .
```

```ez
temp small u8 = cast(42, u8)
temp truncated int = cast(3.7, int)     // 3
temp text string = cast(123, string)    // "123"
```

For array conversions, `cast` converts each element to the target element type:

```ez
temp ints [int] = {1, 2, 3}
temp bytes [u8] = cast(ints, [u8])
```

Range constraints are enforced at runtime (e.g., `u8` values must be 0-255).

---

## 5. Variables and Constants

### 5.1 Variable Declarations

Variables are declared using the `temp` keyword:

```
var_decl = "temp" identifier type "=" expression .
```

```ez
temp count int = 0
temp name string = "Alice"
temp items [int] = {1, 2, 3}
```

Variables declared with `temp`:
- Must be initialized at declaration
- Can be reassigned after declaration
- Are scoped to their containing block

### 5.2 Constant Declarations

Constants are declared using the `const` keyword:

```
const_decl = "const" identifier [ type ] "=" expression .
```

```ez
const PI float = 3.14159
const MAX_SIZE int = 100
const origin = Point{x: 0, y: 0}
```

Constants declared with `const`:
- Must be initialized at declaration
- Cannot be reassigned
- Cannot have their contents modified (for composite types)
- Are scoped to their containing block (or module, if at top level)

### 5.3 Mutability

The `const` keyword indicates complete immutability:

```ez
const arr [int, 3] = {1, 2, 3}
arr[0] = 10  // ERROR: Cannot modify const
arr = {4, 5, 6}  // ERROR: Cannot reassign const
```

The `temp` keyword allows modification and **ensures the value itself is mutable**:

```ez
temp arr [int] = {1, 2, 3}
arr[0] = 10  // OK
arr = {4, 5, 6}  // OK
```

When assigning from a function return or other source, `temp` automatically makes the value mutable. There is no need to use `copy()` to obtain a mutable version:

```ez
do get_data() -> [int] {
    return {1, 2, 3}
}

temp arr = get_data()  // arr is mutable
arrays.append(arr, 4)  // OK - can modify directly

const fixed = get_data()  // fixed is immutable
arrays.append(fixed, 4)   // ERROR - cannot modify const
```

### 5.4 Scope

Variables and constants are block-scoped. A block is delimited by braces `{}`.

Inner scopes may declare variables that shadow outer scope variables:

```ez
temp x int = 10
if true {
    temp x int = 20  // Shadows outer x
    // x is 20 here
}
// x is 10 here
```

### 5.5 Blank Identifier

The blank identifier `_` can be used to discard values that are not needed. This is particularly useful with multiple return values:

```ez
// Discard the second return value
temp value, _ = get_pair()

// Discard multiple values
const _, middle, _ = get_triple()

// Common pattern: ignore error when you know it won't fail
temp data, _ = json.encode(simple_value)
```

The blank identifier:
- Cannot be read from (it discards the value)
- Can be used multiple times in the same assignment
- Works with both `temp` and `const` declarations

---

## 6. Expressions

### 6.1 Primary Expressions

```
primary_expr = identifier
             | literal
             | "(" expression ")"
             | array_literal
             | map_literal
             | struct_literal .
```

#### 6.1.1 Array Literals

```ez
{1, 2, 3}
{"a", "b", "c"}
{}  // Empty array
```

#### 6.1.2 Map Literals

```ez
{"key": "value", "another": "pair"}
{1: "one", 2: "two"}
```

#### 6.1.3 Struct Literals

```ez
Point{x: 10, y: 20}
Person{name: "Alice", age: 30, active: true}
Point{}  // Zero-initialized
```

### 6.2 Operators

#### 6.2.1 Arithmetic Operators

| Operator | Description | Operand Types | Result Type |
|----------|-------------|---------------|-------------|
| `+` | Addition | `int`, `int` | `int` |
| `+` | Addition | `float`, `float` | `float` |
| `+` | Concatenation | `string`, `string` | `string` |
| `-` | Subtraction | `int`, `int` | `int` |
| `-` | Subtraction | `float`, `float` | `float` |
| `*` | Multiplication | `int`, `int` | `int` |
| `*` | Multiplication | `float`, `float` | `float` |
| `/` | Division | `int`, `int` | `int` (truncated) |
| `/` | Division | `float`, `float` | `float` |
| `%` | Modulo | `int`, `int` | `int` |

Division by zero produces a runtime error.

#### 6.2.2 Comparison Operators

| Operator | Description |
|----------|-------------|
| `==` | Equal |
| `!=` | Not equal |
| `<` | Less than |
| `>` | Greater than |
| `<=` | Less than or equal |
| `>=` | Greater than or equal |

Comparison operators return `bool`.

#### 6.2.3 Logical Operators

| Operator | Description |
|----------|-------------|
| `&&` | Logical AND (short-circuit) |
| `\|\|` | Logical OR (short-circuit) |
| `!` | Logical NOT |

Logical AND and OR use short-circuit evaluation: the right operand is not evaluated if the result can be determined from the left operand alone.

#### 6.2.4 Membership Operators

| Operator | Description |
|----------|-------------|
| `in` | Membership test |
| `not_in` | Non-membership test |
| `!in` | Non-membership test (shorthand for `not_in`) |

```ez
if 3 in numbers { ... }
if "key" not_in map { ... }
if x in range(0, 10) { ... }
if 10 !in range(0, 10) { ... }  // Shorthand for not_in
```

#### 6.2.5 Assignment Operators

| Operator | Description |
|----------|-------------|
| `=` | Assignment |
| `+=` | Addition assignment |
| `-=` | Subtraction assignment |
| `*=` | Multiplication assignment |
| `/=` | Division assignment |

#### 6.2.6 Increment and Decrement

| Operator | Description |
|----------|-------------|
| `++` | Post-increment |
| `--` | Post-decrement |

```ez
temp x int = 5
x++  // x is now 6
x--  // x is now 5
```

### 6.3 Operator Precedence

From highest to lowest precedence:

1. Parentheses: `()`
2. Unary: `!`, `-` (negation)
3. Multiplicative: `*`, `/`, `%`
4. Additive: `+`, `-`
5. Comparison: `<`, `>`, `<=`, `>=`
6. Equality: `==`, `!=`
7. Logical AND: `&&`
8. Logical OR: `||`
9. Membership: `in`, `not_in`

### 6.4 Index Expressions

```ez
temp arr [int] = {10, 20, 30}
temp val int = arr[1]  // 20
arr[0] = 100  // Modification

temp str string = "hello"
temp c char = str[0]  // 'h'

temp m map[string:int] = {"a": 1}
temp v int = m["a"]  // 1
```

### 6.5 Member Expressions

```ez
temp p Point = Point{x: 10, y: 20}
temp x int = p.x  // 10
p.y = 30  // Modification

temp status int = Direction.NORTH  // Enum access
```

### 6.6 Call Expressions

```ez
temp sum int = add(1, 2)
temp greeting string = greet("World")
println("Hello!")
```

### 6.7 Range Expressions

```
range_expr = "range" "(" start "," end [ "," step ] ")" .
```

```ez
range(0, 10)       // 0, 1, 2, ..., 9  (increment)
range(0, 10, 2)    // 0, 2, 4, 6, 8    (increment)
range(10, 0, -1)   // 10, 9, 8, ..., 1 (decrement)
range(10, 0, -2)   // 10, 8, 6, 4, 2   (decrement)
```

Ranges are inclusive of the start value and exclusive of the end value.

**Step validation rules:**
- Positive step (or omitted): start must be ≤ end
- Negative step: start must be ≥ end (for backwards iteration)
- Zero step: always produces an error (E9003)
- Mismatched direction (e.g., `range(0, 10, -1)`) produces an error (E9005)

---

## 7. Statements

### 7.1 Expression Statements

Any expression can be used as a statement:

```ez
println("Hello")
counter++
do_something()
```

### 7.2 Conditional Statements

#### 7.2.1 If Statements

```
if_stmt = "if" expression block { "or" expression block } [ "otherwise" block ] .
```

```ez
if x < 0 {
    println("negative")
} or x == 0 {
    println("zero")
} otherwise {
    println("positive")
}
```

The `or` keyword introduces additional conditions (similar to `else if` in other languages).

The `otherwise` keyword introduces the default case (similar to `else`).

### 7.3 Loop Statements

#### 7.3.1 For Loops

```
for_stmt = "for" [ "(" ] identifier [ type ] "in" range_expr [ ")" ] block .
```

```ez
for i in range(0, 10) {
    println("${i}")
}

for i int in range(0, 5) {
    // With explicit type
}

for (i in range(0, 10)) {
    // Parentheses optional
}
```

#### 7.3.2 For-Each Loops

```
for_each_stmt = "for_each" [ "(" ] [ identifier "," ] identifier "in" expression [ ")" ] block .
```

```ez
temp items [string] = {"a", "b", "c"}
for_each item in items {
    println(item)
}
```

An optional index variable can precede the value variable, separated by a comma:

```ez
for_each i, item in items {
    println("${i}: ${item}")
}
// Output: 0: a, 1: b, 2: c
```

The index variable is always of type `int` and is zero-based. It works with both arrays and strings:

```ez
for_each i, ch in "hello" {
    println("${i}: ${ch}")
}
```

The blank identifier `_` can be used in either position:

```ez
for_each _, item in items { ... }   // discard index (same as no index)
for_each i, _ in items { ... }     // index only, discard value
```

#### 7.3.3 While Loops

```
while_stmt = "as_long_as" expression block .
```

```ez
temp count int = 0
as_long_as count < 10 {
    count++
}
```

#### 7.3.4 Infinite Loops

```
loop_stmt = "loop" block .
```

The `loop` statement creates an infinite loop that runs until explicitly terminated with `break` or `return`:

```ez
loop {
    temp input string = input()
    if input == "quit" {
        break
    }
    println("You said: ${input}")
}
```

### 7.4 Control Flow Statements

#### 7.4.1 Break

The `break` statement terminates the innermost enclosing loop:

```ez
for i in range(0, 100) {
    if i == 5 {
        break
    }
}
```

#### 7.4.2 Continue

The `continue` statement skips to the next iteration of the innermost enclosing loop:

```ez
for i in range(0, 10) {
    if i % 2 == 0 {
        continue
    }
    println("${i}")  // Prints odd numbers only
}
```

#### 7.4.3 Return

The `return` statement exits the current function, optionally returning a value:

```ez
do add(a int, b int) -> int {
    return a + b
}

do greet() {
    println("Hello")
    return  // Void return
}
```

### 7.5 When Statements (Pattern Matching)

```
when_stmt = [ "#strict" ] "when" expression "{" { when_case } [ default_case ] "}" .
when_case = "is" pattern { "," pattern } block .
default_case = "default" block .
pattern = expression | range_expr .
```

```ez
when x {
    is 1 { println("one") }
    is 2, 3 { println("two or three") }
    is range(4, 10) { println("four to nine") }
    default { println("other") }
}
```

**Strict mode** requires all possible values to be handled:

```ez
#strict
when direction {
    is Direction.NORTH { ... }
    is Direction.EAST { ... }
    is Direction.SOUTH { ... }
    is Direction.WEST { ... }
}
```

### 7.6 Ensure Statement

The `ensure` statement specifies a function to call when the enclosing function exits (whether normally or via early return):

```ez
do process_file() {
    ensure cleanup()
    // ... do work ...
    if error_condition {
        return  // cleanup() will be called
    }
    // cleanup() will be called when function ends
}
```

---

## 8. Functions

### 8.1 Function Declarations

```
func_decl = "do" identifier "(" [ param_list ] ")" [ "->" return_type ] block .
param_list = param { "," param } .
param = [ "&" ] identifier [ "," identifier ]... type [ "=" default_value ] .
return_type = type | "(" type { "," type } ")" | "nil" | "(" type "," "nil" ")"
            | "(" named_return { "," named_return } ")" .
named_return = identifier [ "," identifier ]... type .
```

```ez
do add(a int, b int) -> int {
    return a + b
}

do greet(name string = "World") -> string {
    return "Hello, ${name}!"
}

do process() {
    // Void function (no return type)
}
```

### 8.2 Parameters

#### 8.2.1 Immutable Parameters

By default, parameters are passed by value and cannot modify the caller's variables:

```ez
do double(x int) -> int {
    return x * 2
}
```

#### 8.2.2 Mutable Parameters

Parameters prefixed with `&` can modify the caller's variables:

```ez
do increment(&n int) {
    n = n + 1
}

temp count int = 0
increment(count)  // count is now 1
```

Mutable parameters work with:
- Primitive types
- Struct fields: `increment(point.x)`
- Array elements: `increment(arr[0])`
- Map values: `increment(map["key"])`

#### 8.2.3 Grouped Parameters

Multiple parameters of the same type can be grouped:

```ez
do add(a, b int) -> int {
    return a + b
}

do swap(&a, &b int) {
    temp t int = a
    a = b
    b = t
}
```

#### 8.2.4 Default Parameters

Parameters can have default values:

```ez
do greet(name string = "World") -> string {
    return "Hello, ${name}!"
}

greet()         // "Hello, World!"
greet("Alice")  // "Hello, Alice!"
```

Default parameters must appear after non-default parameters.

### 8.3 Return Types

#### 8.3.1 Single Return Value

```ez
do square(x int) -> int {
    return x * x
}
```

#### 8.3.2 Multiple Return Values

```ez
do divide(a, b int) -> (int, int) {
    return a / b, a % b
}

temp quotient, remainder = divide(17, 5)
```

#### 8.3.3 Error Returns

```ez
do parse(s string) -> (int, Error) {
    if s == "" {
        return 0, error("empty string")
    }
    return 42, nil
}

temp value, err = parse("test")
if err != nil {
    // Handle error
}
```

#### 8.3.4 Named Return Variables

Return values can be given names, which declares them as variables within the function body:

```ez
do divide(a, b int) -> (quotient int, remainder int) {
    quotient = a / b
    remainder = a % b
    return quotient, remainder
}

temp q, r = divide(17, 5)  // q=3, r=2
```

Named returns support grouped types (multiple names sharing one type):

```ez
do get_info() -> (name, city string, age int) {
    name = "Alice"
    city = "NYC"
    age = 30
    return name, city, age
}
```

Named return variables must be enclosed in parentheses. They are regular variables within the function scope and must be explicitly returned.

#### 8.3.5 Void Functions

Functions without a return type return no value:

```ez
do print_greeting() {
    println("Hello!")
}
```

### 8.4 Visibility

By default, all functions and constants are public. The `private` keyword restricts access to the declaring module:

```ez
module mathlib

private const MAX_ITERATIONS int = 1000

private do validate(n int) -> bool {
    return n > 0
}

do factorial(n int) -> int {
    // Can call private members within the same module
    if !validate(n) { return 1 }
    // ...
}
```

Private members cannot be accessed from other modules:

```ez
import "./mathlib"
mathlib.factorial(5)          // OK - public
// mathlib.validate(5)        // ERROR E4006 - private function
// mathlib.MAX_ITERATIONS     // ERROR E6009 - private constant
```

### 8.5 Attributes

Attributes are annotations prefixed with `#` that modify declaration behavior.

#### 8.5.1 `#doc` Attribute

The `#doc` attribute adds documentation metadata to functions, structs, and enums. Used by the `ez doc` command to generate documentation.

```ez
#doc("Adds two integers and returns the sum")
do add(a int, b int) -> int {
    return a + b
}

#doc("Represents a 2D point")
const Point struct {
    x int
    y int
}
```

#### 8.5.2 `#suppress` Attribute

The `#suppress` attribute suppresses specific typechecker warnings for a function:

```ez
#suppress(W1001)
do helper() {
    temp unused int = 42  // No unused-variable warning
}

#suppress(W1001, W2001)
do another() { ... }      // Suppress multiple warnings

#suppress(ALL)
do nowarnings() { ... }   // Suppress all warnings
```

Suppressible warnings include: `W1001` (unused-variable), `W1004` (unused-parameter), `W1005` (typed-blank-identifier), `W2001` (unreachable-code), `W2002` (shadowed-variable), `W2003` (missing-return), `W2004` (implicit-type-conversion), `W2005` (deprecated-feature), `W2006` (byte-overflow-potential), `W2009` (nil-dereference-potential), `W2011` (named-return-unused), `W3001` (empty-block), `W3002` (redundant-condition), `W3003` (array-size-mismatch).

### 8.6 Function Scope

All functions in EZ are declared at the top level. Nested function declarations are not permitted. Anonymous functions (lambdas/closures) are not supported.

---

## 9. Modules

### 9.1 Module Declaration

```
module_decl = "module" identifier .
```

A source file may declare its module at the top of the file:

```ez
module utils
```

### 9.2 Imports

```
import_decl = "import" [ "&" "use" ] import_path { "," import_path } .
import_path = "@" identifier | string_literal .
```

Standard library modules are prefixed with `@`:

```ez
import @std
import @arrays, @maps, @strings
```

Local modules use relative paths:

```ez
import "./models"
import "./utils/helpers"
```

### 9.3 Combined Import and Use

The `import & use` syntax combines importing and using in a single statement:

```ez
import & use @std
```

This is equivalent to:

```ez
import @std
using std
```

Multiple modules can be combined:

```ez
import & use @std, @arrays, @strings
```

### 9.5 Using Declaration

The `using` declaration brings module members into scope for unqualified access:

```ez
import @std
using std

println("Hello")  // Instead of std.println
```

Multiple modules can be listed:

```ez
using std, arrays, strings
```

### 9.6 Module Member Access

Without `using`, module members are accessed with dot notation:

```ez
import @std
std.println("Hello")
```

With `using`:

```ez
import @std
using std
println("Hello")
```

---

## 10. Standard Library

The EZ standard library consists of 20 modules providing core functionality.

### 10.1 Core Module (`@std`)

The core module provides fundamental I/O, type conversion, and utility functions.

#### Output Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `println` | `(...values) -> nil` | Print values with newline |
| `print` | `(...values) -> nil` | Print values without newline |
| `eprintln` | `(...values) -> nil` | Print to stderr with newline |
| `eprint` | `(...values) -> nil` | Print to stderr without newline |

#### Input Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `input` | `() -> string` | Read line from stdin |
| `read_int` | `() -> (int, Error)` | Read integer from stdin |

#### Type Conversion Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `int` | `(value) -> int` | Convert to int |
| `uint` | `(value) -> uint` | Convert to uint |
| `float` | `(value) -> float` | Convert to float |
| `string` | `(value) -> string` | Convert to string |
| `char` | `(value) -> char` | Convert to char |
| `byte` | `(value) -> byte` | Convert to byte |

#### Sized Integer Conversions

| Function | Description |
|----------|-------------|
| `i8`, `i16`, `i32`, `i64`, `i128`, `i256` | Convert to signed integers |
| `u8`, `u16`, `u32`, `u64`, `u128`, `u256` | Convert to unsigned integers |
| `f32`, `f64` | Convert to sized floats |

#### Utility Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `len` | `(collection) -> int` | Length of array, string, or map |
| `typeof` | `(value) -> string` | Type name as string |
| `copy` | `(value) -> T` | Create deep copy |
| `new` | `(Type) -> Type` | Create zero-initialized instance |
| `ref` | `(value) -> T` | Create reference to value |
| `error` | `(message string) -> Error` | Create error value |
| `assert` | `(condition bool, message string)` | Assert condition is true |
| `panic` | `(message string) -> nil` | Terminate with error message |
| `exit` | `(code int) -> nil` | Exit program with code |

**Reference behavior with `ref()`:**

The `ref()` function creates a reference to an existing value. The mutability of the reference depends on the variable declaration:

```ez
temp arr [int] = {1, 2, 3}

// temp ref is mutable - can modify through the reference
temp r1 = ref(arr)
arrays.append(r1, 4)  // OK - modifies arr

// const ref is read-only - can read but not modify
const r2 = ref(arr)
temp val = r2[0]      // OK - can read
arrays.append(r2, 5)  // ERROR - cannot modify through const ref

// const ref sees changes made to the original
arrays.append(arr, 6)
println(r2[4])        // Prints 6 - r2 sees the change
```

#### Sleep Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `sleep_seconds` | `(seconds int) -> nil` | Sleep for seconds |
| `sleep_milliseconds` | `(ms int) -> nil` | Sleep for milliseconds |
| `sleep_nanoseconds` | `(ns int) -> nil` | Sleep for nanoseconds |

#### Constants

- `EXIT_SUCCESS` = 0
- `EXIT_FAILURE` = 1

### 10.2 Arrays Module (`@arrays`)

#### Query Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_empty` | `(arr [T]) -> bool` | Check if array is empty |
| `get` | `(arr [T], index int) -> T` | Get element at index |
| `first` | `(arr [T]) -> T` | Get first element |
| `last` | `(arr [T]) -> T` | Get last element |
| `contains` | `(arr [T], value T) -> bool` | Check if value exists |
| `index` | `(arr [T], value T) -> int` | First index of value (-1 if not found) |
| `last_index` | `(arr [T], value T) -> int` | Last index of value |
| `count` | `(arr [T], value T) -> int` | Count occurrences |

#### Modification Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `append` | `(&arr [T], ...values T)` | Append elements |
| `unshift` | `(&arr [T], ...values T) -> [T]` | Prepend elements |
| `insert` | `(&arr [T], index int, value T)` | Insert at index |
| `set` | `(&arr [T], index int, value T)` | Set element at index |
| `pop` | `(&arr [T]) -> T` | Remove and return last element |
| `shift` | `(&arr [T]) -> T` | Remove and return first element |
| `remove_at` | `(&arr [T], index int)` | Remove element at index |
| `remove_value` | `(&arr [T], value T)` | Remove first occurrence |
| `remove_all` | `(&arr [T], value T)` | Remove all occurrences |
| `clear` | `(&arr [T])` | Remove all elements |
| `sort` | `(&arr [T])` | Sort ascending in-place |
| `sort_desc` | `(&arr [T])` | Sort descending in-place |
| `shuffle` | `(&arr [T])` | Shuffle in-place |
| `fill` | `(&arr [T], value T)` | Fill all elements with value |

#### Transformation Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `reverse` | `(arr [T]) -> [T]` | Return reversed copy |
| `slice` | `(arr [T], start int, end int) -> [T]` | Return slice |
| `take` | `(arr [T], n int) -> [T]` | Return first n elements |
| `drop` | `(arr [T], n int) -> [T]` | Drop first n elements |
| `concat` | `(...arrs [T]) -> [T]` | Concatenate arrays |
| `zip` | `(arr1 [T], arr2 [U]) -> [[T,U]]` | Zip two arrays |
| `flatten` | `(arr [[T]]) -> [T]` | Flatten nested arrays |
| `unique` | `(arr [T]) -> [T]` | Return unique elements |
| `duplicates` | `(arr [T]) -> [T]` | Return duplicate elements |
| `repeat` | `(value T, count int) -> [T]` | Create array with repeated value |
| `join` | `(arr [T], sep string) -> string` | Join with separator |
| `chunk` | `(arr [T], size int) -> [[T]]` | Split into chunks |

#### Computation Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `sum` | `(arr [number]) -> number` | Sum all elements |
| `product` | `(arr [number]) -> number` | Multiply all elements |
| `min` | `(arr [T]) -> T` | Minimum element |
| `max` | `(arr [T]) -> T` | Maximum element |
| `avg` | `(arr [number]) -> float` | Average |
| `all_equal` | `(arr [T]) -> bool` | Check if all elements equal |
| `equals` | `(arr1 [T], arr2 [T]) -> bool` | Compare two arrays |

### 10.3 Strings Module (`@strings`)

#### Case Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `upper` | `(s string) -> string` | Convert to uppercase |
| `lower` | `(s string) -> string` | Convert to lowercase |
| `capitalize` | `(s string) -> string` | Capitalize first letter |
| `title` | `(s string) -> string` | Convert to title case |

#### Query Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_empty` | `(s string) -> bool` | Check if empty (after trim) |
| `is_numeric` | `(s string) -> bool` | Check if all digits |
| `is_alpha` | `(s string) -> bool` | Check if all letters |
| `is_alphanumeric` | `(s string) -> bool` | Check if all alphanumeric |
| `is_whitespace` | `(s string) -> bool` | Check if whitespace only |
| `is_lowercase` | `(s string) -> bool` | Check if all letters lowercase |
| `is_uppercase` | `(s string) -> bool` | Check if all letters uppercase |
| `is_ascii` | `(s string) -> bool` | Check if all characters are ASCII |
| `contains` | `(s string, sub string) -> bool` | Check if contains substring |
| `starts_with` | `(s string, prefix string) -> bool` | Check prefix |
| `ends_with` | `(s string, suffix string) -> bool` | Check suffix |
| `index` | `(s string, sub string) -> int` | First index of substring |
| `last_index` | `(s string, sub string) -> int` | Last index of substring |
| `count` | `(s string, sub string) -> int` | Count occurrences |
| `compare` | `(s1 string, s2 string) -> int` | Compare strings (-1, 0, 1) |

#### Transformation Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `trim` | `(s string) -> string` | Trim whitespace |
| `trim_left` | `(s string) -> string` | Trim left whitespace |
| `trim_right` | `(s string) -> string` | Trim right whitespace |
| `replace` | `(s string, old string, new string) -> string` | Replace all occurrences |
| `replace_n` | `(s string, old string, new string, n int) -> string` | Replace first n |
| `repeat` | `(s string, count int) -> string` | Repeat string |
| `reverse` | `(s string) -> string` | Reverse string |
| `truncate` | `(s string, length int, suffix string) -> string` | Truncate with suffix |
| `pad_left` | `(s string, width int, pad string) -> string` | Left pad |
| `pad_right` | `(s string, width int, pad string) -> string` | Right pad |
| `center` | `(s string, width int, pad string) -> string` | Center with padding |
| `insert` | `(s string, position int, sub string) -> string` | Insert at position |
| `remove` | `(s string, sub string) -> string` | Remove first occurrence |
| `remove_all` | `(s string, sub string) -> string` | Remove all occurrences |

#### Conversion Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `split` | `(s string, sep string) -> [string]` | Split into array |
| `join` | `(arr [string], sep string) -> string` | Join array |
| `chars` | `(s string) -> [char]` | Convert to char array |
| `from_chars` | `(chars [char]) -> string` | Create from char array |
| `slice` | `(s string, start int, end int) -> string` | Extract substring |
| `lines` | `(s string) -> [string]` | Split by newlines |
| `words` | `(s string) -> [string]` | Split by whitespace |
| `char_at` | `(s string, index int) -> string` | Character at index |
| `to_int` | `(s string) -> int` | Parse integer |
| `to_float` | `(s string) -> float` | Parse float |
| `to_bool` | `(s string) -> bool` | Parse boolean |

### 10.4 Maps Module (`@maps`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_empty` | `(m map[K:V]) -> bool` | Check if empty |
| `contains` | `(m map[K:V], key K) -> bool` | Check if key exists |
| `contains_value` | `(m map[K:V], value V) -> bool` | Check if value exists |
| `get` | `(m map[K:V], key K, default V) -> V` | Get value or default |
| `set` | `(&m map[K:V], key K, value V)` | Set key-value pair |
| `remove` | `(&m map[K:V], key K) -> bool` | Remove key |
| `clear` | `(&m map[K:V])` | Remove all entries |
| `get_or_set` | `(&m map[K:V], key K, default V) -> V` | Get or set default |
| `update` | `(&m map[K:V], ...maps map[K:V])` | Update with other maps |
| `merge` | `(...maps map[K:V]) -> map[K:V]` | Merge maps (non-destructive) |
| `keys` | `(m map[K:V]) -> [K]` | Get all keys |
| `values` | `(m map[K:V]) -> [V]` | Get all values |
| `invert` | `(m map[K:V]) -> map[V:K]` | Swap keys and values |
| `equals` | `(m1 map[K:V], m2 map[K:V]) -> bool` | Compare maps |
| `to_array` | `(m map[K:V]) -> [[K,V]]` | Convert to array of pairs |
| `from_array` | `(pairs [[K,V]]) -> map[K:V]` | Create from pairs |

### 10.5 Math Module (`@math`)

#### Basic Arithmetic

| Function | Signature | Description |
|----------|-----------|-------------|
| `add` | `(a number, b number) -> number` | Addition |
| `sub` | `(a number, b number) -> number` | Subtraction |
| `mul` | `(a number, b number) -> number` | Multiplication |
| `div` | `(a number, b number) -> float` | Division |
| `mod` | `(a number, b number) -> number` | Modulo |
| `abs` | `(n number) -> number` | Absolute value |
| `neg` | `(n number) -> number` | Negation |
| `sign` | `(n number) -> int` | Sign (-1, 0, 1) |

#### Min/Max/Clamp

| Function | Signature | Description |
|----------|-----------|-------------|
| `min` | `(...numbers) -> number` | Minimum value |
| `max` | `(...numbers) -> number` | Maximum value |
| `clamp` | `(value number, min number, max number) -> number` | Clamp to range |

#### Rounding

| Function | Signature | Description |
|----------|-----------|-------------|
| `floor` | `(n number) -> int` | Floor |
| `ceil` | `(n number) -> int` | Ceiling |
| `round` | `(n number) -> int` | Round |
| `trunc` | `(n number) -> int` | Truncate |

#### Powers and Roots

| Function | Signature | Description |
|----------|-----------|-------------|
| `pow` | `(base number, exp number) -> number` | Power |
| `sqrt` | `(n number) -> float` | Square root |
| `cbrt` | `(n number) -> float` | Cube root |
| `hypot` | `(x number, y number) -> float` | Hypotenuse |
| `exp` | `(n number) -> float` | e^n |
| `exp2` | `(n number) -> float` | 2^n |

#### Logarithms

| Function | Signature | Description |
|----------|-----------|-------------|
| `log` | `(n number) -> float` | Natural logarithm |
| `log2` | `(n number) -> float` | Base 2 logarithm |
| `log10` | `(n number) -> float` | Base 10 logarithm |
| `log_base` | `(value number, base number) -> float` | Custom base |

#### Trigonometry

| Function | Signature | Description |
|----------|-----------|-------------|
| `sin` | `(rad number) -> float` | Sine |
| `cos` | `(rad number) -> float` | Cosine |
| `tan` | `(rad number) -> float` | Tangent |
| `asin` | `(n number) -> float` | Arc sine |
| `acos` | `(n number) -> float` | Arc cosine |
| `atan` | `(n number) -> float` | Arc tangent |
| `atan2` | `(y number, x number) -> float` | Arc tangent of y/x |
| `sinh` | `(n number) -> float` | Hyperbolic sine |
| `cosh` | `(n number) -> float` | Hyperbolic cosine |
| `tanh` | `(n number) -> float` | Hyperbolic tangent |
| `deg_to_rad` | `(deg number) -> float` | Degrees to radians |
| `rad_to_deg` | `(rad number) -> float` | Radians to degrees |

#### Random

| Function | Signature | Description |
|----------|-----------|-------------|
| `random` | `() -> float` | Random float [0, 1) |
| `random` | `(max int) -> int` | Random int [0, max) |
| `random` | `(min int, max int) -> int` | Random int [min, max) |
| `random_float` | `(min number, max number) -> float` | Random float [min, max) |

#### Statistical

| Function | Signature | Description |
|----------|-----------|-------------|
| `sum` | `(...numbers) -> number` | Sum |
| `avg` | `(...numbers) -> float` | Average |
| `factorial` | `(n int) -> int` | Factorial |
| `gcd` | `(a int, b int) -> int` | Greatest common divisor |
| `lcm` | `(a int, b int) -> int` | Least common multiple |

#### Number Properties

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_prime` | `(n int) -> bool` | Check if prime |
| `is_even` | `(n int) -> bool` | Check if even |
| `is_odd` | `(n int) -> bool` | Check if odd |
| `is_inf` | `(n number) -> bool` | Check if infinite |
| `is_nan` | `(n number) -> bool` | Check if NaN |
| `is_finite` | `(n number) -> bool` | Check if finite (not infinite or NaN) |

#### Utility

| Function | Signature | Description |
|----------|-----------|-------------|
| `lerp` | `(a number, b number, t number) -> float` | Linear interpolation |
| `map_range` | `(value, in_min, in_max, out_min, out_max) -> float` | Map to new range |
| `distance` | `(x1, y1, x2, y2 number) -> float` | Euclidean distance |

#### Constants

- `PI` - Pi (3.14159...)
- `E` - Euler's number (2.71828...)
- `PHI` - Golden ratio (1.61803...)
- `SQRT2` - Square root of 2
- `LN2` - Natural log of 2
- `LN10` - Natural log of 10
- `TAU` - Tau (2*Pi)
- `INF` - Positive infinity
- `NEG_INF` - Negative infinity
- `EPSILON` - Smallest representable float difference

### 10.6 Time Module (`@time`)

#### Current Time

| Function | Signature | Description |
|----------|-----------|-------------|
| `now` | `() -> int` | Current Unix timestamp (seconds) |
| `now_ms` | `() -> int` | Current Unix timestamp (milliseconds) |
| `now_ns` | `() -> int` | Current Unix timestamp (nanoseconds) |

#### Sleep

| Function | Signature | Description |
|----------|-----------|-------------|
| `sleep` | `(seconds number)` | Sleep for seconds |
| `sleep_ms` | `(ms int)` | Sleep for milliseconds |

#### Time Components

| Function | Signature | Description |
|----------|-----------|-------------|
| `year` | `(timestamp int) -> int` | Get year |
| `month` | `(timestamp int) -> int` | Get month (1-12) |
| `day` | `(timestamp int) -> int` | Get day of month |
| `hour` | `(timestamp int) -> int` | Get hour |
| `minute` | `(timestamp int) -> int` | Get minute |
| `second` | `(timestamp int) -> int` | Get second |
| `weekday` | `(timestamp int) -> int` | Get day of week (0=Sunday) |
| `weekday_name` | `(timestamp int) -> string` | Get day name |
| `month_name` | `(timestamp int) -> string` | Get month name |
| `day_of_year` | `(timestamp int) -> int` | Get day of year |
| `quarter` | `(timestamp int) -> int` | Get quarter (1-4) |
| `week_of_year` | `(timestamp int) -> int` | Get ISO week number (1-53) |
| `timezone` | `() -> string` | Get local timezone name |
| `utc_offset` | `() -> int` | Get local UTC offset in seconds |

#### Formatting

| Function | Signature | Description |
|----------|-----------|-------------|
| `format` | `(format string, timestamp int) -> string` | Format time |
| `iso` | `(timestamp int) -> string` | ISO 8601 string |
| `date` | `(timestamp int) -> string` | Date (YYYY-MM-DD) |
| `clock` | `(timestamp int) -> string` | Time (HH:MM:SS) |

#### Parsing and Creation

| Function | Signature | Description |
|----------|-----------|-------------|
| `parse` | `(s string, format string) -> int` | Parse string to timestamp |
| `make` | `(year, month, day, hour, minute, second int) -> int` | Create timestamp |
| `from_unix` | `(seconds int) -> int` | Convert Unix seconds to timestamp |
| `from_unix_ms` | `(milliseconds int) -> int` | Convert Unix milliseconds to timestamp |
| `to_unix` | `(timestamp int) -> int` | Convert timestamp to Unix seconds |
| `to_unix_ms` | `(timestamp int) -> int` | Convert timestamp to Unix milliseconds |

#### Arithmetic

| Function | Signature | Description |
|----------|-----------|-------------|
| `add_seconds` | `(timestamp int, seconds int) -> int` | Add seconds |
| `add_minutes` | `(timestamp int, minutes int) -> int` | Add minutes |
| `add_hours` | `(timestamp int, hours int) -> int` | Add hours |
| `add_days` | `(timestamp int, days int) -> int` | Add days |
| `add_weeks` | `(timestamp int, weeks int) -> int` | Add weeks |
| `add_months` | `(timestamp int, months int) -> int` | Add months |
| `add_years` | `(timestamp int, years int) -> int` | Add years |

#### Differences

| Function | Signature | Description |
|----------|-----------|-------------|
| `diff` | `(ts1 int, ts2 int) -> int` | Difference in seconds |
| `diff_days` | `(ts1 int, ts2 int) -> int` | Difference in days |
| `diff_hours` | `(ts1 int, ts2 int) -> int` | Difference in hours |
| `diff_minutes` | `(ts1 int, ts2 int) -> int` | Difference in minutes |

#### Comparisons

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_before` | `(ts1 int, ts2 int) -> bool` | Check if ts1 < ts2 |
| `is_after` | `(ts1 int, ts2 int) -> bool` | Check if ts1 > ts2 |
| `is_leap_year` | `(year int) -> bool` | Check if leap year |
| `days_in_month` | `(year int, month int) -> int` | Days in month |
| `is_weekend` | `(timestamp int) -> bool` | Check if weekend |
| `is_weekday` | `(timestamp int) -> bool` | Check if weekday |
| `is_today` | `(timestamp int) -> bool` | Check if today |
| `is_same_day` | `(ts1 int, ts2 int) -> bool` | Check if same day |
| `relative` | `(timestamp int) -> string` | Human-readable relative time (e.g., "2 hours ago") |

#### Period Boundaries

| Function | Signature | Description |
|----------|-----------|-------------|
| `start_of_day` | `(timestamp int) -> int` | Start of day |
| `end_of_day` | `(timestamp int) -> int` | End of day |
| `start_of_month` | `(timestamp int) -> int` | Start of month |
| `end_of_month` | `(timestamp int) -> int` | End of month |
| `start_of_year` | `(timestamp int) -> int` | Start of year |
| `end_of_year` | `(timestamp int) -> int` | End of year |

#### Performance Timing

| Function | Signature | Description |
|----------|-----------|-------------|
| `tick` | `() -> int` | High-resolution timestamp in nanoseconds |
| `elapsed_ms` | `(start_tick int) -> float` | Milliseconds elapsed since a tick |

#### Constants

Weekdays: `SUNDAY` (0) through `SATURDAY` (6)

Months: `JANUARY` (1) through `DECEMBER` (12)

Durations: `SECOND` (1), `MINUTE` (60), `HOUR` (3600), `DAY` (86400), `WEEK` (604800)

### 10.7 Random Module (`@random`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `float` | `() -> float` | Random float [0.0, 1.0) |
| `float` | `(min number, max number) -> float` | Random float [min, max) |
| `int` | `(max int) -> int` | Random int [0, max) |
| `int` | `(min int, max int) -> int` | Random int [min, max) |
| `bool` | `() -> bool` | Random boolean |
| `byte` | `() -> byte` | Random byte [0, 255] |
| `char` | `() -> char` | Random printable char |
| `char` | `(min, max) -> char` | Random char in range |
| `choice` | `(arr [T]) -> T` | Random element from array |
| `shuffle` | `(arr [T]) -> [T]` | Return shuffled copy |
| `sample` | `(arr [T], n int) -> [T]` | Return n unique random elements |

### 10.8 JSON Module (`@json`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `encode` | `(value) -> (string, Error)` | Encode to JSON string |
| `decode` | `(text string) -> (any, Error)` | Decode to dynamic type |
| `decode` | `(text string, Type) -> (Type, Error)` | Decode to typed struct |
| `pretty` | `(value, indent string) -> (string, Error)` | Pretty print JSON |
| `is_valid` | `(text string) -> bool` | Check if valid JSON |

### 10.9 IO Module (`@io`)

#### File Reading

| Function | Signature | Description |
|----------|-----------|-------------|
| `read_file` | `(path string) -> (string, Error)` | Read file as string |
| `read_bytes` | `(path string) -> ([byte], Error)` | Read file as bytes |

#### File Writing

| Function | Signature | Description |
|----------|-----------|-------------|
| `write_file` | `(path string, content string) -> (bool, Error)` | Write file |
| `write_bytes` | `(path string, data [byte]) -> (bool, Error)` | Write bytes |
| `append_file` | `(path string, content string) -> (bool, Error)` | Append to file |

#### File Operations

| Function | Signature | Description |
|----------|-----------|-------------|
| `file_exists` | `(path string) -> bool` | Check if file exists |
| `is_file` | `(path string) -> bool` | Check if path is file |
| `is_directory` | `(path string) -> bool` | Check if path is directory |
| `is_readable` | `(path string) -> bool` | Check if readable |
| `is_writable` | `(path string) -> bool` | Check if writable |
| `file_size` | `(path string) -> (int, Error)` | Get file size |
| `file_extension` | `(path string) -> string` | Get file extension |
| `file_name` | `(path string) -> string` | Get file name |
| `directory_name` | `(path string) -> string` | Get directory path |
| `absolute_path` | `(path string) -> (string, Error)` | Get absolute path |
| `delete_file` | `(path string) -> (bool, Error)` | Delete file |

#### Directory Operations

| Function | Signature | Description |
|----------|-----------|-------------|
| `list_directory` | `(path string) -> ([string], Error)` | List directory contents |
| `create_directory` | `(path string) -> (bool, Error)` | Create directory |
| `create_directories` | `(path string) -> (bool, Error)` | Create recursively |
| `delete_directory` | `(path string) -> (bool, Error)` | Delete empty directory |
| `delete_directory_recursive` | `(path string) -> (bool, Error)` | Delete recursively |

#### Path Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `join_path` | `(...parts string) -> string` | Join path components |
| `normalize_path` | `(path string) -> string` | Normalize path |

### 10.10 OS Module (`@os`)

#### Environment Variables

| Function | Signature | Description |
|----------|-----------|-------------|
| `get_env` | `(name string) -> (string, Error)` | Get environment variable |
| `set_env` | `(name string, value string) -> (bool, Error)` | Set environment variable |
| `unset_env` | `(name string) -> (bool, Error)` | Unset environment variable |
| `env` | `() -> map[string:string]` | Get all environment variables |

#### System Information

| Function | Signature | Description |
|----------|-----------|-------------|
| `args` | `() -> [string]` | Get command-line arguments |
| `cwd` | `() -> (string, Error)` | Get current working directory |
| `chdir` | `(path string) -> (bool, Error)` | Change directory |
| `hostname` | `() -> (string, Error)` | Get machine hostname |
| `username` | `() -> (string, Error)` | Get current username |
| `home_dir` | `() -> (string, Error)` | Get home directory |
| `temp_dir` | `() -> string` | Get temporary directory |
| `pid` | `() -> int` | Get process ID |
| `ppid` | `() -> int` | Get parent process ID |
| `current_os` | `() -> int` | Get current OS |
| `arch` | `() -> string` | Get CPU architecture |
| `exit` | `(code int)` | Exit program |

#### Constants

- `MAC_OS` = 0
- `LINUX` = 1
- `WINDOWS` = 2
- `OTHER` = 3

### 10.11 HTTP Module (`@http`)

#### Request Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `get` | `(url string) -> (Response, Error)` | GET request |
| `post` | `(url string, body string) -> (Response, Error)` | POST request |
| `put` | `(url string, body string) -> (Response, Error)` | PUT request |
| `delete` | `(url string) -> (Response, Error)` | DELETE request |
| `patch` | `(url string, body string) -> (Response, Error)` | PATCH request |
| `head` | `(url string) -> (Response, Error)` | HEAD request |
| `options` | `(url string) -> (Response, Error)` | OPTIONS request |
| `download` | `(url string, path string) -> (int, Error)` | Download file, returns bytes written |
| `parse_url` | `(url string) -> (URL, Error)` | Parse URL into components |
| `build_url` | `(components) -> string` | Build URL from components |

#### Response Type

The `Response` struct contains:
- `status int` - HTTP status code
- `body string` - Response body
- `headers map[string:[string]]` - Response headers

#### Status Constants

`OK` (200), `CREATED` (201), `ACCEPTED` (202), `NO_CONTENT` (204), `MOVED_PERMANENTLY` (301), `FOUND` (302), `NOT_MODIFIED` (304), `BAD_REQUEST` (400), `UNAUTHORIZED` (401), `FORBIDDEN` (403), `NOT_FOUND` (404), `METHOD_NOT_ALLOWED` (405), `CONFLICT` (409), `INTERNAL_SERVER_ERROR` (500), `BAD_GATEWAY` (502), `SERVICE_UNAVAILABLE` (503)

### 10.12 Crypto Module (`@crypto`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `sha256` | `(data string) -> string` | SHA-256 hash (hex) |
| `sha512` | `(data string) -> string` | SHA-512 hash (hex) |
| `md5` | `(data string) -> string` | MD5 hash (hex) |
| `random_bytes` | `(length int) -> [byte]` | Cryptographically secure random bytes |
| `random_hex` | `(length int) -> string` | Cryptographically secure random hex |

### 10.13 Encoding Module (`@encoding`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `base64_encode` | `(s string) -> string` | Encode to base64 |
| `base64_decode` | `(s string) -> (string, Error)` | Decode from base64 |
| `hex_encode` | `(s string) -> string` | Encode to hex |
| `hex_decode` | `(s string) -> (string, Error)` | Decode from hex |
| `url_encode` | `(s string) -> string` | URL percent-encode |
| `url_decode` | `(s string) -> (string, Error)` | URL percent-decode |

### 10.14 UUID Module (`@uuid`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `create` | `() -> string` | Generate UUID v4 with hyphens |
| `create_compact` | `() -> string` | Generate UUID v4 without hyphens |
| `is_valid` | `(s string) -> bool` | Validate UUID format |

#### Constants

- `NIL` - Nil UUID (00000000-0000-0000-0000-000000000000)

### 10.15 Bytes Module (`@bytes`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `from_array` | `(arr [int]) -> [byte]` | Create from integer array |
| `from_string` | `(s string) -> [byte]` | Create from UTF-8 string |
| `from_hex` | `(hex string) -> ([byte], Error)` | Decode hex string |
| `from_base64` | `(b64 string) -> ([byte], Error)` | Decode base64 string |
| `to_string` | `(bytes [byte]) -> string` | Convert to UTF-8 string |
| `to_array` | `(bytes [byte]) -> [int]` | Convert to integer array |
| `to_hex` | `(bytes [byte]) -> string` | Encode to hex string |
| `to_base64` | `(bytes [byte]) -> string` | Encode to base64 string |

### 10.16 Binary Module (`@binary`)

Binary encoding/decoding for integers and floats in little-endian (le) and big-endian (be) formats.

#### 8-bit

| Function | Description |
|----------|-------------|
| `encode_i8`, `decode_i8` | Signed 8-bit |
| `encode_u8`, `decode_u8` | Unsigned 8-bit |

#### 16-bit

| Function | Description |
|----------|-------------|
| `encode_i16_le`, `encode_i16_be`, `decode_i16_le`, `decode_i16_be` | Signed 16-bit |
| `encode_u16_le`, `encode_u16_be`, `decode_u16_le`, `decode_u16_be` | Unsigned 16-bit |

#### 32-bit

| Function | Description |
|----------|-------------|
| `encode_i32_le`, `encode_i32_be`, `decode_i32_le`, `decode_i32_be` | Signed 32-bit |
| `encode_u32_le`, `encode_u32_be`, `decode_u32_le`, `decode_u32_be` | Unsigned 32-bit |

#### 64-bit

| Function | Description |
|----------|-------------|
| `encode_i64_le`, `encode_i64_be`, `decode_i64_le`, `decode_i64_be` | Signed 64-bit |
| `encode_u64_le`, `encode_u64_be`, `decode_u64_le`, `decode_u64_be` | Unsigned 64-bit |

#### Floats

| Function | Description |
|----------|-------------|
| `encode_f32_le`, `encode_f32_be`, `decode_f32_le`, `decode_f32_be` | 32-bit float |
| `encode_f64_le`, `encode_f64_be`, `decode_f64_le`, `decode_f64_be` | 64-bit float |

### 10.17 Database Module (`@db`)

A simple JSON-based key-value database.

| Function | Signature | Description |
|----------|-----------|-------------|
| `open` | `(path string) -> (Database, Error)` | Open/create database |
| `close` | `(db Database) -> Error` | Close database |
| `save` | `(db Database) -> Error` | Save to disk |
| `set` | `(db Database, key string, value)` | Set key-value pair |
| `get` | `(db Database, key string) -> (any, Error)` | Get value by key |
| `has` | `(db Database, key string) -> bool` | Check if key exists |
| `delete` | `(db Database, key string) -> bool` | Delete key |
| `clear` | `(db Database)` | Clear all entries |
| `keys` | `(db Database) -> [string]` | Get all keys |
| `values` | `(db Database) -> [any]` | Get all values |
| `entries` | `(db Database) -> [Entry]` | Get all key-value pairs as Entry structs |
| `length` | `(db Database) -> int` | Get number of entries |

### 10.18 Server Module (`@server`)

A simple HTTP server module for building web services.

| Function | Signature | Description |
|----------|-----------|-------------|
| `router` | `() -> Router` | Create a new router |
| `route` | `(router Router, method string, path string, response Response)` | Add a route |
| `listen` | `(port int, router Router) -> Error` | Start HTTP server on port |
| `text` | `(status int, body string) -> Response` | Create text/plain response |
| `json` | `(status int, data) -> Response` | Create application/json response |
| `html` | `(status int, body string) -> Response` | Create text/html response |

```ez
import @server

do main() {
    temp r = server.router()
    server.route(r, "GET", "/", server.text(200, "Hello!"))
    server.route(r, "GET", "/data", server.json(200, {"status": "ok"}))
    server.listen(8080, r)
}
```

### 10.19 Regex Module (`@regex`)

Regular expression operations using Go's `regexp` syntax.

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_valid` | `(pattern string) -> bool` | Check if pattern is valid |
| `match` | `(pattern string, s string) -> (bool, Error)` | Check if pattern matches |
| `find` | `(pattern string, s string) -> (string, Error)` | First match |
| `find_all` | `(pattern string, s string) -> ([string], Error)` | All matches |
| `find_all_n` | `(pattern string, s string, n int) -> ([string], Error)` | First n matches |
| `replace` | `(pattern string, s string, repl string) -> (string, Error)` | Replace first match |
| `replace_all` | `(pattern string, s string, repl string) -> (string, Error)` | Replace all matches |
| `split` | `(pattern string, s string) -> ([string], Error)` | Split by pattern |
| `groups` | `(pattern string, s string) -> ([string], Error)` | Capture groups from first match |
| `groups_all` | `(pattern string, s string) -> ([[string]], Error)` | Capture groups from all matches |

### 10.20 CSV Module (`@csv`)

Reading and writing CSV (Comma-Separated Values) data.

| Function | Signature | Description |
|----------|-----------|-------------|
| `parse` | `(csv_string string) -> ([[string]], Error)` | Parse CSV string to 2D array |
| `stringify` | `(data [[string]]) -> (string, Error)` | Convert 2D array to CSV string |
| `read` | `(path string, options map) -> ([[string]], Error)` | Read CSV file |
| `headers` | `(path string) -> ([string], Error)` | Read first row (headers) |
| `write` | `(path string, data [[string]], options map) -> (bool, Error)` | Write CSV file |

The `read` and `write` functions accept an optional options map with keys:
- `delimiter` (string) — field delimiter (default: `","`)
- `skip_empty` (bool) — skip empty rows (default: `false`, read only)
- `quote_all` (bool) — quote all fields (default: `false`, write only)

---

## 11. Error Handling

### 11.1 Error Type

The `Error` type represents an error condition. Errors are created with the `error()` function:

```ez
temp err Error = error("something went wrong")
```

### 11.2 Error Returns

Functions that may fail conventionally return a tuple with the result and an Error:

```ez
do read_file(path string) -> (string, Error) {
    if !file_exists(path) {
        return "", error("file not found")
    }
    return contents, nil
}
```

### 11.3 Error Checking

Errors are checked by comparing to `nil`:

```ez
temp content, err = read_file("data.txt")
if err != nil {
    println("Error: ${err}")
    return
}
// Use content
```

### 11.4 Runtime Errors

Certain operations produce runtime errors that terminate program execution:

- Division by zero (int or float)
- Array index out of bounds
- Map key not found
- Invalid type conversion

Runtime errors include location information (file, line, column).

---

## 12. Memory Model

### 12.1 Garbage Collection

EZ uses automatic memory management via the Go runtime's garbage collector. Programmers do not manually allocate or free memory.

### 12.2 Value Semantics

Primitive types (`int`, `uint`, `float`, `string`, `bool`, `char`, `byte`) have value semantics. Assignment creates a copy:

```ez
temp a int = 42
temp b int = a  // b is a copy of a
b = 100         // a is still 42
```

### 12.3 Reference Semantics

Composite types (arrays, maps) have reference semantics for assignment but value semantics for function parameters (unless using mutable parameters).

### 12.4 Deep Copy

The `copy()` function creates a deep copy of any value, including nested structures:

```ez
temp original = Person{name: "Alice", age: 30}
temp duplicate = copy(original)
duplicate.age = 31  // original.age is still 30
```

### 12.5 Zero Values

The `new()` function creates a zero-initialized instance of a type:

| Type | Zero Value |
|------|------------|
| `int/uint` | `0` |
| `float` | `0.0` |
| `string` | `""` |
| `bool` | `false` |
| `char` | `'\0'` |
| `byte` | `0` |
| `map[K:V]` | `{}` |
| struct | All fields zero-initialized |

---

## 13. Program Execution

### 13.1 Program Structure

An EZ program consists of one or more source files. Each file may contain:

1. Module declaration (optional)
2. Import declarations
3. Using declarations
4. Top-level declarations (functions, structs, enums, constants)

### 13.2 Entry Point

Every EZ program must define a `main` function with no parameters and no return value:

```ez
do main() {
    // Program starts here
}
```

The `main` function is not called explicitly; it is invoked automatically when the program runs.

### 13.3 Evaluation Order

Expressions are evaluated left-to-right. Function arguments are evaluated before the function is called.

Short-circuit evaluation applies to `&&` and `||`:

```ez
// If a is false, b() is not called
if a && b() { ... }

// If a is true, b() is not called
if a || b() { ... }
```

### 13.4 Program Termination

A program terminates when:

1. The `main` function returns
2. A runtime error occurs

---

## Appendix A: Grammar Summary

```ebnf
program        = { declaration } .
declaration    = module_decl | import_decl | using_decl | func_decl
               | struct_decl | enum_decl | const_decl .

module_decl    = "module" identifier .
import_decl    = "import" [ "&" "use" ] import_path { "," import_path } .
import_path    = "@" identifier | string_literal .
using_decl     = "using" identifier { "," identifier } .

func_decl      = [ "private" ] "do" identifier "(" [ param_list ] ")" [ "->" return_type ] block .
struct_decl    = "const" identifier "struct" "{" { field_decl } "}" .
enum_decl      = [ "#flags" | "#enum" "(" "int" ")" ] "const" identifier "enum"
               "{" enum_member { enum_member } "}" .
const_decl     = [ "private" ] "const" identifier [ type ] "=" expression .
var_decl       = "temp" identifier type "=" expression .

statement      = var_decl | const_decl | if_stmt | for_stmt | for_each_stmt
               | while_stmt | loop_stmt | when_stmt | return_stmt | break_stmt
               | continue_stmt | ensure_stmt | expr_stmt .

if_stmt        = "if" expression block { "or" expression block } [ "otherwise" block ] .
for_stmt       = "for" [ "(" ] identifier [ type ] "in" range_expr [ ")" ] block .
for_each_stmt  = "for_each" [ "(" ] [ identifier "," ] identifier "in" expression [ ")" ] block .
while_stmt     = "as_long_as" expression block .
loop_stmt      = "loop" block .
when_stmt      = [ "#strict" ] "when" expression "{" { when_case } [ default_case ] "}" .
when_case      = "is" pattern { "," pattern } block .
default_case   = "default" block .
return_stmt    = "return" [ expression { "," expression } ] .
break_stmt     = "break" .
continue_stmt  = "continue" .
ensure_stmt    = "ensure" call_expr .

expression     = /* standard expression grammar with operators */ .
block          = "{" { statement } "}" .
```

---

## Appendix B: Error Codes

### Overview

| Range | Category | Description |
|-------|----------|-------------|
| E1xxx | Lexer | Tokenization and lexical analysis errors |
| E2xxx | Parser | Syntax and parsing errors |
| E3xxx | Type Checker | Type system errors |
| E4xxx | Resolver | Name resolution and reference errors |
| E5xxx | Runtime | General runtime errors |
| E6xxx | Import | Module import and loading errors |
| E7xxx | Stdlib | Standard library argument validation errors |
| E8xxx | Math | Math module domain errors |
| E9xxx | Arrays | Array operation errors |
| E10xxx | Strings | String operation errors |
| E11xxx | Time | Time module errors |
| E12xxx | Maps | Map operation errors |
| E13xxx | JSON | JSON encoding/decoding errors |
| E14xxx | HTTP | HTTP client errors |
| E15xxx | Crypto | Cryptography errors |
| E16xxx | Encoding | Encoding/decoding errors |
| E17xxx | DB | Database errors |
| E18xxx | Server | HTTP server errors |
| W1xxx | Warning | Code style warnings |
| W2xxx | Warning | Potential bug warnings |
| W3xxx | Warning | Code quality warnings |
| W4xxx | Warning | Module warnings |

### E1xxx — Lexer Errors

| Code | Name | Description |
|------|------|-------------|
| E1001 | illegal-character | Illegal character in source |
| E1002 | illegal-or-character | Illegal OR character in source |
| E1003 | unclosed-comment | Multi-line comment not closed |
| E1004 | unclosed-string | String literal not closed |
| E1005 | unclosed-char | Character literal not closed |
| E1006 | invalid-escape-string | Invalid escape sequence in string |
| E1007 | invalid-escape-char | Invalid escape sequence in character |
| E1008 | empty-char-literal | Character literal is empty |
| E1009 | multi-char-literal | Character literal contains multiple characters |
| E1010 | invalid-number-format | Invalid numeric literal format |
| E1011 | number-consecutive-underscores | Consecutive underscores in number |
| E1012 | number-leading-underscore | Number starts with underscore |
| E1013 | number-trailing-underscore | Number ends with underscore |
| E1014 | number-underscore-before-decimal | Underscore before decimal point |
| E1015 | number-underscore-after-decimal | Underscore after decimal point |
| E1016 | number-trailing-decimal | Decimal point without digits |
| E1017 | unclosed-raw-string | Raw string literal not closed |

### E2xxx — Parser Errors

| Code | Name | Description |
|------|------|-------------|
| E2001 | unexpected-token | Unexpected token encountered |
| E2002 | missing-token | Expected token not found |
| E2003 | missing-expression | Expected expression |
| E2004 | unclosed-brace | Missing closing brace |
| E2005 | unclosed-paren | Missing closing parenthesis |
| E2006 | unclosed-bracket | Missing closing bracket |
| E2007 | unclosed-interpolation | String interpolation not closed |
| E2008 | invalid-assignment-target | Cannot assign to this expression |
| E2009 | using-after-declarations | `using` statement must come before declarations |
| E2010 | using-before-import | Cannot use module before importing |
| E2011 | const-requires-value | `const` must be initialized |
| E2012 | duplicate-parameter | Parameter name already used |
| E2013 | duplicate-field | Field name already used |
| E2014 | missing-parameter-type | Parameter missing type annotation |
| E2015 | missing-return-type | Expected return type after arrow |
| E2016 | empty-enum | Enum must have at least one value |
| E2017 | trailing-comma-array | Trailing comma in array literal |
| E2018 | trailing-comma-call | Trailing comma in function call |
| E2019 | nested-function | Function inside function not allowed |
| E2020 | reserved-variable-name | Variable name is reserved |
| E2021 | reserved-function-name | Function name is reserved |
| E2022 | reserved-type-name | Type name is reserved |
| E2023 | duplicate-declaration | Name already declared in scope |
| E2024 | invalid-type-name | Expected valid type name |
| E2025 | invalid-array-size | Array size must be integer |
| E2026 | invalid-enum-type | Enum type must be primitive |
| E2027 | integer-parse-error | Cannot parse integer literal |
| E2028 | float-parse-error | Cannot parse float literal |
| E2029 | expected-identifier | Expected identifier |
| E2030 | expected-block | Expected block statement |
| E2031 | string-enum-requires-values | String enum needs explicit values |
| E2032 | const-array-requires-size | Const array must have fixed size |
| E2033 | reserved-param-name | Parameter name is reserved |
| E2034 | invalid-struct-field | Invalid struct field name |
| E2035 | invalid-enum-value | Invalid enum value name |
| E2036 | import-inside-block | Import must be at file level |
| E2037 | reserved-struct-name | Struct name is reserved |
| E2038 | reserved-enum-name | Enum name is reserved |
| E2039 | required-after-default | Required parameter after parameter with default |
| E2040 | mutable-with-default | Mutable parameter cannot have default value |
| E2041 | when-missing-default | `when` statement requires a `default` case |
| E2042 | when-strict-has-default | `#strict when` cannot have a `default` case |
| E2043 | when-duplicate-case | Duplicate case value in `when` statement |
| E2044 | when-float-not-allowed | Float type not allowed in `when` statement |
| E2045 | when-strict-non-enum | `#strict` only allowed on enum `when` statements |
| E2046 | when-strict-missing-case | `#strict when` missing enum case |
| E2047 | when-type-as-condition | `when` condition must be a value, not a type name |
| E2048 | when-bool-condition | `when` condition cannot be boolean; use `if`/`otherwise` |
| E2049 | when-nil-condition | `when` condition cannot be nil |
| E2050 | when-collection-condition | `when` condition cannot be an array or map |
| E2051 | suppress-invalid-target | `#suppress` can only be applied at file scope or to functions |
| E2052 | suppress-invalid-code | Warning code cannot be suppressed |
| E2053 | type-definition-in-function | Type definitions must be at file level |
| E2054 | when-strict-non-enum-case | `#strict when` requires explicit enum member values |
| E2055 | strict-invalid-target | `#strict` can only be applied to `when` statements |
| E2056 | executable-at-file-scope | Executable statement not allowed at file scope |
| E2057 | invalid-interpolation-syntax | Invalid string interpolation syntax |
| E2058 | doc-invalid-target | `#doc` can only be applied to functions, structs, or enums |
| E2059 | doc-orphaned | `#doc` must be followed by a declaration |
| E2060 | doc-duplicate | Only one `#doc` attribute allowed per declaration |

### E3xxx — Type Errors

| Code | Name | Description |
|------|------|-------------|
| E3001 | type-mismatch | Types do not match |
| E3002 | invalid-operator-for-type | Operator not valid for type |
| E3003 | invalid-index-type | Index must be integer |
| E3004 | invalid-index-assignment-type | Invalid type for index assignment |
| E3005 | cannot-convert-to-int | Cannot convert value to integer |
| E3006 | cannot-convert-to-float | Cannot convert value to float |
| E3007 | cannot-convert-array | Cannot convert array to scalar |
| E3008 | undefined-type | Type is not defined |
| E3009 | undefined-type-in-struct | Field type not defined |
| E3010 | undefined-param-type | Parameter type not defined |
| E3011 | undefined-return-type | Return type not defined |
| E3012 | return-type-mismatch | Return type does not match declaration |
| E3013 | return-count-mismatch | Wrong number of return values |
| E3014 | incompatible-binary-types | Incompatible types for binary operator |
| E3015 | not-callable | Value is not callable |
| E3016 | not-indexable | Value is not indexable |
| E3017 | not-iterable | Value is not iterable |
| E3018 | array-literal-required | Array type requires array literal |
| E3019 | signed-to-unsigned | Cannot assign signed type to unsigned |
| E3020 | negative-to-unsigned | Cannot assign negative value to unsigned type |
| E3021 | type-change-not-allowed | Cannot change type of variable after declaration |
| E3022 | undefined-struct-field | Struct field not found |
| E3023 | enum-value-not-found | Enum value not found |
| E3024 | missing-return-statement | Function must return a value |
| E3025 | byte-value-out-of-range | Byte value must be between 0 and 255 |
| E3026 | byte-array-element-out-of-range | Byte array element must be between 0 and 255 |
| E3027 | const-to-mutable-param | Cannot pass immutable variable to mutable parameter |
| E3028 | enum-mixed-types | Enum members must all have the same type |
| E3029 | float-enum-map-key | Float-based enum cannot be used as map key |
| E3030 | type-as-value | Type definition cannot be used as a runtime value |
| E3031 | function-as-value | Function cannot be used as a value without calling it |
| E3032 | enum-type-mismatch | Cannot compare values from different enum types |
| E3033 | duplicate-enum-value | Enum contains duplicate values |
| E3034 | any-type-not-allowed | `any` type is reserved for internal use |
| E3035 | not-all-paths-return | Not all code paths return a value |
| E3036 | integer-out-of-range | Integer literal exceeds type range |
| E3037 | invalid-private-usage | `private` modifier cannot be used here |
| E3038 | void-type-not-allowed | `void` is not a valid type |
| E3039 | ensure-expects-call | `ensure` expects a function call |
| E3040 | multi-return-to-single-var | Cannot assign multiple return values to single variable |
| E3041 | array-size-overflow | Array literal has more elements than declared size |

### E4xxx — Reference Errors

| Code | Name | Description |
|------|------|-------------|
| E4001 | undefined-variable | Variable not found in scope |
| E4002 | undefined-function | Function not defined |
| E4003 | undefined-field | Field does not exist on type |
| E4004 | undefined-enum-value | Enum value does not exist |
| E4005 | undefined-module-member | Member not found in module |
| E4006 | undefined-type-new | Type not found for `new` expression |
| E4007 | module-not-imported | Module has not been imported |
| E4008 | ambiguous-function | Function exists in multiple modules |
| E4009 | no-main-function | Program has no entry point |
| E4010 | nil-member-access | Cannot access member of nil |
| E4011 | member-access-invalid-type | Type does not support member access |
| E4012 | shadows-type | Variable shadows a type definition |
| E4013 | shadows-function | Variable shadows a function |
| E4014 | shadows-module | Variable shadows an imported module |
| E4015 | shadows-used-module-function | Variable shadows a function from a `using` module |
| E4016 | loop-variable-shadows-loop-variable | Loop variable shadows outer loop variable |

### E5xxx — Runtime Errors

| Code | Name | Description |
|------|------|-------------|
| E5001 | division-by-zero | Cannot divide by zero |
| E5002 | modulo-by-zero | Cannot modulo by zero |
| E5003 | index-out-of-bounds | Index outside valid range |
| E5004 | index-empty-collection | Cannot index empty collection |
| E5005 | nil-operation | Cannot perform operation on nil |
| E5006 | immutable-variable | Cannot modify `const` variable |
| E5007 | immutable-array | Cannot modify `const` array |
| E5008 | wrong-argument-count | Incorrect number of arguments |
| E5009 | break-outside-loop | `break` not inside loop |
| E5010 | continue-outside-loop | `continue` not inside loop |
| E5011 | return-value-unused | Function return value not used |
| E5012 | multi-assign-count-mismatch | Assignment value count mismatch |
| E5013 | range-start-not-integer | Range start must be integer |
| E5014 | range-end-not-integer | Range end must be integer |
| E5015 | postfix-requires-identifier | Postfix operator needs variable |
| E5016 | immutable-parameter | Cannot modify read-only parameter |
| E5017 | immutable-struct | Cannot modify field of `const` struct |
| E5018 | max-recursion-depth | Maximum recursion depth exceeded |
| E5019 | range-step-not-integer | Range step must be integer |
| E5020 | range-in-operand-not-integer | Value checked against range must be integer |
| E5021 | panic | Explicit `panic()` called |
| E5022 | assertion-failed | Assertion condition was false |
| E5023 | postfix-requires-integer | Postfix operator needs integer operand |
| E5024 | return-type-mismatch | Return type mismatch at runtime |

### E6xxx — Import Errors

| Code | Name | Description |
|------|------|-------------|
| E6001 | circular-import | Circular import detected |
| E6002 | module-not-found | Module file not found |
| E6003 | invalid-module-format | Module has invalid format |
| E6004 | module-load-error | Failed to load module |
| E6005 | module-name-mismatch | Module name does not match directory |
| E6006 | module-name-conflict | Files in directory declare different module names |
| E6007 | internal-import-denied | Cannot import from `internal/` directory outside package |
| E6008 | module-member-readonly | Cannot assign to module member |
| E6009 | private-access-denied | Cannot access private member from outside module |

### E7xxx — Stdlib Validation Errors

| Code | Name | Description |
|------|------|-------------|
| E7001 | stdlib-argument-mismatch | Wrong number of arguments |
| E7002 | requires-array | Argument must be an array |
| E7003 | requires-string | Argument must be a string |
| E7004 | requires-integer | Argument must be an integer |
| E7005 | requires-number | Argument must be a number |
| E7006 | requires-function | Argument must be a function |
| E7007 | requires-map | Argument must be a map |
| E7008 | requires-boolean | Argument must be a boolean |
| E7009 | requires-char | Argument must be a char |
| E7010 | invalid-argument-value | Argument value is invalid |
| E7011 | negative-not-allowed | Argument cannot be negative |
| E7012 | zero-not-allowed | Argument cannot be zero |
| E7013 | empty-not-allowed | Argument cannot be empty |
| E7014 | type-conversion-failed | Type conversion failed |
| E7015 | len-unsupported-type | `len()` not supported for type |
| E7016 | file-not-found | File or directory not found |
| E7017 | permission-denied | Permission denied |
| E7018 | cannot-remove-directory | `io.remove()` cannot remove directories |
| E7019 | cannot-remove-file | `io.remove_dir()` can only remove directories |
| E7020 | safety-check-failed | Cannot remove root or home directory |
| E7021 | cannot-copy-directory | `io.copy()` cannot copy directories |
| E7022 | file-already-exists | File or directory already exists |
| E7023 | directory-not-empty | Directory not empty |
| E7024 | env-var-operation-failed | Environment variable operation failed |
| E7025 | get-cwd-failed | Failed to get current directory |
| E7026 | chdir-failed | Failed to change directory |
| E7027 | get-hostname-failed | Failed to get hostname |
| E7028 | get-username-failed | Failed to get username |
| E7029 | get-homedir-failed | Failed to get home directory |
| E7030 | command-not-found | Command or executable not found |
| E7031 | command-failed | Command execution failed |
| E7032 | sleep-negative | Sleep duration cannot be negative |
| E7033 | conversion-overflow | Value exceeds target type range |
| E7035 | env-var-not-set | Environment variable is not set |
| E7040 | empty-path | Path cannot be empty |
| E7041 | path-null-byte | Path contains null byte |
| E7042 | read-directory-as-file | Cannot read directory as file |
| E7043 | invalid-glob-pattern | Invalid glob pattern syntax |
| E7050 | file-handle-closed | File handle is closed |
| E7099 | io-error | General I/O error |

### E8xxx — Math Errors

| Code | Name | Description |
|------|------|-------------|
| E8001 | sqrt-negative | Cannot take square root of negative number |
| E8002 | log-non-positive | Logarithm requires positive number |
| E8003 | trig-out-of-range | Trigonometric function input out of valid range |
| E8004 | factorial-negative | Factorial requires non-negative integer |
| E8005 | factorial-overflow | Factorial result exceeds maximum value |
| E8006 | random-invalid-range | Random range is invalid |
| E8007 | map-range-div-zero | `map_range()` requires `in_min != in_max` |

### E9xxx — Array Errors

| Code | Name | Description |
|------|------|-------------|
| E9001 | array-is-empty | Operation requires non-empty array |
| E9002 | array-non-numeric | Operation requires numeric array |
| E9003 | range-step-zero | Range step cannot be zero |
| E9004 | chunk-size-invalid | Chunk size must be greater than zero |
| E9005 | range-invalid-bounds | Range start must be less than or equal to end |
| E9006 | array-modified-during-iteration | Cannot modify array during `for_each` iteration |
| E9007 | empty-array-selection | Cannot select from empty array |
| E9008 | sample-count-exceeds-length | Sample count exceeds array length |

### E10xxx — String Errors

| Code | Name | Description |
|------|------|-------------|
| E10001 | repeat-count-negative | Repeat count cannot be negative |
| E10003 | string-index-out-of-bounds | String index out of bounds |
| E10004 | string-empty-index | Cannot index empty string |

### E11xxx — Time Errors

| Code | Name | Description |
|------|------|-------------|
| E11001 | time-parse-failed | Failed to parse time string |

### E12xxx — Map Errors

| Code | Name | Description |
|------|------|-------------|
| E12001 | map-key-not-hashable | Map key must be a hashable type |
| E12002 | map-immutable | Cannot modify immutable map |
| E12003 | map-key-not-found | Key not found in map |
| E12004 | map-invalid-pair | Map entry must be a `[key, value]` pair |
| E12005 | map-value-not-hashable | Map value is not hashable and cannot become a key |
| E12006 | map-duplicate-key | Map literal contains duplicate key |

### E13xxx — JSON Errors

| Code | Name | Description |
|------|------|-------------|
| E13001 | json-syntax-error | Invalid JSON syntax |
| E13002 | json-unsupported-type | Type cannot be converted to JSON |
| E13003 | json-invalid-map-key | JSON object keys must be strings |
| E13004 | json-decode-requires-type | `json.decode()` requires a type argument |

### E14xxx — HTTP Errors

| Code | Name | Description |
|------|------|-------------|
| E14001 | http-invalid-url | Invalid URL |
| E14002 | http-failed-request | Request failed (network error) |
| E14003 | http-timeout | Timeout exceeded |
| E14004 | http-invalid-method | Invalid HTTP method |
| E14005 | http-failed-url-decode | URL decode failed |
| E14006 | http-failed-json-encoding | JSON encoding failed |

### E15xxx — Crypto Errors

| Code | Name | Description |
|------|------|-------------|
| E15001 | crypto-random-failed | Cryptographic random generation failed |

### E16xxx — Encoding Errors

| Code | Name | Description |
|------|------|-------------|
| E16001 | invalid-base64 | Invalid base64 encoded input |
| E16002 | invalid-hex | Invalid hexadecimal encoded input |
| E16003 | invalid-url-encoding | Invalid URL encoded input |

### E17xxx — Database Errors

| Code | Name | Description |
|------|------|-------------|
| E17001 | db-open-failed | Failed to open database |
| E17002 | db-read-failed | Failed to read database file |
| E17003 | db-write-failed | Failed to write database file |
| E17004 | db-corrupted | Database file is corrupted |
| E17005 | db-closed | Operation on closed database |

### E18xxx — Server Errors

| Code | Name | Description |
|------|------|-------------|
| E18001 | server-listen-failed | Server failed to start |
| E18002 | server-invalid-port | Invalid port number |
| E18003 | server-internal-error | Internal server error |
| E18004 | server-handler-error | Handler returned an error |

### Warnings

#### W1xxx — Code Style Warnings

| Code | Name | Description |
|------|------|-------------|
| W1001 | unused-variable | Variable declared but not used |
| W1002 | unused-import | Module imported but not used |
| W1003 | unused-function | Function declared but not called |
| W1004 | unused-parameter | Parameter declared but not used |
| W1005 | typed-blank-identifier | Blank identifier does not require type annotation |

#### W2xxx — Potential Bug Warnings

| Code | Name | Description |
|------|------|-------------|
| W2001 | unreachable-code | Code will never execute |
| W2002 | shadowed-variable | Variable shadows outer scope |
| W2003 | missing-return | Function may not return value |
| W2004 | implicit-type-conversion | Implicit type conversion occurring |
| W2005 | deprecated-feature | Using deprecated feature |
| W2006 | byte-overflow-potential | Byte arithmetic may overflow |
| W2007 | shadows-global | Variable shadows global variable or constant |
| W2008 | integer-overflow-potential | Integer arithmetic may overflow |
| W2009 | nil-dereference-potential | Accessing member on potentially nil value |
| W2010 | chained-nil-access | Chained member access on nullable struct type |
| W2011 | named-return-unused | Named return variable declared but returns different value |

#### W3xxx — Code Quality Warnings

| Code | Name | Description |
|------|------|-------------|
| W3001 | empty-block | Block statement is empty |
| W3002 | redundant-condition | Condition is always true/false |
| W3003 | array-size-mismatch | Fixed-size array not fully initialized |

#### W4xxx — Module Warnings

| Code | Name | Description |
|------|------|-------------|
| W4001 | module-name-mismatch | Module name does not match directory name |

---

## Appendix C: Revision History

| Version | Date | Changes |
|---------|------|---------|
| 1.0-draft | January 2026 | Initial draft |
| 1.1-draft | January 31, 2026 | Added hex escapes, `!in` operator, blank identifier, `ref()` builtin, negative step `range()`, `temp` mutability; fixed terminology to use check-time instead of compile-time; added `uint` to primitive lists |
| 1.2-draft | February 12, 2026 | Added `for_each` index variable, named return variables, `cast` keyword, raw string literals, octal literals, `private` visibility, `#doc`/`#suppress` attributes; added `@server`, `@regex`, `@csv` modules; updated `@http`, `@db`, `@math`, `@strings`, `@time`, `@arrays` modules; fixed `remove` → `remove_at` in arrays; expanded Appendix B with comprehensive error code reference (181 errors, 14 warnings) |

---

*This document is the authoritative specification for the EZ programming language.*
