# The EZ Programming Language Standard

**Version:** 1.1-draft
**Date:** January 31, 2026
**Status:** Working Draft
**EZ Version:** 1.4.8

---

> **Notice**
>
> This specification was generated by Claude through systematic review of the EZ language source code and passing integration tests. It represents a best-effort documentation of the language's syntax, semantics, and standard library as implemented.
>
> **This document is subject to change** as the EZ language evolves. It is not guaranteed to be complete or fully accurate in all edge cases.
>
> **Primary Purpose:** This specification is intended primarily to provide context for AI agents and language models to learn and understand the EZ programming language. It serves as a reference for AI-assisted development, code generation, and tooling support. While human developers may find it useful, the official EZ documentation at [https://schoolyb.github.io/EZ-Language-Webapp/docs](https://schoolyb.github.io/EZ-Language-Webapp/docs) should be consulted for tutorials and usage guidance.

---

## Table of Contents

1. [Introduction](#1-introduction)
2. [Notation](#2-notation)
3. [Lexical Structure](#3-lexical-structure)
4. [Types](#4-types)
5. [Variables and Constants](#5-variables-and-constants)
6. [Expressions](#6-expressions)
7. [Statements](#7-statements)
8. [Functions](#8-functions)
9. [Modules](#9-modules)
10. [Standard Library](#10-standard-library)
11. [Error Handling](#11-error-handling)
12. [Memory Model](#12-memory-model)
13. [Program Execution](#13-program-execution)

---

## 1. Introduction

### 1.1 Purpose

This document defines the EZ programming language. It serves as the authoritative reference for the language's syntax, semantics, and behavior. Implementations of EZ must conform to this specification.

### 1.2 Overview

EZ is a statically-typed, interpreted programming language designed for clarity and ease of use. The language emphasizes:

- **Simplicity**: A minimal set of orthogonal features
- **Clarity**: Explicit syntax that reads naturally
- **Safety**: Static type checking and runtime bounds checking

### 1.3 Conformance

A conforming EZ implementation must:

1. Accept all programs that conform to this specification
2. Reject all programs that violate this specification with appropriate error messages
3. Execute conforming programs with the semantics defined herein

---

## 2. Notation

### 2.1 Grammar Notation

This specification uses Extended Backus-Naur Form (EBNF) to describe syntax:

```
production  = name "=" expression "." ;
expression  = term { "|" term } ;
term        = factor { factor } ;
factor      = name | literal | "[" expression "]" | "(" expression ")" | "{" expression "}" ;
```

Where:
- `[ x ]` denotes zero or one occurrence of x
- `{ x }` denotes zero or more occurrences of x
- `( x | y )` denotes grouping with alternation
- `"text"` denotes literal text

### 2.2 Terminology

- **Must**: Indicates an absolute requirement
- **Must not**: Indicates an absolute prohibition
- **Should**: Indicates a recommendation
- **May**: Indicates optional behavior

---

## 3. Lexical Structure

### 3.1 Source Encoding

EZ source files must be encoded in UTF-8. However, identifiers are restricted to ASCII characters.

### 3.2 Line Terminators

Line terminators are the ASCII line feed character (LF, U+000A) or the ASCII carriage return character (CR, U+000D) optionally followed by a line feed.

### 3.3 Comments

EZ supports two forms of comments:

**Single-line comments** begin with `//` and extend to the end of the line:

```ez
// This is a single-line comment
temp x int = 42  // inline comment
```

**Multi-line comments** begin with `/*` and end with `*/`:

```ez
/* This is a
   multi-line comment */
```

Multi-line comments do not nest. A `/*` inside a multi-line comment has no special meaning.

### 3.4 Identifiers

Identifiers name program entities such as variables, functions, types, and modules.

```
identifier = letter { letter | digit | "_" } .
letter     = "A" ... "Z" | "a" ... "z" .
digit      = "0" ... "9" .
```

Identifiers must:
- Begin with an ASCII letter
- Contain only ASCII letters, digits, and underscores
- Not be a reserved keyword

Valid identifiers: `x`, `count`, `myVariable`, `point_2d`, `MAX_SIZE`

Invalid identifiers: `2fast`, `my-var`, `café`, `_private`

### 3.5 Keywords

The following words are reserved and may not be used as identifiers:

```
as_long_as   bool        break       byte        char
const        continue    default     do          ensure
enum         error       false       float       for
for_each     if          import      in          int
is           map         module      new         nil
not_in       or          otherwise   range       return
string       struct      temp        true        uint
using        when        private
```

### 3.6 Operators and Punctuation

```
+    -    *    /    %
==   !=   <    >    <=   >=
&&   ||   !
=    +=   -=   *=   /=
++   --
(    )    {    }    [    ]
,    :    .    ->   &
```

### 3.7 Literals

#### 3.7.1 Integer Literals

Integer literals represent integer values.

```
int_literal    = decimal_lit | hex_lit .
decimal_lit    = digit { [ "_" ] digit } .
hex_lit        = "0" ( "x" | "X" ) hex_digit { [ "_" ] hex_digit } .
hex_digit      = digit | "A" ... "F" | "a" ... "f" .
```

Underscores may be used for readability but:
- Must not appear at the beginning or end
- Must not appear consecutively
- Must not appear adjacent to the decimal point

Examples: `42`, `1_000_000`, `0xFF`, `0xDEAD_BEEF`

#### 3.7.2 Floating-Point Literals

Floating-point literals represent floating-point values.

```
float_literal = digit { digit } "." digit { digit } .
```

Examples: `3.14159`, `0.5`, `100.0`

#### 3.7.3 String Literals

String literals represent string values.

```
string_literal = '"' { string_char | escape_seq | interpolation } '"' .
string_char    = /* any UTF-8 character except '"', '\', or newline */ .
escape_seq     = "\" ( "n" | "r" | "t" | "\" | '"' ) .
interpolation  = "${" expression "}" .
```

Escape sequences:
- `\n` - line feed (U+000A)
- `\r` - carriage return (U+000D)
- `\t` - horizontal tab (U+0009)
- `\\` - backslash
- `\"` - double quote
- `\xNN` - hex byte value (e.g., `\x48` = 'H', `\x0a` = newline)

String interpolation allows embedding expressions within strings:

```ez
temp name string = "World"
temp greeting string = "Hello, ${name}!"  // "Hello, World!"
```

#### 3.7.4 Character Literals

Character literals represent single character values.

```
char_literal = "'" ( char_char | escape_seq ) "'" .
char_char    = /* any UTF-8 character except "'", '\', or newline */ .
```

Examples: `'A'`, `'\n'`, `'\t'`

Character literals must contain exactly one character (or escape sequence).

#### 3.7.5 Boolean Literals

```
bool_literal = "true" | "false" .
```

#### 3.7.6 Nil Literal

```
nil_literal = "nil" .
```

The literal `nil` represents the absence of a value.

---

## 4. Types

EZ is statically typed. Every variable and expression has a type known at check time.

### 4.1 Primitive Types

#### 4.1.1 Integer Type (`int`)

The `int` type represents arbitrary-precision signed integers. There is no overflow or underflow; integers grow as needed to accommodate any value.

```ez
temp small int = 42
temp large int = 9223372036854775808  // Exceeds 64-bit, still valid
```

#### 4.1.2 Unsigned Integer Type (`uint`)

The `uint` type represents arbitrary-precision unsigned (non-negative) integers. Like `int`, there is no overflow; values grow as needed.

```ez
temp count uint = 100
temp big uint = 18446744073709551615  // Max 64-bit unsigned, still valid
```

Assigning a negative value to a `uint` produces a check-time error.

#### 4.1.3 Floating-Point Type (`float`)

The `float` type represents 64-bit IEEE 754 double-precision floating-point numbers.

Division by zero with floating-point operands produces a runtime error (not IEEE 754 infinity or NaN).

```ez
temp pi float = 3.14159
temp negative float = -2.5
```

#### 4.1.4 String Type (`string`)

The `string` type represents a sequence of characters. Strings are UTF-8 encoded and are treated as arrays of `char` values.

```ez
temp greeting string = "Hello, World!"
temp first_char char = greeting[0]  // 'H'
```

#### 4.1.5 Boolean Type (`bool`)

The `bool` type has exactly two values: `true` and `false`.

```ez
temp flag bool = true
temp result bool = 10 > 5  // true
```

#### 4.1.6 Character Type (`char`)

The `char` type represents a single character.

```ez
temp letter char = 'A'
temp newline char = '\n'
```

Characters can be converted to their integer code point using `int()`.

#### 4.1.7 Byte Type (`byte`)

The `byte` type represents an 8-bit unsigned integer with values from 0 to 255.

```ez
temp b byte = 0xFF  // 255
temp c byte = 128   // decimal also works
```

Assigning a value outside the range 0-255 to a `byte` is a check-time error.

#### 4.1.8 Nil Type (`nil`)

The `nil` type has a single value, also written `nil`. It represents the absence of a value and is used in error handling.

### 4.2 Composite Types

#### 4.2.1 Arrays

Arrays are ordered collections of elements of the same type.

**Dynamic arrays** have variable length:

```
array_type = "[" type "]" .
```

```ez
temp numbers [int] = {1, 2, 3, 4, 5}
temp empty [string] = {}
```

**Fixed-size arrays** have a length specified at declaration:

```
fixed_array_type = "[" type "," size "]" .
```

```ez
const fixed [int, 3] = {10, 20, 30}
```

**Multi-dimensional arrays**:

```ez
temp matrix [[int]] = {{1, 2}, {3, 4}}
temp cube [[[int]]] = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}
```

Array indexing is zero-based. Accessing an index outside the valid range produces a runtime error.

#### 4.2.2 Maps

Maps are unordered collections of key-value pairs.

```
map_type = "map" "[" key_type ":" value_type "]" .
```

```ez
temp ages map[string:int] = {
    "alice": 30,
    "bob": 25
}
```

Keys must be of a hashable type: `int`, `uint`, `float`, `string`, `bool`, `char`, or `byte`.

Accessing a key that does not exist produces a runtime error.

#### 4.2.3 Structs

Structs are user-defined composite types with named fields.

```
struct_decl = "const" identifier "struct" "{" { field_decl } "}" .
field_decl  = identifier type .
```

```ez
const Point struct {
    x int
    y int
}

const Person struct {
    name string
    age int
    active bool
}
```

Struct instantiation uses named field syntax:

```ez
temp origin Point = Point{x: 0, y: 0}
temp p Point = Point{}  // Zero-initialized: x=0, y=0
```

Fields are accessed using dot notation:

```ez
temp x_value int = origin.x
origin.x = 10  // Modification (if variable is temp)
```

#### 4.2.4 Enums

Enums define a type with a fixed set of named values.

**Integer enums** (default, auto-incrementing from 0):

```ez
const Direction enum {
    NORTH    // 0
    EAST     // 1
    SOUTH    // 2
    WEST     // 3
}
```

**Flags enums** (powers of 2, annotated with `#flags`):

```ez
#flags
const Permissions enum {
    READ      // 1
    WRITE     // 2
    EXECUTE   // 4
    DELETE    // 8
}
```

**String enums** (explicit string values):

```ez
const Status enum {
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    DONE = "done"
}
```

Enum values are accessed using dot notation:

```ez
temp dir int = Direction.NORTH
temp status string = Status.TODO
```

### 4.3 Type Inference

EZ is a statically-typed language that generally requires explicit type annotations. However, **partial type inference** is supported in specific contexts where the type can be unambiguously determined from the initializer.

Type inference is permitted when assigning from:

1. **Function return values** - The variable's type is inferred from the function's return type
2. **Struct literals** - The type is known from the struct name
3. **Built-in constructors** - `new(Type)` and `copy(value)`
4. **Array literals** - When element types are consistent

```ez
// Inferred from function return type
do sum(a int, b int) -> int {
    return a + b
}
temp result = sum(1, 2)        // Inferred: int
println(typeof(result))        // Output: int

// Inferred from struct literal
const p = Point{x: 1, y: 2}    // Inferred: Point

// Inferred from built-in constructors
temp val = new(Person)         // Inferred: Person
temp dup = copy(val)           // Inferred: Person

// Inferred from array literal
temp arr = {1, 2, 3}           // Inferred: [int]

// Multiple return values
do divide(a, b int) -> (int, int) {
    return a / b, a % b
}
temp quotient, remainder = divide(10, 3)  // Both inferred: int
```

**Note:** Type inference does not apply to standalone literals without context. Explicit types are required when the type cannot be determined:

```ez
temp x int = 42                // Explicit type required for standalone literal
temp name string = "Alice"     // Explicit type required
```

### 4.4 Type Conversions

Explicit type conversions are performed using type constructors:

```ez
temp i int = int('A')       // 65 - char to int (code point)
temp f float = float(42)    // 42.0 - int to float
temp s string = string(123) // "123" - int to string
temp c char = char(65)      // 'A' - int to char
```

Conversions that would lose information or are invalid produce check-time or runtime errors.

---

## 5. Variables and Constants

### 5.1 Variable Declarations

Variables are declared using the `temp` keyword:

```
var_decl = "temp" identifier type "=" expression .
```

```ez
temp count int = 0
temp name string = "Alice"
temp items [int] = {1, 2, 3}
```

Variables declared with `temp`:
- Must be initialized at declaration
- Can be reassigned after declaration
- Are scoped to their containing block

### 5.2 Constant Declarations

Constants are declared using the `const` keyword:

```
const_decl = "const" identifier [ type ] "=" expression .
```

```ez
const PI float = 3.14159
const MAX_SIZE int = 100
const origin = Point{x: 0, y: 0}
```

Constants declared with `const`:
- Must be initialized at declaration
- Cannot be reassigned
- Cannot have their contents modified (for composite types)
- Are scoped to their containing block (or module, if at top level)

### 5.3 Mutability

The `const` keyword indicates complete immutability:

```ez
const arr [int, 3] = {1, 2, 3}
arr[0] = 10  // ERROR: Cannot modify const
arr = {4, 5, 6}  // ERROR: Cannot reassign const
```

The `temp` keyword allows modification and **ensures the value itself is mutable**:

```ez
temp arr [int] = {1, 2, 3}
arr[0] = 10  // OK
arr = {4, 5, 6}  // OK
```

When assigning from a function return or other source, `temp` automatically makes the value mutable. There is no need to use `copy()` to obtain a mutable version:

```ez
do get_data() -> [int] {
    return {1, 2, 3}
}

temp arr = get_data()  // arr is mutable
arrays.append(arr, 4)  // OK - can modify directly

const fixed = get_data()  // fixed is immutable
arrays.append(fixed, 4)   // ERROR - cannot modify const
```

### 5.4 Scope

Variables and constants are block-scoped. A block is delimited by braces `{}`.

Inner scopes may declare variables that shadow outer scope variables:

```ez
temp x int = 10
if true {
    temp x int = 20  // Shadows outer x
    // x is 20 here
}
// x is 10 here
```

### 5.5 Blank Identifier

The blank identifier `_` can be used to discard values that are not needed. This is particularly useful with multiple return values:

```ez
// Discard the second return value
temp value, _ = get_pair()

// Discard multiple values
const _, middle, _ = get_triple()

// Common pattern: ignore error when you know it won't fail
temp data, _ = json.encode(simple_value)
```

The blank identifier:
- Cannot be read from (it discards the value)
- Can be used multiple times in the same assignment
- Works with both `temp` and `const` declarations

---

## 6. Expressions

### 6.1 Primary Expressions

```
primary_expr = identifier
             | literal
             | "(" expression ")"
             | array_literal
             | map_literal
             | struct_literal .
```

#### 6.1.1 Array Literals

```ez
{1, 2, 3}
{"a", "b", "c"}
{}  // Empty array
```

#### 6.1.2 Map Literals

```ez
{"key": "value", "another": "pair"}
{1: "one", 2: "two"}
```

#### 6.1.3 Struct Literals

```ez
Point{x: 10, y: 20}
Person{name: "Alice", age: 30, active: true}
Point{}  // Zero-initialized
```

### 6.2 Operators

#### 6.2.1 Arithmetic Operators

| Operator | Description | Operand Types | Result Type |
|----------|-------------|---------------|-------------|
| `+` | Addition | `int`, `int` | `int` |
| `+` | Addition | `float`, `float` | `float` |
| `+` | Concatenation | `string`, `string` | `string` |
| `-` | Subtraction | `int`, `int` | `int` |
| `-` | Subtraction | `float`, `float` | `float` |
| `*` | Multiplication | `int`, `int` | `int` |
| `*` | Multiplication | `float`, `float` | `float` |
| `/` | Division | `int`, `int` | `int` (truncated) |
| `/` | Division | `float`, `float` | `float` |
| `%` | Modulo | `int`, `int` | `int` |

Division by zero produces a runtime error.

#### 6.2.2 Comparison Operators

| Operator | Description |
|----------|-------------|
| `==` | Equal |
| `!=` | Not equal |
| `<` | Less than |
| `>` | Greater than |
| `<=` | Less than or equal |
| `>=` | Greater than or equal |

Comparison operators return `bool`.

#### 6.2.3 Logical Operators

| Operator | Description |
|----------|-------------|
| `&&` | Logical AND (short-circuit) |
| `\|\|` | Logical OR (short-circuit) |
| `!` | Logical NOT |

Logical AND and OR use short-circuit evaluation: the right operand is not evaluated if the result can be determined from the left operand alone.

#### 6.2.4 Membership Operators

| Operator | Description |
|----------|-------------|
| `in` | Membership test |
| `not_in` | Non-membership test |
| `!in` | Non-membership test (shorthand for `not_in`) |

```ez
if 3 in numbers { ... }
if "key" not_in map { ... }
if x in range(0, 10) { ... }
if 10 !in range(0, 10) { ... }  // Shorthand for not_in
```

#### 6.2.5 Assignment Operators

| Operator | Description |
|----------|-------------|
| `=` | Assignment |
| `+=` | Addition assignment |
| `-=` | Subtraction assignment |
| `*=` | Multiplication assignment |
| `/=` | Division assignment |

#### 6.2.6 Increment and Decrement

| Operator | Description |
|----------|-------------|
| `++` | Post-increment |
| `--` | Post-decrement |

```ez
temp x int = 5
x++  // x is now 6
x--  // x is now 5
```

### 6.3 Operator Precedence

From highest to lowest precedence:

1. Parentheses: `()`
2. Unary: `!`, `-` (negation)
3. Multiplicative: `*`, `/`, `%`
4. Additive: `+`, `-`
5. Comparison: `<`, `>`, `<=`, `>=`
6. Equality: `==`, `!=`
7. Logical AND: `&&`
8. Logical OR: `||`
9. Membership: `in`, `not_in`

### 6.4 Index Expressions

```ez
temp arr [int] = {10, 20, 30}
temp val int = arr[1]  // 20
arr[0] = 100  // Modification

temp str string = "hello"
temp c char = str[0]  // 'h'

temp m map[string:int] = {"a": 1}
temp v int = m["a"]  // 1
```

### 6.5 Member Expressions

```ez
temp p Point = Point{x: 10, y: 20}
temp x int = p.x  // 10
p.y = 30  // Modification

temp status int = Direction.NORTH  // Enum access
```

### 6.6 Call Expressions

```ez
temp sum int = add(1, 2)
temp greeting string = greet("World")
println("Hello!")
```

### 6.7 Range Expressions

```
range_expr = "range" "(" start "," end [ "," step ] ")" .
```

```ez
range(0, 10)       // 0, 1, 2, ..., 9  (increment)
range(0, 10, 2)    // 0, 2, 4, 6, 8    (increment)
range(10, 0, -1)   // 10, 9, 8, ..., 1 (decrement)
range(10, 0, -2)   // 10, 8, 6, 4, 2   (decrement)
```

Ranges are inclusive of the start value and exclusive of the end value.

**Step validation rules:**
- Positive step (or omitted): start must be ≤ end
- Negative step: start must be ≥ end (for backwards iteration)
- Zero step: always produces an error (E9003)
- Mismatched direction (e.g., `range(0, 10, -1)`) produces an error (E9005)

---

## 7. Statements

### 7.1 Expression Statements

Any expression can be used as a statement:

```ez
println("Hello")
counter++
do_something()
```

### 7.2 Conditional Statements

#### 7.2.1 If Statements

```
if_stmt = "if" expression block { "or" expression block } [ "otherwise" block ] .
```

```ez
if x < 0 {
    println("negative")
} or x == 0 {
    println("zero")
} otherwise {
    println("positive")
}
```

The `or` keyword introduces additional conditions (similar to `else if` in other languages).

The `otherwise` keyword introduces the default case (similar to `else`).

### 7.3 Loop Statements

#### 7.3.1 For Loops

```
for_stmt = "for" [ "(" ] identifier [ type ] "in" range_expr [ ")" ] block .
```

```ez
for i in range(0, 10) {
    println("${i}")
}

for i int in range(0, 5) {
    // With explicit type
}

for (i in range(0, 10)) {
    // Parentheses optional
}
```

#### 7.3.2 For-Each Loops

```
for_each_stmt = "for_each" [ "(" ] identifier "in" expression [ ")" ] block .
```

```ez
temp items [string] = {"a", "b", "c"}
for_each item in items {
    println(item)
}
```

#### 7.3.3 While Loops

```
while_stmt = "as_long_as" expression block .
```

```ez
temp count int = 0
as_long_as count < 10 {
    count++
}
```

### 7.4 Control Flow Statements

#### 7.4.1 Break

The `break` statement terminates the innermost enclosing loop:

```ez
for i in range(0, 100) {
    if i == 5 {
        break
    }
}
```

#### 7.4.2 Continue

The `continue` statement skips to the next iteration of the innermost enclosing loop:

```ez
for i in range(0, 10) {
    if i % 2 == 0 {
        continue
    }
    println("${i}")  // Prints odd numbers only
}
```

#### 7.4.3 Return

The `return` statement exits the current function, optionally returning a value:

```ez
do add(a int, b int) -> int {
    return a + b
}

do greet() {
    println("Hello")
    return  // Void return
}
```

### 7.5 When Statements (Pattern Matching)

```
when_stmt = [ "#strict" ] "when" expression "{" { when_case } [ default_case ] "}" .
when_case = "is" pattern { "," pattern } block .
default_case = "default" block .
pattern = expression | range_expr .
```

```ez
when x {
    is 1 { println("one") }
    is 2, 3 { println("two or three") }
    is range(4, 10) { println("four to nine") }
    default { println("other") }
}
```

**Strict mode** requires all possible values to be handled:

```ez
#strict
when direction {
    is Direction.NORTH { ... }
    is Direction.EAST { ... }
    is Direction.SOUTH { ... }
    is Direction.WEST { ... }
}
```

### 7.6 Ensure Statement

The `ensure` statement specifies a function to call when the enclosing function exits (whether normally or via early return):

```ez
do process_file() {
    ensure cleanup()
    // ... do work ...
    if error_condition {
        return  // cleanup() will be called
    }
    // cleanup() will be called when function ends
}
```

---

## 8. Functions

### 8.1 Function Declarations

```
func_decl = "do" identifier "(" [ param_list ] ")" [ "->" return_type ] block .
param_list = param { "," param } .
param = [ "&" ] identifier [ "," identifier ]... type [ "=" default_value ] .
return_type = type | "(" type { "," type } ")" | "nil" | "(" type "," "nil" ")" .
```

```ez
do add(a int, b int) -> int {
    return a + b
}

do greet(name string = "World") -> string {
    return "Hello, ${name}!"
}

do process() {
    // Void function (no return type)
}
```

### 8.2 Parameters

#### 8.2.1 Immutable Parameters

By default, parameters are passed by value and cannot modify the caller's variables:

```ez
do double(x int) -> int {
    return x * 2
}
```

#### 8.2.2 Mutable Parameters

Parameters prefixed with `&` can modify the caller's variables:

```ez
do increment(&n int) {
    n = n + 1
}

temp count int = 0
increment(count)  // count is now 1
```

Mutable parameters work with:
- Primitive types
- Struct fields: `increment(point.x)`
- Array elements: `increment(arr[0])`
- Map values: `increment(map["key"])`

#### 8.2.3 Grouped Parameters

Multiple parameters of the same type can be grouped:

```ez
do add(a, b int) -> int {
    return a + b
}

do swap(&a, &b int) {
    temp t int = a
    a = b
    b = t
}
```

#### 8.2.4 Default Parameters

Parameters can have default values:

```ez
do greet(name string = "World") -> string {
    return "Hello, ${name}!"
}

greet()         // "Hello, World!"
greet("Alice")  // "Hello, Alice!"
```

Default parameters must appear after non-default parameters.

### 8.3 Return Types

#### 8.3.1 Single Return Value

```ez
do square(x int) -> int {
    return x * x
}
```

#### 8.3.2 Multiple Return Values

```ez
do divide(a, b int) -> (int, int) {
    return a / b, a % b
}

temp quotient, remainder = divide(17, 5)
```

#### 8.3.3 Error Returns

```ez
do parse(s string) -> (int, error) {
    if s == "" {
        return 0, error("empty string")
    }
    return 42, nil
}

temp value, err = parse("test")
if err != nil {
    // Handle error
}
```

#### 8.3.4 Void Functions

Functions without a return type return no value:

```ez
do print_greeting() {
    println("Hello!")
}
```

### 8.4 Function Scope

All functions in EZ are declared at the top level. Nested function declarations are not permitted. Anonymous functions (lambdas/closures) are not supported.

---

## 9. Modules

### 9.1 Module Declaration

```
module_decl = "module" identifier .
```

A source file may declare its module at the top of the file:

```ez
module utils
```

### 9.2 Imports

```
import_decl = "import" [ "&" "use" ] import_path { "," import_path } .
import_path = "@" identifier | string_literal .
```

Standard library modules are prefixed with `@`:

```ez
import @std
import @arrays, @maps, @strings
```

Local modules use relative paths:

```ez
import "./models"
import "./utils/helpers"
```

### 9.3 Combined Import and Use

The `import & use` syntax combines importing and using in a single statement:

```ez
import & use @std
```

This is equivalent to:

```ez
import @std
using std
```

Multiple modules can be combined:

```ez
import & use @std, @arrays, @strings
```

### 9.5 Using Declaration

The `using` declaration brings module members into scope for unqualified access:

```ez
import @std
using std

println("Hello")  // Instead of std.println
```

Multiple modules can be listed:

```ez
using std, arrays, strings
```

### 9.6 Module Member Access

Without `using`, module members are accessed with dot notation:

```ez
import @std
std.println("Hello")
```

With `using`:

```ez
import @std
using std
println("Hello")
```

---

## 10. Standard Library

The EZ standard library consists of 17 modules providing core functionality.

### 10.1 Core Module (`@std`)

The core module provides fundamental I/O, type conversion, and utility functions.

#### Output Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `println` | `(...values) -> nil` | Print values with newline |
| `print` | `(...values) -> nil` | Print values without newline |
| `eprintln` | `(...values) -> nil` | Print to stderr with newline |
| `eprint` | `(...values) -> nil` | Print to stderr without newline |

#### Input Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `input` | `() -> string` | Read line from stdin |
| `read_int` | `() -> (int, error)` | Read integer from stdin |

#### Type Conversion Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `int` | `(value) -> int` | Convert to int |
| `uint` | `(value) -> uint` | Convert to uint |
| `float` | `(value) -> float` | Convert to float |
| `string` | `(value) -> string` | Convert to string |
| `char` | `(value) -> char` | Convert to char |
| `byte` | `(value) -> byte` | Convert to byte |

#### Sized Integer Conversions

| Function | Description |
|----------|-------------|
| `i8`, `i16`, `i32`, `i64`, `i128`, `i256` | Convert to signed integers |
| `u8`, `u16`, `u32`, `u64`, `u128`, `u256` | Convert to unsigned integers |
| `f32`, `f64` | Convert to sized floats |

#### Utility Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `len` | `(collection) -> int` | Length of array, string, or map |
| `typeof` | `(value) -> string` | Type name as string |
| `copy` | `(value) -> T` | Create deep copy |
| `new` | `(Type) -> Type` | Create zero-initialized instance |
| `ref` | `(value) -> T` | Create reference to value |
| `error` | `(message string) -> error` | Create error value |
| `assert` | `(condition bool, message string)` | Assert condition is true |
| `panic` | `(message string) -> nil` | Terminate with error message |
| `exit` | `(code int) -> nil` | Exit program with code |

**Reference behavior with `ref()`:**

The `ref()` function creates a reference to an existing value. The mutability of the reference depends on the variable declaration:

```ez
temp arr [int] = {1, 2, 3}

// temp ref is mutable - can modify through the reference
temp r1 = ref(arr)
arrays.append(r1, 4)  // OK - modifies arr

// const ref is read-only - can read but not modify
const r2 = ref(arr)
temp val = r2[0]      // OK - can read
arrays.append(r2, 5)  // ERROR - cannot modify through const ref

// const ref sees changes made to the original
arrays.append(arr, 6)
println(r2[4])        // Prints 6 - r2 sees the change
```

#### Sleep Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `sleep_seconds` | `(seconds int) -> nil` | Sleep for seconds |
| `sleep_milliseconds` | `(ms int) -> nil` | Sleep for milliseconds |
| `sleep_nanoseconds` | `(ns int) -> nil` | Sleep for nanoseconds |

#### Constants

- `EXIT_SUCCESS` = 0
- `EXIT_FAILURE` = 1

### 10.2 Arrays Module (`@arrays`)

#### Query Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_empty` | `(arr [T]) -> bool` | Check if array is empty |
| `get` | `(arr [T], index int) -> T` | Get element at index |
| `first` | `(arr [T]) -> T` | Get first element |
| `last` | `(arr [T]) -> T` | Get last element |
| `contains` | `(arr [T], value T) -> bool` | Check if value exists |
| `index` | `(arr [T], value T) -> int` | First index of value (-1 if not found) |
| `last_index` | `(arr [T], value T) -> int` | Last index of value |
| `count` | `(arr [T], value T) -> int` | Count occurrences |

#### Modification Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `append` | `(&arr [T], ...values T)` | Append elements |
| `unshift` | `(&arr [T], ...values T) -> [T]` | Prepend elements |
| `insert` | `(&arr [T], index int, value T)` | Insert at index |
| `set` | `(&arr [T], index int, value T)` | Set element at index |
| `pop` | `(&arr [T]) -> T` | Remove and return last element |
| `shift` | `(&arr [T]) -> T` | Remove and return first element |
| `remove` | `(&arr [T], index int)` | Remove element at index |
| `remove_value` | `(&arr [T], value T)` | Remove first occurrence |
| `remove_all` | `(&arr [T], value T)` | Remove all occurrences |
| `clear` | `(&arr [T])` | Remove all elements |
| `sort` | `(&arr [T])` | Sort ascending in-place |
| `sort_desc` | `(&arr [T])` | Sort descending in-place |
| `shuffle` | `(&arr [T])` | Shuffle in-place |
| `fill` | `(&arr [T], value T)` | Fill all elements with value |

#### Transformation Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `reverse` | `(arr [T]) -> [T]` | Return reversed copy |
| `slice` | `(arr [T], start int, end int) -> [T]` | Return slice |
| `take` | `(arr [T], n int) -> [T]` | Return first n elements |
| `drop` | `(arr [T], n int) -> [T]` | Drop first n elements |
| `concat` | `(...arrs [T]) -> [T]` | Concatenate arrays |
| `zip` | `(arr1 [T], arr2 [U]) -> [[T,U]]` | Zip two arrays |
| `flatten` | `(arr [[T]]) -> [T]` | Flatten nested arrays |
| `unique` | `(arr [T]) -> [T]` | Return unique elements |
| `duplicates` | `(arr [T]) -> [T]` | Return duplicate elements |
| `repeat` | `(value T, count int) -> [T]` | Create array with repeated value |
| `join` | `(arr [T], sep string) -> string` | Join with separator |
| `chunk` | `(arr [T], size int) -> [[T]]` | Split into chunks |

#### Computation Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `sum` | `(arr [number]) -> number` | Sum all elements |
| `product` | `(arr [number]) -> number` | Multiply all elements |
| `min` | `(arr [T]) -> T` | Minimum element |
| `max` | `(arr [T]) -> T` | Maximum element |
| `avg` | `(arr [number]) -> float` | Average |
| `all_equal` | `(arr [T]) -> bool` | Check if all elements equal |
| `equals` | `(arr1 [T], arr2 [T]) -> bool` | Compare two arrays |

### 10.3 Strings Module (`@strings`)

#### Case Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `upper` | `(s string) -> string` | Convert to uppercase |
| `lower` | `(s string) -> string` | Convert to lowercase |
| `capitalize` | `(s string) -> string` | Capitalize first letter |
| `title` | `(s string) -> string` | Convert to title case |

#### Query Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_empty` | `(s string) -> bool` | Check if empty (after trim) |
| `is_numeric` | `(s string) -> bool` | Check if all digits |
| `is_alpha` | `(s string) -> bool` | Check if all letters |
| `contains` | `(s string, sub string) -> bool` | Check if contains substring |
| `starts_with` | `(s string, prefix string) -> bool` | Check prefix |
| `ends_with` | `(s string, suffix string) -> bool` | Check suffix |
| `index` | `(s string, sub string) -> int` | First index of substring |
| `last_index` | `(s string, sub string) -> int` | Last index of substring |
| `count` | `(s string, sub string) -> int` | Count occurrences |
| `compare` | `(s1 string, s2 string) -> int` | Compare strings (-1, 0, 1) |

#### Transformation Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `trim` | `(s string) -> string` | Trim whitespace |
| `trim_left` | `(s string) -> string` | Trim left whitespace |
| `trim_right` | `(s string) -> string` | Trim right whitespace |
| `replace` | `(s string, old string, new string) -> string` | Replace all occurrences |
| `replace_n` | `(s string, old string, new string, n int) -> string` | Replace first n |
| `repeat` | `(s string, count int) -> string` | Repeat string |
| `reverse` | `(s string) -> string` | Reverse string |
| `truncate` | `(s string, length int, suffix string) -> string` | Truncate with suffix |
| `pad_left` | `(s string, width int, pad string) -> string` | Left pad |
| `pad_right` | `(s string, width int, pad string) -> string` | Right pad |

#### Conversion Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `split` | `(s string, sep string) -> [string]` | Split into array |
| `join` | `(arr [string], sep string) -> string` | Join array |
| `chars` | `(s string) -> [char]` | Convert to char array |
| `from_chars` | `(chars [char]) -> string` | Create from char array |
| `slice` | `(s string, start int, end int) -> string` | Extract substring |
| `to_int` | `(s string) -> int` | Parse integer |
| `to_float` | `(s string) -> float` | Parse float |
| `to_bool` | `(s string) -> bool` | Parse boolean |

### 10.4 Maps Module (`@maps`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_empty` | `(m map[K:V]) -> bool` | Check if empty |
| `contains` | `(m map[K:V], key K) -> bool` | Check if key exists |
| `contains_value` | `(m map[K:V], value V) -> bool` | Check if value exists |
| `get` | `(m map[K:V], key K, default V) -> V` | Get value or default |
| `set` | `(&m map[K:V], key K, value V)` | Set key-value pair |
| `remove` | `(&m map[K:V], key K) -> bool` | Remove key |
| `clear` | `(&m map[K:V])` | Remove all entries |
| `get_or_set` | `(&m map[K:V], key K, default V) -> V` | Get or set default |
| `update` | `(&m map[K:V], ...maps map[K:V])` | Update with other maps |
| `merge` | `(...maps map[K:V]) -> map[K:V]` | Merge maps (non-destructive) |
| `keys` | `(m map[K:V]) -> [K]` | Get all keys |
| `values` | `(m map[K:V]) -> [V]` | Get all values |
| `invert` | `(m map[K:V]) -> map[V:K]` | Swap keys and values |
| `equals` | `(m1 map[K:V], m2 map[K:V]) -> bool` | Compare maps |
| `to_array` | `(m map[K:V]) -> [[K,V]]` | Convert to array of pairs |
| `from_array` | `(pairs [[K,V]]) -> map[K:V]` | Create from pairs |

### 10.5 Math Module (`@math`)

#### Basic Arithmetic

| Function | Signature | Description |
|----------|-----------|-------------|
| `add` | `(a number, b number) -> number` | Addition |
| `sub` | `(a number, b number) -> number` | Subtraction |
| `mul` | `(a number, b number) -> number` | Multiplication |
| `div` | `(a number, b number) -> float` | Division |
| `mod` | `(a number, b number) -> number` | Modulo |
| `abs` | `(n number) -> number` | Absolute value |
| `neg` | `(n number) -> number` | Negation |
| `sign` | `(n number) -> int` | Sign (-1, 0, 1) |

#### Min/Max/Clamp

| Function | Signature | Description |
|----------|-----------|-------------|
| `min` | `(...numbers) -> number` | Minimum value |
| `max` | `(...numbers) -> number` | Maximum value |
| `clamp` | `(value number, min number, max number) -> number` | Clamp to range |

#### Rounding

| Function | Signature | Description |
|----------|-----------|-------------|
| `floor` | `(n number) -> int` | Floor |
| `ceil` | `(n number) -> int` | Ceiling |
| `round` | `(n number) -> int` | Round |
| `trunc` | `(n number) -> int` | Truncate |

#### Powers and Roots

| Function | Signature | Description |
|----------|-----------|-------------|
| `pow` | `(base number, exp number) -> number` | Power |
| `sqrt` | `(n number) -> float` | Square root |
| `cbrt` | `(n number) -> float` | Cube root |
| `hypot` | `(x number, y number) -> float` | Hypotenuse |
| `exp` | `(n number) -> float` | e^n |
| `exp2` | `(n number) -> float` | 2^n |

#### Logarithms

| Function | Signature | Description |
|----------|-----------|-------------|
| `log` | `(n number) -> float` | Natural logarithm |
| `log2` | `(n number) -> float` | Base 2 logarithm |
| `log10` | `(n number) -> float` | Base 10 logarithm |
| `log_base` | `(value number, base number) -> float` | Custom base |

#### Trigonometry

| Function | Signature | Description |
|----------|-----------|-------------|
| `sin` | `(rad number) -> float` | Sine |
| `cos` | `(rad number) -> float` | Cosine |
| `tan` | `(rad number) -> float` | Tangent |
| `asin` | `(n number) -> float` | Arc sine |
| `acos` | `(n number) -> float` | Arc cosine |
| `atan` | `(n number) -> float` | Arc tangent |
| `atan2` | `(y number, x number) -> float` | Arc tangent of y/x |
| `sinh` | `(n number) -> float` | Hyperbolic sine |
| `cosh` | `(n number) -> float` | Hyperbolic cosine |
| `tanh` | `(n number) -> float` | Hyperbolic tangent |
| `deg_to_rad` | `(deg number) -> float` | Degrees to radians |
| `rad_to_deg` | `(rad number) -> float` | Radians to degrees |

#### Random

| Function | Signature | Description |
|----------|-----------|-------------|
| `random` | `() -> float` | Random float [0, 1) |
| `random` | `(max int) -> int` | Random int [0, max) |
| `random` | `(min int, max int) -> int` | Random int [min, max) |
| `random_float` | `(min number, max number) -> float` | Random float [min, max) |

#### Statistical

| Function | Signature | Description |
|----------|-----------|-------------|
| `sum` | `(...numbers) -> number` | Sum |
| `avg` | `(...numbers) -> float` | Average |
| `factorial` | `(n int) -> int` | Factorial |
| `gcd` | `(a int, b int) -> int` | Greatest common divisor |
| `lcm` | `(a int, b int) -> int` | Least common multiple |

#### Number Properties

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_prime` | `(n int) -> bool` | Check if prime |
| `is_even` | `(n int) -> bool` | Check if even |
| `is_odd` | `(n int) -> bool` | Check if odd |
| `is_inf` | `(n number) -> bool` | Check if infinite |

#### Utility

| Function | Signature | Description |
|----------|-----------|-------------|
| `lerp` | `(a number, b number, t number) -> float` | Linear interpolation |
| `map_range` | `(value, in_min, in_max, out_min, out_max) -> float` | Map to new range |
| `distance` | `(x1, y1, x2, y2 number) -> float` | Euclidean distance |

#### Constants

- `PI` - Pi (3.14159...)
- `E` - Euler's number (2.71828...)
- `PHI` - Golden ratio (1.61803...)
- `SQRT2` - Square root of 2
- `LN2` - Natural log of 2
- `LN10` - Natural log of 10
- `TAU` - Tau (2*Pi)
- `INF` - Positive infinity
- `NEG_INF` - Negative infinity

### 10.6 Time Module (`@time`)

#### Current Time

| Function | Signature | Description |
|----------|-----------|-------------|
| `now` | `() -> int` | Current Unix timestamp (seconds) |
| `now_ms` | `() -> int` | Current Unix timestamp (milliseconds) |
| `now_ns` | `() -> int` | Current Unix timestamp (nanoseconds) |

#### Sleep

| Function | Signature | Description |
|----------|-----------|-------------|
| `sleep` | `(seconds number)` | Sleep for seconds |
| `sleep_ms` | `(ms int)` | Sleep for milliseconds |

#### Time Components

| Function | Signature | Description |
|----------|-----------|-------------|
| `year` | `(timestamp int) -> int` | Get year |
| `month` | `(timestamp int) -> int` | Get month (1-12) |
| `day` | `(timestamp int) -> int` | Get day of month |
| `hour` | `(timestamp int) -> int` | Get hour |
| `minute` | `(timestamp int) -> int` | Get minute |
| `second` | `(timestamp int) -> int` | Get second |
| `weekday` | `(timestamp int) -> int` | Get day of week (0=Sunday) |
| `weekday_name` | `(timestamp int) -> string` | Get day name |
| `month_name` | `(timestamp int) -> string` | Get month name |
| `day_of_year` | `(timestamp int) -> int` | Get day of year |

#### Formatting

| Function | Signature | Description |
|----------|-----------|-------------|
| `format` | `(format string, timestamp int) -> string` | Format time |
| `iso` | `(timestamp int) -> string` | ISO 8601 string |
| `date` | `(timestamp int) -> string` | Date (YYYY-MM-DD) |
| `clock` | `(timestamp int) -> string` | Time (HH:MM:SS) |

#### Parsing and Creation

| Function | Signature | Description |
|----------|-----------|-------------|
| `parse` | `(s string, format string) -> int` | Parse string to timestamp |
| `make` | `(year, month, day, hour, minute, second int) -> int` | Create timestamp |

#### Arithmetic

| Function | Signature | Description |
|----------|-----------|-------------|
| `add_seconds` | `(timestamp int, seconds int) -> int` | Add seconds |
| `add_minutes` | `(timestamp int, minutes int) -> int` | Add minutes |
| `add_hours` | `(timestamp int, hours int) -> int` | Add hours |
| `add_days` | `(timestamp int, days int) -> int` | Add days |
| `add_weeks` | `(timestamp int, weeks int) -> int` | Add weeks |
| `add_months` | `(timestamp int, months int) -> int` | Add months |
| `add_years` | `(timestamp int, years int) -> int` | Add years |

#### Differences

| Function | Signature | Description |
|----------|-----------|-------------|
| `diff` | `(ts1 int, ts2 int) -> int` | Difference in seconds |
| `diff_days` | `(ts1 int, ts2 int) -> int` | Difference in days |
| `diff_hours` | `(ts1 int, ts2 int) -> int` | Difference in hours |
| `diff_minutes` | `(ts1 int, ts2 int) -> int` | Difference in minutes |

#### Comparisons

| Function | Signature | Description |
|----------|-----------|-------------|
| `is_before` | `(ts1 int, ts2 int) -> bool` | Check if ts1 < ts2 |
| `is_after` | `(ts1 int, ts2 int) -> bool` | Check if ts1 > ts2 |
| `is_leap_year` | `(year int) -> bool` | Check if leap year |
| `days_in_month` | `(year int, month int) -> int` | Days in month |
| `is_weekend` | `(timestamp int) -> bool` | Check if weekend |
| `is_weekday` | `(timestamp int) -> bool` | Check if weekday |
| `is_today` | `(timestamp int) -> bool` | Check if today |
| `is_same_day` | `(ts1 int, ts2 int) -> bool` | Check if same day |

#### Period Boundaries

| Function | Signature | Description |
|----------|-----------|-------------|
| `start_of_day` | `(timestamp int) -> int` | Start of day |
| `end_of_day` | `(timestamp int) -> int` | End of day |
| `start_of_month` | `(timestamp int) -> int` | Start of month |
| `end_of_month` | `(timestamp int) -> int` | End of month |
| `start_of_year` | `(timestamp int) -> int` | Start of year |
| `end_of_year` | `(timestamp int) -> int` | End of year |

#### Constants

Weekdays: `SUNDAY` (0) through `SATURDAY` (6)

Months: `JANUARY` (1) through `DECEMBER` (12)

Durations: `SECOND` (1), `MINUTE` (60), `HOUR` (3600), `DAY` (86400), `WEEK` (604800)

### 10.7 Random Module (`@random`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `float` | `() -> float` | Random float [0.0, 1.0) |
| `float` | `(min number, max number) -> float` | Random float [min, max) |
| `int` | `(max int) -> int` | Random int [0, max) |
| `int` | `(min int, max int) -> int` | Random int [min, max) |
| `bool` | `() -> bool` | Random boolean |
| `byte` | `() -> byte` | Random byte [0, 255] |
| `char` | `() -> char` | Random printable char |
| `char` | `(min, max) -> char` | Random char in range |
| `choice` | `(arr [T]) -> T` | Random element from array |
| `shuffle` | `(arr [T]) -> [T]` | Return shuffled copy |
| `sample` | `(arr [T], n int) -> [T]` | Return n unique random elements |

### 10.8 JSON Module (`@json`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `encode` | `(value) -> (string, error)` | Encode to JSON string |
| `decode` | `(text string) -> (any, error)` | Decode to dynamic type |
| `decode` | `(text string, Type) -> (Type, error)` | Decode to typed struct |
| `pretty` | `(value, indent string) -> (string, error)` | Pretty print JSON |
| `is_valid` | `(text string) -> bool` | Check if valid JSON |

### 10.9 IO Module (`@io`)

#### File Reading

| Function | Signature | Description |
|----------|-----------|-------------|
| `read_file` | `(path string) -> (string, error)` | Read file as string |
| `read_bytes` | `(path string) -> ([byte], error)` | Read file as bytes |

#### File Writing

| Function | Signature | Description |
|----------|-----------|-------------|
| `write_file` | `(path string, content string) -> (bool, error)` | Write file |
| `write_bytes` | `(path string, data [byte]) -> (bool, error)` | Write bytes |
| `append_file` | `(path string, content string) -> (bool, error)` | Append to file |

#### File Operations

| Function | Signature | Description |
|----------|-----------|-------------|
| `file_exists` | `(path string) -> bool` | Check if file exists |
| `is_file` | `(path string) -> bool` | Check if path is file |
| `is_directory` | `(path string) -> bool` | Check if path is directory |
| `is_readable` | `(path string) -> bool` | Check if readable |
| `is_writable` | `(path string) -> bool` | Check if writable |
| `file_size` | `(path string) -> (int, error)` | Get file size |
| `file_extension` | `(path string) -> string` | Get file extension |
| `file_name` | `(path string) -> string` | Get file name |
| `directory_name` | `(path string) -> string` | Get directory path |
| `absolute_path` | `(path string) -> (string, error)` | Get absolute path |
| `delete_file` | `(path string) -> (bool, error)` | Delete file |

#### Directory Operations

| Function | Signature | Description |
|----------|-----------|-------------|
| `list_directory` | `(path string) -> ([string], error)` | List directory contents |
| `create_directory` | `(path string) -> (bool, error)` | Create directory |
| `create_directories` | `(path string) -> (bool, error)` | Create recursively |
| `delete_directory` | `(path string) -> (bool, error)` | Delete empty directory |
| `delete_directory_recursive` | `(path string) -> (bool, error)` | Delete recursively |

#### Path Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `join_path` | `(...parts string) -> string` | Join path components |
| `normalize_path` | `(path string) -> string` | Normalize path |

### 10.10 OS Module (`@os`)

#### Environment Variables

| Function | Signature | Description |
|----------|-----------|-------------|
| `get_env` | `(name string) -> (string, error)` | Get environment variable |
| `set_env` | `(name string, value string) -> (bool, error)` | Set environment variable |
| `unset_env` | `(name string) -> (bool, error)` | Unset environment variable |
| `env` | `() -> map[string:string]` | Get all environment variables |

#### System Information

| Function | Signature | Description |
|----------|-----------|-------------|
| `args` | `() -> [string]` | Get command-line arguments |
| `cwd` | `() -> (string, error)` | Get current working directory |
| `chdir` | `(path string) -> (bool, error)` | Change directory |
| `hostname` | `() -> (string, error)` | Get machine hostname |
| `username` | `() -> (string, error)` | Get current username |
| `home_dir` | `() -> (string, error)` | Get home directory |
| `temp_dir` | `() -> string` | Get temporary directory |
| `pid` | `() -> int` | Get process ID |
| `ppid` | `() -> int` | Get parent process ID |
| `current_os` | `() -> int` | Get current OS |
| `arch` | `() -> string` | Get CPU architecture |
| `exit` | `(code int)` | Exit program |

#### Constants

- `MAC_OS` = 0
- `LINUX` = 1
- `WINDOWS` = 2
- `OTHER` = 3

### 10.11 HTTP Module (`@http`)

#### Request Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `get` | `(url string) -> (Response, error)` | GET request |
| `post` | `(url string, body string) -> (Response, error)` | POST request |
| `put` | `(url string, body string) -> (Response, error)` | PUT request |
| `delete` | `(url string) -> (Response, error)` | DELETE request |
| `patch` | `(url string, body string) -> (Response, error)` | PATCH request |
| `head` | `(url string) -> (Response, error)` | HEAD request |

#### Response Type

The `Response` struct contains:
- `status int` - HTTP status code
- `body string` - Response body
- `headers map[string:[string]]` - Response headers

#### Status Constants

`OK` (200), `CREATED` (201), `ACCEPTED` (202), `NO_CONTENT` (204), `MOVED_PERMANENTLY` (301), `FOUND` (302), `NOT_MODIFIED` (304), `BAD_REQUEST` (400), `UNAUTHORIZED` (401), `FORBIDDEN` (403), `NOT_FOUND` (404), `METHOD_NOT_ALLOWED` (405), `CONFLICT` (409), `INTERNAL_SERVER_ERROR` (500), `BAD_GATEWAY` (502), `SERVICE_UNAVAILABLE` (503)

### 10.12 Crypto Module (`@crypto`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `sha256` | `(data string) -> string` | SHA-256 hash (hex) |
| `sha512` | `(data string) -> string` | SHA-512 hash (hex) |
| `md5` | `(data string) -> string` | MD5 hash (hex) |
| `random_bytes` | `(length int) -> [byte]` | Cryptographically secure random bytes |
| `random_hex` | `(length int) -> string` | Cryptographically secure random hex |

### 10.13 Encoding Module (`@encoding`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `base64_encode` | `(s string) -> string` | Encode to base64 |
| `base64_decode` | `(s string) -> (string, error)` | Decode from base64 |
| `hex_encode` | `(s string) -> string` | Encode to hex |
| `hex_decode` | `(s string) -> (string, error)` | Decode from hex |
| `url_encode` | `(s string) -> string` | URL percent-encode |
| `url_decode` | `(s string) -> (string, error)` | URL percent-decode |

### 10.14 UUID Module (`@uuid`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `create` | `() -> string` | Generate UUID v4 with hyphens |
| `create_compact` | `() -> string` | Generate UUID v4 without hyphens |
| `is_valid` | `(s string) -> bool` | Validate UUID format |

#### Constants

- `NIL` - Nil UUID (00000000-0000-0000-0000-000000000000)

### 10.15 Bytes Module (`@bytes`)

| Function | Signature | Description |
|----------|-----------|-------------|
| `from_array` | `(arr [int]) -> [byte]` | Create from integer array |
| `from_string` | `(s string) -> [byte]` | Create from UTF-8 string |
| `from_hex` | `(hex string) -> ([byte], error)` | Decode hex string |
| `from_base64` | `(b64 string) -> ([byte], error)` | Decode base64 string |
| `to_string` | `(bytes [byte]) -> string` | Convert to UTF-8 string |
| `to_array` | `(bytes [byte]) -> [int]` | Convert to integer array |
| `to_hex` | `(bytes [byte]) -> string` | Encode to hex string |
| `to_base64` | `(bytes [byte]) -> string` | Encode to base64 string |

### 10.16 Binary Module (`@binary`)

Binary encoding/decoding for integers and floats in little-endian (le) and big-endian (be) formats.

#### 8-bit

| Function | Description |
|----------|-------------|
| `encode_i8`, `decode_i8` | Signed 8-bit |
| `encode_u8`, `decode_u8` | Unsigned 8-bit |

#### 16-bit

| Function | Description |
|----------|-------------|
| `encode_i16_le`, `encode_i16_be`, `decode_i16_le`, `decode_i16_be` | Signed 16-bit |
| `encode_u16_le`, `encode_u16_be`, `decode_u16_le`, `decode_u16_be` | Unsigned 16-bit |

#### 32-bit

| Function | Description |
|----------|-------------|
| `encode_i32_le`, `encode_i32_be`, `decode_i32_le`, `decode_i32_be` | Signed 32-bit |
| `encode_u32_le`, `encode_u32_be`, `decode_u32_le`, `decode_u32_be` | Unsigned 32-bit |

#### 64-bit

| Function | Description |
|----------|-------------|
| `encode_i64_le`, `encode_i64_be`, `decode_i64_le`, `decode_i64_be` | Signed 64-bit |
| `encode_u64_le`, `encode_u64_be`, `decode_u64_le`, `decode_u64_be` | Unsigned 64-bit |

#### Floats

| Function | Description |
|----------|-------------|
| `encode_f32_le`, `encode_f32_be`, `decode_f32_le`, `decode_f32_be` | 32-bit float |
| `encode_f64_le`, `encode_f64_be`, `decode_f64_le`, `decode_f64_be` | 64-bit float |

### 10.17 Database Module (`@db`)

A simple JSON-based key-value database.

| Function | Signature | Description |
|----------|-----------|-------------|
| `open` | `(path string) -> (Database, error)` | Open/create database |
| `close` | `(db Database) -> error` | Close database |
| `save` | `(db Database) -> error` | Save to disk |
| `set` | `(db Database, key string, value)` | Set key-value pair |
| `get` | `(db Database, key string) -> (any, error)` | Get value by key |
| `has` | `(db Database, key string) -> bool` | Check if key exists |
| `delete` | `(db Database, key string) -> bool` | Delete key |
| `clear` | `(db Database)` | Clear all entries |
| `keys` | `(db Database) -> [string]` | Get all keys |
| `values` | `(db Database) -> [any]` | Get all values |
| `length` | `(db Database) -> int` | Get number of entries |

---

## 11. Error Handling

### 11.1 Error Type

The `error` type represents an error condition. Errors are created with the `error()` function:

```ez
temp err error = error("something went wrong")
```

### 11.2 Error Returns

Functions that may fail conventionally return a tuple with the result and an error:

```ez
do read_file(path string) -> (string, error) {
    if !file_exists(path) {
        return "", error("file not found")
    }
    return contents, nil
}
```

### 11.3 Error Checking

Errors are checked by comparing to `nil`:

```ez
temp content, err = read_file("data.txt")
if err != nil {
    println("Error: ${err}")
    return
}
// Use content
```

### 11.4 Runtime Errors

Certain operations produce runtime errors that terminate program execution:

- Division by zero (int or float)
- Array index out of bounds
- Map key not found
- Invalid type conversion

Runtime errors include location information (file, line, column).

---

## 12. Memory Model

### 12.1 Garbage Collection

EZ uses automatic memory management via the Go runtime's garbage collector. Programmers do not manually allocate or free memory.

### 12.2 Value Semantics

Primitive types (`int`, `uint`, `float`, `string`, `bool`, `char`, `byte`) have value semantics. Assignment creates a copy:

```ez
temp a int = 42
temp b int = a  // b is a copy of a
b = 100         // a is still 42
```

### 12.3 Reference Semantics

Composite types (arrays, maps) have reference semantics for assignment but value semantics for function parameters (unless using mutable parameters).

### 12.4 Deep Copy

The `copy()` function creates a deep copy of any value, including nested structures:

```ez
temp original = Person{name: "Alice", age: 30}
temp duplicate = copy(original)
duplicate.age = 31  // original.age is still 30
```

### 12.5 Zero Values

The `new()` function creates a zero-initialized instance of a type:

| Type | Zero Value |
|------|------------|
| `int/uint` | `0` |
| `float` | `0.0` |
| `string` | `""` |
| `bool` | `false` |
| `char` | `'\0'` |
| `byte` | `0` |
| `map[K:V]` | `{}` |
| struct | All fields zero-initialized |

---

## 13. Program Execution

### 13.1 Program Structure

An EZ program consists of one or more source files. Each file may contain:

1. Module declaration (optional)
2. Import declarations
3. Using declarations
4. Top-level declarations (functions, structs, enums, constants)

### 13.2 Entry Point

Every EZ program must define a `main` function with no parameters and no return value:

```ez
do main() {
    // Program starts here
}
```

The `main` function is not called explicitly; it is invoked automatically when the program runs.

### 13.3 Evaluation Order

Expressions are evaluated left-to-right. Function arguments are evaluated before the function is called.

Short-circuit evaluation applies to `&&` and `||`:

```ez
// If a is false, b() is not called
if a && b() { ... }

// If a is true, b() is not called
if a || b() { ... }
```

### 13.4 Program Termination

A program terminates when:

1. The `main` function returns
2. A runtime error occurs

---

## Appendix A: Grammar Summary

```ebnf
program        = { declaration } .
declaration    = module_decl | import_decl | using_decl | func_decl
               | struct_decl | enum_decl | const_decl .

module_decl    = "module" identifier .
import_decl    = "import" [ "&" "use" ] import_path { "," import_path } .
import_path    = "@" identifier | string_literal .
using_decl     = "using" identifier { "," identifier } .

func_decl      = "do" identifier "(" [ param_list ] ")" [ "->" return_type ] block .
struct_decl    = "const" identifier "struct" "{" { field_decl } "}" .
enum_decl      = [ "#flags" | "#enum" "(" "int" ")" ] "const" identifier "enum"
               "{" enum_member { enum_member } "}" .
const_decl     = "const" identifier [ type ] "=" expression .
var_decl       = "temp" identifier type "=" expression .

statement      = var_decl | const_decl | if_stmt | for_stmt | for_each_stmt
               | while_stmt | when_stmt | return_stmt | break_stmt
               | continue_stmt | ensure_stmt | expr_stmt .

if_stmt        = "if" expression block { "or" expression block } [ "otherwise" block ] .
for_stmt       = "for" [ "(" ] identifier [ type ] "in" range_expr [ ")" ] block .
for_each_stmt  = "for_each" [ "(" ] identifier "in" expression [ ")" ] block .
while_stmt     = "as_long_as" expression block .
when_stmt      = [ "#strict" ] "when" expression "{" { when_case } [ default_case ] "}" .
when_case      = "is" pattern { "," pattern } block .
default_case   = "default" block .
return_stmt    = "return" [ expression { "," expression } ] .
break_stmt     = "break" .
continue_stmt  = "continue" .
ensure_stmt    = "ensure" call_expr .

expression     = /* standard expression grammar with operators */ .
block          = "{" { statement } "}" .
```

---

## Appendix B: Error Codes

| Code | Category | Description |
|------|----------|-------------|
| E1xxx | Lexer | Lexical analysis errors |
| E2xxx | Parser | Syntax errors |
| E3xxx | Type Checker | Type errors |
| E4xxx | Resolver | Name resolution errors |
| E5xxx | Runtime | Arithmetic errors |
| E9xxx | Runtime | Index/bounds errors |
| E10xxx | Runtime | String operation errors |
| E11xxx | Runtime | Time operation errors |
| E12xxx | Runtime | Map operation errors |

---

## Appendix C: Revision History

| Version | Date | Changes |
|---------|------|---------|
| 1.0-draft | January 2026 | Initial draft |
| 1.1-draft | January 31, 2026 | Added hex escapes, `!in` operator, blank identifier, `ref()` builtin, negative step `range()`, `temp` mutability; fixed compile-time → check-time terminology; added `uint` to primitive lists |

---

*This document is the authoritative specification for the EZ programming language.*
