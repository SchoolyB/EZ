/*
 * Task Manager - Task Service
 *
 * This module provides operations for managing tasks.
 * Demonstrates: array operations, functional patterns, filtering, and sorting.
 */

module task_service

import @std, @arrays, @time
import "./models"

using std, arrays

/*
 * add_task - Adds a task to the task list
 * Mutates the tasks array by appending the new task
 */
do add_task(tasks [Task], task Task) {
    append(tasks, task)
}

/*
 * remove_task - Removes a task by ID from the task list
 * Returns: true if task was found and removed, false otherwise
 */
do remove_task(tasks [Task], task_id int) -> bool {
    for i in range(0, len(tasks)) {
        if tasks[i].id == task_id {
            remove_at(tasks, i)
            return true
        }
    }
    return false
}

/*
 * find_task_by_id - Finds a task by its ID
 * Returns: Task if found, or an empty task with id=-1 if not found
 */
do find_task_by_id(tasks [Task], task_id int) -> Task {
    for_each task in tasks {
        if task.id == task_id {
            return task
        }
    }
    temp empty Task = Task{
        id: -1,
        title: "",
        description: "",
        priority: 0,
        status: "",
        category: "",
        created_at: 0,
        due_date: 0,
        completed_at: 0,
        tags: {}
    }
    return empty
}

/*
 * complete_task - Marks a task as done
 * Updates the task in place if found
 * Returns: true if task was found and updated
 */
do complete_task(tasks [Task], task_id int) -> bool {
    for i in range(0, len(tasks)) {
        if tasks[i].id == task_id {
            tasks[i].status = models.Status.DONE
            tasks[i].completed_at = time.now()
            return true
        }
    }
    return false
}

/*
 * start_task - Marks a task as in progress
 */
do start_task(tasks [Task], task_id int) -> bool {
    for i in range(0, len(tasks)) {
        if tasks[i].id == task_id {
            tasks[i].status = models.Status.IN_PROGRESS
            return true
        }
    }
    return false
}

/*
 * block_task - Marks a task as blocked
 */
do block_task(tasks [Task], task_id int) -> bool {
    for i in range(0, len(tasks)) {
        if tasks[i].id == task_id {
            tasks[i].status = models.Status.BLOCKED
            return true
        }
    }
    return false
}

/*
 * update_priority - Updates a task's priority
 */
do update_priority(tasks [Task], task_id int, new_priority int) -> bool {
    for i in range(0, len(tasks)) {
        if tasks[i].id == task_id {
            tasks[i].priority = new_priority
            return true
        }
    }
    return false
}

/*
 * add_tag - Adds a tag to a task
 */
do add_tag(tasks [Task], task_id int, tag string) -> bool {
    for i in range(0, len(tasks)) {
        if tasks[i].id == task_id {
            append(tasks[i].tags, tag)
            return true
        }
    }
    return false
}

/*
 * get_tasks_by_status - Filters tasks by status
 * Returns: New array containing only tasks with matching status
 */
do get_tasks_by_status(tasks [Task], status string) -> [Task] {
    temp result [Task] = {}
    for_each task in tasks {
        if task.status == status {
            append(result, task)
        }
    }
    return result
}

/*
 * get_tasks_by_category - Filters tasks by category
 */
do get_tasks_by_category(tasks [Task], category string) -> [Task] {
    temp result [Task] = {}
    for_each task in tasks {
        if task.category == category {
            append(result, task)
        }
    }
    return result
}

/*
 * get_tasks_by_priority - Filters tasks by minimum priority
 * Returns: Tasks with priority >= min_priority
 */
do get_tasks_by_priority(tasks [Task], min_priority int) -> [Task] {
    temp result [Task] = {}
    for_each task in tasks {
        if task.priority >= min_priority {
            append(result, task)
        }
    }
    return result
}

/*
 * get_overdue_tasks - Returns all overdue tasks
 */
do get_overdue_tasks(tasks [Task]) -> [Task] {
    temp result [Task] = {}
    for_each task in tasks {
        if models.is_overdue(task) {
            append(result, task)
        }
    }
    return result
}

/*
 * get_pending_tasks - Returns tasks that are not done
 */
do get_pending_tasks(tasks [Task]) -> [Task] {
    temp result [Task] = {}
    for_each task in tasks {
        if task.status != models.Status.DONE {
            append(result, task)
        }
    }
    return result
}

/*
 * count_by_status - Counts tasks by status
 */
do count_by_status(tasks [Task], status string) -> int {
    temp count int = 0
    for_each task in tasks {
        if task.status == status {
            count += 1
        }
    }
    return count
}

/*
 * calculate_stats - Calculates comprehensive statistics for tasks
 */
do calculate_stats(tasks [Task]) -> TaskStats {
    temp total int = len(tasks)
    temp completed int = count_by_status(tasks, models.Status.DONE)
    temp in_progress int = count_by_status(tasks, models.Status.IN_PROGRESS)
    temp blocked int = count_by_status(tasks, models.Status.BLOCKED)
    temp todo int = count_by_status(tasks, models.Status.TODO)

    temp completion_rate float = 0.0
    if total > 0 {
        completion_rate = float(completed) / float(total) * 100.0
    }

    temp total_priority int = 0
    for_each task in tasks {
        total_priority += task.priority
    }

    temp avg_priority float = 0.0
    if total > 0 {
        avg_priority = float(total_priority) / float(total)
    }

    temp stats TaskStats = TaskStats{
        total: total,
        completed: completed,
        in_progress: in_progress,
        blocked: blocked,
        todo: todo,
        completion_rate: completion_rate,
        avg_priority: avg_priority
    }
    return stats
}

/*
 * sort_by_priority_desc - Sorts tasks by priority (highest first)
 * Uses simple bubble sort for demonstration
 */
do sort_by_priority_desc(tasks [Task]) -> [Task] {
    temp result [Task] = {}
    for_each task in tasks {
        append(result, task)
    }

    temp n int = len(result)
    for i in range(0, n) {
        for j in range(0, n - i - 1) {
            if result[j].priority < result[j + 1].priority {
                temp swap Task = result[j]
                result[j] = result[j + 1]
                result[j + 1] = swap
            }
        }
    }
    return result
}

/*
 * sort_by_due_date - Sorts tasks by due date (earliest first)
 * Tasks without due dates (0) are placed at the end
 */
do sort_by_due_date(tasks [Task]) -> [Task] {
    temp result [Task] = {}
    for_each task in tasks {
        append(result, task)
    }

    temp n int = len(result)
    for i in range(0, n) {
        for j in range(0, n - i - 1) {
            temp a_due int = result[j].due_date
            temp b_due int = result[j + 1].due_date

            temp should_swap bool = false
            if a_due == 0 && b_due != 0 {
                should_swap = true
            } or a_due != 0 && b_due != 0 && a_due > b_due {
                should_swap = true
            }

            if should_swap {
                temp swap Task = result[j]
                result[j] = result[j + 1]
                result[j + 1] = swap
            }
        }
    }
    return result
}

/*
 * get_next_id - Generates the next available task ID
 */
do get_next_id(tasks [Task]) -> int {
    temp max_id int = 0
    for_each task in tasks {
        if task.id > max_id {
            max_id = task.id
        }
    }
    return max_id + 1
}
