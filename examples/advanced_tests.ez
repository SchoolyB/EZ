/*
 * EZ Language - Advanced Test Suite
 * Tests complex scenarios and edge cases to find potential bugs
 */

import @std
import @arrays

// Complex nested struct definitions
const Address struct {
    street string
    city string
    zipcode int
}

const Employee struct {
    name string
    age int
    salary float
    address Address
}

const Company struct {
    name string
    employeeCount int
}

// Test enum with different types
@(int)
const Priority enum {
    LOW = 1
    MEDIUM = 5
    HIGH = 10
    CRITICAL = 100
}

do main() {
    using std

    println("=== Advanced EZ Language Tests ===")
    println("")

    test_recursion()
    test_complex_arrays()
    test_nested_structs()
    test_complex_expressions()
    test_arithmetic_edge_cases()
    test_nested_loops()
    test_array_boundaries()
    test_complex_conditionals()
    test_function_edge_cases()
    test_struct_array_combinations()

    println("")
    println("=== All Advanced Tests Complete ===")
}

// Test 1: Recursion
do test_recursion() {
    using std
    println("Testing recursion...")

    temp result int = factorial(5)
    println("  Factorial(5) =", result)

    temp fib int = fibonacci(10)
    println("  Fibonacci(10) =", fib)

    println("  ✓ Recursion working")
}

do factorial(n int) -> int {
    if n <= 1 {
        return 1
    }
    temp prev int = factorial(n - 1)
    return n * prev
}

do fibonacci(n int) -> int {
    if n <= 1 {
        return n
    }
    temp a int = fibonacci(n - 1)
    temp b int = fibonacci(n - 2)
    return a + b
}

// Test 2: Complex array operations
do test_complex_arrays() {
    using std
    println("Testing complex arrays...")

    // Multi-dimensional array simulation with nested arrays
    temp matrix [int] = {1, 2, 3, 4, 5, 6, 7, 8, 9}

    // Array of structs
    temp addresses [Address] = {
        Address{street: "123 Main St", city: "Austin", zipcode: 78701},
        Address{street: "456 Elm St", city: "Dallas", zipcode: 75201}
    }

    println("  Matrix length:", len(matrix))
    println("  Addresses length:", len(addresses))
    println("  First address city:", addresses[0].city)

    // Nested array operations
    temp numbers [int] = {10, 20, 30, 40, 50}
    arrays.push(numbers, 60)
    temp last int = arrays.pop(numbers)
    println("  Popped value:", last)

    println("  ✓ Complex arrays working")
}

// Test 3: Deeply nested structs
do test_nested_structs() {
    using std
    println("Testing nested structs...")

    temp addr Address = Address{
        street: "789 Oak Ave",
        city: "Houston",
        zipcode: 77001
    }

    temp emp Employee = Employee{
        name: "John Doe",
        age: 30,
        salary: 75000.50,
        address: addr
    }

    temp company Company = Company{
        name: "TechCorp",
        employeeCount: 1
    }

    println("  Company:", company.name)
    println("  Employee count:", company.employeeCount)
    println("  Employee name:", emp.name)
    println("  Employee city:", emp.address.city)
    println("  Employee zipcode:", emp.address.zipcode)

    println("  ✓ Nested structs working")
}

// Test 4: Complex expressions
do test_complex_expressions() {
    using std
    println("Testing complex expressions...")

    // Nested arithmetic
    temp result1 int = ((10 + 5) * 3 - 7) / 2 + 1
    println("  Complex arithmetic 1:", result1)

    temp result2 float = (3.14 * 2.0) + (1.5 / 0.5) - 1.0
    println("  Complex arithmetic 2:", result2)

    // Chained comparisons
    temp x int = 15
    temp inRange bool = x > 10 && x < 20 && x != 15
    println("  Chained comparison (should be false):", inRange)

    // Complex boolean logic
    temp a bool = true
    temp b bool = false
    temp c bool = true
    temp complex bool = (a || b) && (c && !b) || false
    println("  Complex boolean:", complex)

    // Nested function calls
    temp nested int = add(multiply(2, 3), divide(10, 2))
    println("  Nested function calls:", nested)

    println("  ✓ Complex expressions working")
}

do add(x, y int) -> int {
    return x + y
}

do multiply(x, y int) -> int {
    return x * y
}

do divide(x, y int) -> int {
    return x / y
}

// Test 5: Arithmetic edge cases
do test_arithmetic_edge_cases() {
    using std
    println("Testing arithmetic edge cases...")

    // Large numbers
    temp big int = 1000000
    temp bigger int = big * 1000
    println("  Large number:", bigger)

    // Negative numbers
    temp negative int = -100
    temp negResult int = negative * -2
    println("  Negative multiplication:", negResult)

    // Float precision
    temp precise float = 3.141592653589793
    temp doubled float = precise * 2.0
    println("  Float precision:", doubled)

    // Mixed int/float (should auto-convert)
    temp mixed1 float = 10.5 + 5.0
    temp mixed2 float = 20.0 - 3.5
    println("  Mixed arithmetic 1:", mixed1)
    println("  Mixed arithmetic 2:", mixed2)

    // Modulo with various numbers
    temp mod1 int = 10 % 3
    temp mod2 int = 17 % 5
    temp mod3 int = 100 % 7
    println("  Modulo tests:", mod1, mod2, mod3)

    println("  ✓ Arithmetic edge cases working")
}

// Test 6: Deeply nested loops
do test_nested_loops() {
    using std
    println("Testing nested loops...")

    temp count int = 0
    for i in range(0, 2) {
        for j in range(0, 2) {
            for k in range(0, 2) {
                count += 1
            }
        }
    }
    println("  Triple nested loop count:", count)

    // Nested loop with breaks
    temp breakCount int = 0
    for i in range(0, 5) {
        for j in range(0, 5) {
            breakCount += 1
            if j == 2 {
                break
            }
        }
    }
    println("  Nested loop with breaks:", breakCount)

    // Nested loop with continue
    temp continueCount int = 0
    for i in range(0, 3) {
        for j in range(0, 3) {
            if j == 1 {
                continue
            }
            continueCount += 1
        }
    }
    println("  Nested loop with continue:", continueCount)

    println("  ✓ Nested loops working")
}

// Test 7: Array boundary conditions
do test_array_boundaries() {
    using std
    println("Testing array boundaries...")

    // Empty array
    temp empty [int] = {}
    println("  Empty array length:", len(empty))

    // Single element
    temp single [int] = {42}
    println("  Single element:", single[0])

    // First and last access
    temp nums [int] = {1, 2, 3, 4, 5}
    temp first int = nums[0]
    temp last int = nums[4]
    println("  First:", first, "Last:", last)

    // Array iteration boundaries
    for_each n in nums {
        temp dummy int = n
    }

    println("  ✓ Array boundaries working")
}

// Test 8: Complex conditionals
do test_complex_conditionals() {
    using std
    println("Testing complex conditionals...")

    // Multiple or conditions
    temp priority int = Priority.HIGH
    if priority == Priority.LOW {
        println("  Priority: Low")
    } or priority == Priority.MEDIUM {
        println("  Priority: Medium")
    } or priority == Priority.HIGH {
        println("  Priority: High")
    } or priority == Priority.CRITICAL {
        println("  Priority: Critical")
    } otherwise {
        println("  Priority: Unknown")
    }

    // Deeply nested if statements
    temp val int = 15
    if val > 10 {
        if val < 20 {
            if val != 15 {
                println("  Between 10 and 20, not 15")
            } otherwise {
                println("  Value is exactly 15")
            }
        }
    }

    // Complex condition with multiple variables
    temp isValid bool = true
    temp score int = 85
    temp attempts int = 3

    if isValid && score > 80 && attempts < 5 {
        println("  Complex condition: PASS")
    } otherwise {
        println("  Complex condition: FAIL")
    }

    println("  ✓ Complex conditionals working")
}

// Test 9: Function edge cases
do test_function_edge_cases() {
    using std
    println("Testing function edge cases...")

    // Function with no parameters
    no_params()

    // Function with many parameters
    temp result int = many_params(1, 2, 3, 4, 5)
    println("  Many params result:", result)

    // Function returning from nested condition
    temp condResult int = conditional_return(true)
    println("  Conditional return:", condResult)

    // Chained function calls
    temp chained int = chain_add(chain_add(1, 2), 3)
    println("  Chained calls:", chained)

    println("  ✓ Function edge cases working")
}

do no_params() {
    using std
    println("  Function with no params called")
}

do many_params(a, b, c, d, e int) -> int {
    return a + b + c + d + e
}

do conditional_return(flag bool) -> int {
    if flag {
        return 100
    }
    return 200
}

do chain_add(x, y int) -> int {
    return x + y
}

// Test 10: Struct and array combinations
do test_struct_array_combinations() {
    using std
    println("Testing struct and array combinations...")

    // Array of structs
    temp people [Person] = {
        Person{name: "Alice", age: 30, email: "alice@test.com"},
        Person{name: "Bob", age: 25, email: "bob@test.com"},
        Person{name: "Charlie", age: 35, email: "charlie@test.com"}
    }

    println("  Number of people:", len(people))

    // Iterate over struct array
    temp totalAge int = 0
    for_each person in people {
        totalAge += person.age
    }
    println("  Total age:", totalAge)

    // Multiple employees stored separately (since struct fields can't be arrays yet)
    temp emp1 Employee = Employee{
        name: "David",
        age: 28,
        salary: 60000.0,
        address: Address{street: "100 Park Ave", city: "NYC", zipcode: 10001}
    }

    temp emp2 Employee = Employee{
        name: "Eve",
        age: 32,
        salary: 75000.0,
        address: Address{street: "200 Main St", city: "LA", zipcode: 90001}
    }

    temp company Company = Company{
        name: "StartupCo",
        employeeCount: 2
    }

    println("  Company has", company.employeeCount, "employees")

    println("  ✓ Struct and array combinations working")
}

// Additional struct for testing
const Person struct {
    name string
    age int
    email string
}
