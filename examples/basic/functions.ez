/*
 * functions.ez - Defining and calling functions
 *
 * Functions in EZ use the 'do' keyword.
 * Return types are specified with '->'
 * Named return variables use '-> (name type)' syntax.
 */

import @std
using std

do main() {
    println("=== Functions in EZ ===")
    println("")

    // Calling a simple function
    greet()

    // Function with parameters
    greet_person("Alice")
    greet_person("Bob")

    // Function with return value
    temp sum int = add(5, 3)
    println("add(5, 3) = ${sum}")

    // Function with multiple parameters
    temp result float = calculate(10.0, 5.0, 2.0)
    println("calculate(10, 5, 2) = ${result}")

    // Recursive function
    temp fact int = factorial(5)
    println("factorial(5) = ${fact}")

    // Function returning a string
    temp msg string = get_greeting("World")
    println(msg)

    // Named return variables
    println("")
    println("--- Named Returns ---")

    temp area int = rect_area(5, 3)
    println("rect_area(5, 3) = ${area}")

    temp x int, y int = swap(10, 20)
    println("swap(10, 20) = ${x}, ${y}")

    temp name string, age int, active bool = get_user()
    println("get_user() = ${name}, ${age}, ${active}")

    temp min int, max int = min_max(7, 3, 9, 1, 5)
    println("min_max(7,3,9,1,5) = min:${min}, max:${max}")
}

// Simple function with no parameters or return
do greet() {
    println("Hello!")
}

// Function with a parameter
do greet_person(name string) {
    println("Hello, ${name}!")
}

// Function with return type
do add(a int, b int) -> int {
    return a + b
}

// Multiple parameters with shared types
do calculate(x float, y float, z float) -> float {
    return (x + y) * z
}

// Recursive function
do factorial(n int) -> int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

// Function returning a string
do get_greeting(name string) -> string {
    return "Welcome, ${name}!"
}

// Named return: single value
do rect_area(w int, h int) -> (area int) {
    area = w * h
    return area
}

// Named return: multiple values
do swap(a int, b int) -> (x int, y int) {
    x = b
    y = a
    return x, y
}

// Named return: mixed types
do get_user() -> (name string, age int, active bool) {
    name = "Alice"
    age = 30
    active = true
    return name, age, active
}

// Named return: shared type shorthand
do min_max(a int, b int, c int, d int, e int) -> (min, max int) {
    min = a
    max = a
    if b < min { min = b }
    if c < min { min = c }
    if d < min { min = d }
    if e < min { min = e }
    if b > max { max = b }
    if c > max { max = c }
    if d > max { max = d }
    if e > max { max = e }
    return min, max
}
