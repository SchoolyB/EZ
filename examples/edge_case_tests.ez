/*
 * EZ Language - Edge Case Tests
 * Tests unusual edge cases and boundary conditions
 */

import @std
import @arrays

do main() {
    using std

    println("=== Edge Case Tests ===")
    println("")

    test_string_edge_cases()
    test_char_edge_cases()
    test_zero_values()
    test_enum_edge_cases()
    test_scope_edge_cases()
    test_operator_precedence()
    test_array_modification()
    test_struct_mutation()
    test_type_boundaries()
    test_empty_blocks()

    println("")
    println("=== Edge Case Tests Complete ===")
}

// Test 1: String edge cases
do test_string_edge_cases() {
    using std
    println("Testing string edge cases...")

    // Empty string
    temp empty string = ""
    println("  Empty string length:", len(empty))

    // Single character string
    temp single string = "a"
    println("  Single char length:", len(single))

    // String with spaces
    temp spaces string = "   "
    println("  Spaces length:", len(spaces))

    // String concatenation chains
    temp concat string = "a" + "b" + "c" + "d" + "e"
    println("  Concatenation:", concat)

    // String with special characters
    temp special string = "Hello\nWorld"
    println("  Special chars work")

    // String indexing at boundaries
    temp text string = "Hello"
    temp firstChar char = text[0]
    temp lastChar char = text[4]
    println("  First char:", firstChar, "Last char:", lastChar)

    println("  ✓ String edge cases working")
}

// Test 2: Character edge cases
do test_char_edge_cases() {
    using std
    println("Testing char edge cases...")

    // Various characters
    temp letter char = 'A'
    temp digit char = '5'
    temp space char = ' '
    temp newline char = '\n'

    println("  Letter:", letter)
    println("  Digit:", digit)
    println("  Space: (invisible)")

    // Char comparison
    temp isEqual bool = letter == 'A'
    temp notEqual bool = letter != 'B'
    println("  Char comparison works:", isEqual, notEqual)

    println("  ✓ Char edge cases working")
}

// Test 3: Zero and default values
do test_zero_values() {
    using std
    println("Testing zero values...")

    // Zero int
    temp zeroInt int = 0
    println("  Zero int:", zeroInt)

    // Zero float
    temp zeroFloat float = 0.0
    println("  Zero float:", zeroFloat)

    // Arithmetic with zero
    temp addZero int = 10 + 0
    temp multZero int = 10 * 0
    temp subZero int = 10 - 0
    println("  Add zero:", addZero, "Mult zero:", multZero, "Sub zero:", subZero)

    // Comparison with zero
    temp isZero bool = zeroInt == 0
    temp notZero bool = 5 != 0
    temp ltZero bool = -5 < 0
    temp gtZero bool = 5 > 0
    println("  Zero comparisons:", isZero, notZero, ltZero, gtZero)

    println("  ✓ Zero values working")
}

// Test 4: Enum edge cases
do test_enum_edge_cases() {
    using std
    println("Testing enum edge cases...")

    // Access different enum values
    temp s1 int = STATUS.PENDING
    temp s2 int = STATUS.ACTIVE
    temp s3 int = STATUS.INACTIVE
    println("  Enum values:", s1, s2, s3)

    // Use enums in comparisons
    temp currentStatus int = STATUS.ACTIVE
    if currentStatus == STATUS.PENDING {
        println("  Status is PENDING")
    } or currentStatus == STATUS.ACTIVE {
        println("  Status is ACTIVE")
    } otherwise {
        println("  Status is INACTIVE")
    }

    // String enum
    temp color string = COLORS.RED
    println("  String enum:", color)

    println("  ✓ Enum edge cases working")
}

const STATUS enum {
    PENDING
    ACTIVE
    INACTIVE
}

@(string)
const COLORS enum {
    RED = "red"
    GREEN = "green"
    BLUE = "blue"
}

// Test 5: Scope edge cases
do test_scope_edge_cases() {
    using std
    println("Testing scope edge cases...")

    // Variable shadowing at different levels
    temp x int = 1
    println("  Outer x:", x)

    if true {
        temp x int = 2
        println("  First level x:", x)

        if true {
            temp x int = 3
            println("  Second level x:", x)
        }

        println("  Back to first level x:", x)
    }

    println("  Back to outer x:", x)

    // Multiple variables with same scope
    temp a int = 10
    temp b int = 20
    temp c int = 30
    println("  Multiple vars:", a, b, c)

    // Const vs temp in same scope
    const constVal int = 100
    temp tempVal int = 200
    println("  Const:", constVal, "Temp:", tempVal)

    println("  ✓ Scope edge cases working")
}

// Test 6: Operator precedence
do test_operator_precedence() {
    using std
    println("Testing operator precedence...")

    // Multiplication before addition
    temp result1 int = 2 + 3 * 4
    println("  2 + 3 * 4 =", result1, "(expected 14)")

    // Division before subtraction
    temp result2 int = 10 - 8 / 2
    println("  10 - 8 / 2 =", result2, "(expected 6)")

    // Parentheses override
    temp result3 int = (2 + 3) * 4
    println("  (2 + 3) * 4 =", result3, "(expected 20)")

    // Complex precedence
    temp result4 int = 10 + 5 * 2 - 3
    println("  10 + 5 * 2 - 3 =", result4, "(expected 17)")

    // Boolean operators
    temp bool1 bool = true || false && false
    temp bool2 bool = (true || false) && false
    println("  OR before AND:", bool1, "Parentheses:", bool2)

    // Comparison operators
    temp comp1 bool = 5 > 3 && 10 < 20
    temp comp2 bool = 5 > 3 || 10 > 20
    println("  Comparison AND:", comp1, "Comparison OR:", comp2)

    println("  ✓ Operator precedence working")
}

// Test 7: Array modification patterns
do test_array_modification() {
    using std
    println("Testing array modification...")

    // Modify array elements
    temp nums [int] = {1, 2, 3, 4, 5}
    nums[0] = 100
    nums[4] = 500
    println("  Modified array first:", nums[0], "last:", nums[4])

    // Multiple modifications
    temp values [int] = {10, 20, 30}
    values[0] += 5
    values[1] -= 5
    values[2] *= 2
    println("  After operations:", values[0], values[1], values[2])

    // Array element swap pattern
    temp arr [int] = {1, 2, 3}
    temp temp1 int = arr[0]
    arr[0] = arr[2]
    arr[2] = temp1
    println("  After swap:", arr[0], arr[1], arr[2])

    println("  ✓ Array modification working")
}

// Test 8: Struct field mutation
do test_struct_mutation() {
    using std
    println("Testing struct mutation...")

    temp person Person = Person{name: "Alice", age: 25}
    println("  Initial:", person.name, person.age)

    // Modify fields
    person.name = "Bob"
    person.age = 30
    println("  After modification:", person.name, person.age)

    // Increment field
    person.age += 1
    println("  After increment:", person.age)

    // Multiple modifications
    person.age *= 2
    person.age -= 10
    println("  After operations:", person.age)

    println("  ✓ Struct mutation working")
}

const Person struct {
    name string
    age int
}

// Test 9: Type boundaries
do test_type_boundaries() {
    using std
    println("Testing type boundaries...")

    // Max-ish values (not actual max, but large)
    temp bigInt int = 999999999
    temp smallInt int = -999999999
    println("  Large int:", bigInt, "Small int:", smallInt)

    // Very small float
    temp smallFloat float = 0.000001
    temp largeFloat float = 999999.999999
    println("  Small float:", smallFloat, "Large float:", largeFloat)

    // Boolean true/false
    temp t bool = true
    temp f bool = false
    println("  Booleans:", t, f)

    // Type consistency in operations
    temp intResult int = bigInt + smallInt
    temp floatResult float = largeFloat * 2.0
    println("  Type operations:", intResult, floatResult)

    println("  ✓ Type boundaries working")
}

// Test 10: Empty blocks and minimal code
do test_empty_blocks() {
    using std
    println("Testing empty blocks...")

    // If with minimal code
    temp x int = 10
    if x > 5 {
        temp y int = 20
    }

    // Empty else (implicit)
    if x < 5 {
        println("  Won't print")
    }

    // Loop with single statement
    for i in range(0, 2) {
        temp j int = i
    }

    // Minimal function call
    minimal_function()

    println("  ✓ Empty blocks working")
}

do minimal_function() {
    using std
    println("  Minimal function called")
}
