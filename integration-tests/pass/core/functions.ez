/*
 * functions.ez - Test function definitions, parameters, returns, mutable params
 */

import @std, @arrays
using std

const Point struct {
    x int
    y int
}

const GameState struct {
    score int
    lives int
    level int
}

do main() {
    println("=== Functions Test ===")
    temp passed int = 0
    temp failed int = 0

    // ==================== BASIC FUNCTIONS ====================
    println("  -- Basic Functions --")

    // Test 1: function with params and return
    temp sum int = add(5, 3)
    if sum == 8 {
        println("  [PASS] add(5, 3) = 8")
        passed += 1
    } otherwise {
        println("  [FAIL] add(5, 3): expected 8, got ${sum}")
        failed += 1
    }

    // Test 2: function returning struct
    temp origin Point = make_point(0, 0)
    if origin.x == 0 && origin.y == 0 {
        println("  [PASS] make_point(0, 0) returns Point")
        passed += 1
    } otherwise {
        println("  [FAIL] make_point: x=${origin.x}, y=${origin.y}")
        failed += 1
    }

    // Test 3: function with array param
    temp numbers [int] = {1, 2, 3, 4, 5}
    temp total int = sum_array(numbers)
    if total == 15 {
        println("  [PASS] sum_array({1,2,3,4,5}) = 15")
        passed += 1
    } otherwise {
        println("  [FAIL] sum_array: expected 15, got ${total}")
        failed += 1
    }

    // Test 4: recursive function
    temp fact int = factorial(5)
    if fact == 120 {
        println("  [PASS] factorial(5) = 120")
        passed += 1
    } otherwise {
        println("  [FAIL] factorial(5): expected 120, got ${fact}")
        failed += 1
    }

    // Test 5: function returning array
    temp doubled [int] = double_array({1, 2, 3})
    if len(doubled) == 3 && doubled[0] == 2 && doubled[1] == 4 && doubled[2] == 6 {
        println("  [PASS] double_array({1,2,3}) = {2,4,6}")
        passed += 1
    } otherwise {
        println("  [FAIL] double_array: got ${doubled}")
        failed += 1
    }

    // ==================== MUTABLE PARAMETERS ====================
    println("  -- Mutable Parameters (&) --")

    // Test 6: basic mutable int
    temp counter int = 0
    increment(counter)
    if counter == 1 {
        println("  [PASS] increment(&n int)")
        passed += 1
    } otherwise {
        println("  [FAIL] increment: expected 1, got ${counter}")
        failed += 1
    }

    // Test 7: multiple increments
    increment(counter)
    increment(counter)
    if counter == 3 {
        println("  [PASS] multiple increments")
        passed += 1
    } otherwise {
        println("  [FAIL] multiple increments: expected 3, got ${counter}")
        failed += 1
    }

    // Test 8: swap values
    temp x int = 10
    temp y int = 20
    swap_values(x, y)
    if x == 20 && y == 10 {
        println("  [PASS] swap_values(&a, &b int)")
        passed += 1
    } otherwise {
        println("  [FAIL] swap: x=${x}, y=${y}")
        failed += 1
    }

    // Test 9: mutable float
    temp f float = 0.0
    set_to_pi(f)
    if f > 3.14 && f < 3.15 {
        println("  [PASS] set_to_pi(&f float)")
        passed += 1
    } otherwise {
        println("  [FAIL] set_to_pi: got ${f}")
        failed += 1
    }

    // Test 10: mutable bool
    temp flag bool = false
    toggle_bool(flag)
    if flag == true {
        println("  [PASS] toggle_bool(&b bool)")
        passed += 1
    } otherwise {
        println("  [FAIL] toggle_bool: expected true")
        failed += 1
    }

    // Test 11: mutable string
    temp message string = "Hello"
    append_world(message)
    if message == "Hello, World!" {
        println("  [PASS] append_world(&s string)")
        passed += 1
    } otherwise {
        println("  [FAIL] append_world: got '${message}'")
        failed += 1
    }

    // Test 12: mutable struct
    temp p Point = Point{x: 5, y: 10}
    double_point(p)
    if p.x == 10 && p.y == 20 {
        println("  [PASS] double_point(&p Point)")
        passed += 1
    } otherwise {
        println("  [FAIL] double_point: x=${p.x}, y=${p.y}")
        failed += 1
    }

    // Test 13: mutable array
    temp nums [int] = {1, 2, 3, 4, 5}
    double_array_in_place(nums)
    if nums[0] == 2 && nums[2] == 6 && nums[4] == 10 {
        println("  [PASS] double_array_in_place(&arr [int])")
        passed += 1
    } otherwise {
        println("  [FAIL] double_array_in_place: ${nums}")
        failed += 1
    }

    // Test 14: mixed mutable and immutable params
    temp result int = 0
    add_to_result(result, 15)
    add_to_result(result, 25)
    if result == 40 {
        println("  [PASS] mixed params: add_to_result")
        passed += 1
    } otherwise {
        println("  [FAIL] mixed params: expected 40, got ${result}")
        failed += 1
    }

    // Test 15: multiple output pattern (quotient and remainder)
    temp q int = 0
    temp r int = 0
    divide_with_remainder(q, r, 17, 5)
    if q == 3 && r == 2 {
        println("  [PASS] divide_with_remainder: 17/5 = 3 r 2")
        passed += 1
    } otherwise {
        println("  [FAIL] divide_with_remainder: q=${q}, r=${r}")
        failed += 1
    }

    // Test 16: state machine pattern
    temp game GameState = GameState{score: 0, lives: 3, level: 1}
    add_score(game, 50)
    add_score(game, 60)
    if game.score == 110 && game.level == 2 {
        println("  [PASS] state machine: level up at 100")
        passed += 1
    } otherwise {
        println("  [FAIL] state machine: score=${game.score}, level=${game.level}")
        failed += 1
    }

    lose_life(game)
    if game.lives == 2 {
        println("  [PASS] lose_life: lives = 2")
        passed += 1
    } otherwise {
        println("  [FAIL] lose_life: expected 2, got ${game.lives}")
        failed += 1
    }

    // Summary
    println("")
    println("Results: ${passed} passed, ${failed} failed")

    if failed > 0 {
        println("SOME TESTS FAILED")
    } otherwise {
        println("ALL TESTS PASSED")
    }
}

// Helper functions
do add(a int, b int) -> int {
    return a + b
}

do make_point(x int, y int) -> Point {
    temp p Point = Point{x: x, y: y}
    return p
}

do sum_array(nums [int]) -> int {
    temp total int = 0
    for_each n in nums {
        total += n
    }
    return total
}

do factorial(n int) -> int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

do double_array(nums [int]) -> [int] {
    temp result [int] = {}
    for_each n in nums {
        arrays.append(result, n * 2)
    }
    return result
}

do increment(&n int) {
    n = n + 1
}

do swap_values(&a, &b int) {
    temp t int = a
    a = b
    b = t
}

do set_to_pi(&f float) {
    f = 3.14159
}

do toggle_bool(&b bool) {
    b = !b
}

do append_world(&s string) {
    s = s + ", World!"
}

do double_point(&p Point) {
    p.x = p.x * 2
    p.y = p.y * 2
}

do double_array_in_place(&arr [int]) {
    for i in range(0, len(arr)) {
        arr[i] = arr[i] * 2
    }
}

do add_to_result(&result int, value int) {
    result = result + value
}

do divide_with_remainder(&quotient, &remainder int, a, b int) {
    quotient = a / b
    remainder = a % b
}

do add_score(&state GameState, points int) {
    state.score = state.score + points
    if state.score >= state.level * 100 {
        state.level = state.level + 1
    }
}

do lose_life(&state GameState) {
    state.lives = state.lives - 1
}
