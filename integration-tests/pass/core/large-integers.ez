/*
 * large-integers.ez - Test i128/u128 and other large integer types
 * Tests parsing and arithmetic for integers beyond int64 range
 */

import @std
using std

do main() {
    println("=== Large Integers Test ===")
    temp passed int = 0
    temp failed int = 0

    // Test 1: i128 literal larger than int64 max
    temp big i128 = 10000000000000000000
    if big == 10000000000000000000 {
        println("  [PASS] i128 literal > int64 max")
        passed += 1
    } otherwise {
        println("  [FAIL] i128 literal > int64 max")
        failed += 1
    }

    // Test 2: i128 arithmetic beyond int64
    temp a i128 = 9223372036854775807  // max int64
    temp b i128 = 1
    temp sum i128 = a + b
    if sum == 9223372036854775808 {
        println("  [PASS] i128 addition beyond int64 max")
        passed += 1
    } otherwise {
        println("  [FAIL] i128 addition beyond int64 max: expected 9223372036854775808, got ${sum}")
        failed += 1
    }

    // Test 3: u128 large value
    temp u_big u128 = 18446744073709551615  // max uint64
    if u_big == 18446744073709551615 {
        println("  [PASS] u128 literal = uint64 max")
        passed += 1
    } otherwise {
        println("  [FAIL] u128 literal = uint64 max")
        failed += 1
    }

    // Test 4: u128 arithmetic beyond uint64
    temp u_max u128 = 18446744073709551615
    temp u_one u128 = 1
    temp u_sum u128 = u_max + u_one
    if u_sum == 18446744073709551616 {
        println("  [PASS] u128 addition beyond uint64 max")
        passed += 1
    } otherwise {
        println("  [FAIL] u128 addition beyond uint64 max: expected 18446744073709551616, got ${u_sum}")
        failed += 1
    }

    // Test 5: i128 multiplication
    temp x i128 = 10000000000
    temp y i128 = 10000000000
    temp product i128 = x * y
    if product == 100000000000000000000 {
        println("  [PASS] i128 multiplication")
        passed += 1
    } otherwise {
        println("  [FAIL] i128 multiplication: expected 100000000000000000000, got ${product}")
        failed += 1
    }

    // Test 6: i128 negative values
    temp neg i128 = -9223372036854775808  // min int64
    temp neg_minus i128 = neg - 1
    if neg_minus == -9223372036854775809 {
        println("  [PASS] i128 subtraction below int64 min")
        passed += 1
    } otherwise {
        println("  [FAIL] i128 subtraction below int64 min: expected -9223372036854775809, got ${neg_minus}")
        failed += 1
    }

    // Test 7: i64 at boundary (should work)
    temp i64_max i64 = 9223372036854775807
    if i64_max == 9223372036854775807 {
        println("  [PASS] i64 max value")
        passed += 1
    } otherwise {
        println("  [FAIL] i64 max value")
        failed += 1
    }

    // Test 8: u64 at boundary (should work)
    temp u64_max u64 = 18446744073709551615
    if u64_max == 18446744073709551615 {
        println("  [PASS] u64 max value")
        passed += 1
    } otherwise {
        println("  [FAIL] u64 max value")
        failed += 1
    }

    // Test 9: i128 division
    temp dividend i128 = 100000000000000000000
    temp divisor i128 = 10000000000
    temp quotient i128 = dividend / divisor
    if quotient == 10000000000 {
        println("  [PASS] i128 division")
        passed += 1
    } otherwise {
        println("  [FAIL] i128 division: expected 10000000000, got ${quotient}")
        failed += 1
    }

    // Test 10: i128 modulo
    temp mod_result i128 = 100000000000000000001 % 10000000000
    if mod_result == 1 {
        println("  [PASS] i128 modulo")
        passed += 1
    } otherwise {
        println("  [FAIL] i128 modulo: expected 1, got ${mod_result}")
        failed += 1
    }

    // Summary
    println("")
    println("Results: ${passed} passed, ${failed} failed")

    if failed > 0 {
        println("SOME TESTS FAILED")
    } otherwise {
        println("ALL TESTS PASSED")
    }
}
