/*
 * db.ez - Test @db standard library with PROPER ASSERTIONS
 */

import @std, @db, @json
using std

const User struct {
	name string
	age  int
}

do main() {
    println("=== @db Standard Library Test ===")
    temp passed int = 0
    temp failed int = 0

    // ==================== db.open ====================
    println("  -- Opening --")

    // Test 1: opening database
    temp store Database, err error = db.open("mydb.ezdb")
    if err != nil {
        println("   [FAIL] db.open(string): unexpected error")
        failed += 1
    } otherwise {
        println("   [PASS] db.open(string)")
        passed += 1
    }
    
    // ==================== db.set ====================
    println("  -- Setting --")
    
    // Test 1: setting string
    db.set(store, "config:theme", "dark")

    // Test 2: setting json encoded string
		temp user1 User = User{name: "Alice", age: 30}
		temp user1data, _ = json.encode(user1)
    db.set(store, "user:1", user1data)

		temp user2 User = User{name: "Bob", age: 25}
		temp user2data, _ = json.encode(user2)
    db.set(store, "user:2", user2data)

    println("   [PASS] db.set(database, string, string)")
    passed += 1
    
    // ==================== db.get ====================
    println("  -- Getting --")

    // Test 1: getting value for existing key
    temp data, found = db.get(store, "user:1")
		if found {
				temp user, _ = json.decode(data, User)
        if user.name == "Alice" && user.age == 30 {
            println("   [PASS] db.get(database, string)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.get(database, string): stored incorrect value in database")
            failed += 1
        }
		} otherwise {
        println("   [FAIL] db.get(database, string): value not stored in database")
        failed += 1
    }

    // Test 2: getting value for non-existent key
    data, found = db.get(store, "user:3")
    if found {
        println("   [FAIL] db.get(database, string): expected `false`, got `true`")
        failed += 1
    } otherwise {
        println("   [PASS] db.get(database, string)")
        passed += 1
    }
    
    // ==================== db.has ====================
    println("  -- db.has --")

    // Test 1: checking for existing key
    if db.has (store, "user:2") {
        println("   [PASS] db.has(database, string)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.has(database, string): expected `true`, got `false`")
        failed += 1
    }

    // Test 2: checking for non-existent key
    if !db.has (store, "user:3") {
        println("   [PASS] db.has(database, string)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.has(database, string): expected `false`, got `true`")
        failed += 1
    }

    // ==================== db.keys ====================
    println("  -- db.keys --")

    // Test 1: Lising present keys
    temp expected_all_keys [string] = {"config:theme", "user:1", "user:2"}

		temp keys [string] = db.keys(store)

    temp unknown_key bool = false
    for i in range(0, len(keys)) {
        if keys[i] != expected_all_keys[i] {
            unknown_key = true
        }
    }

    if unknown_key {
        println("   [FAIL] db.keys(database): unknown key found in database")
        failed += 1
    } otherwise {
        println("   [PASS] db.keys(database)")
        passed += 1
    }
    
    // ==================== db.prefix ====================
    println("  -- db.prefix --")
    
    // Test 1: Listing keys with prefix
    temp expected_prefix_keys [string] = {"user:1", "user:2"}

    temp users [string] = db.prefix(store, "user:")

    temp unknown_prefix_key bool = false
    for i in range(0, len(users)) {
        if users[i] != expected_prefix_keys[i] {
            unknown_prefix_key = true
        }
    }

    if unknown_prefix_key {
        println("   [FAIL] db.prefix(database,string): unknown key found in database")
        failed += 1
    } otherwise {
        println("   [PASS] db.prefix(database,string)")
        passed += 1
    }

    // ==================== db.count ====================
    println("  -- db.count --")
    
    // Test 1: Count of all keys
    if db.count(store) == 3 {
        println("   [PASS] db.count(database)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.count(database): incorrect count of keys in database")
        failed += 1
    }

    // ==================== db.delete ====================
    println("  -- db.delete --")

    // Test 1: Delete existing key
    if db.delete(store, "config:theme") {
        println("   [PASS] db.delete(database, string)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.delete(database, string): could not delete existing key")
        failed += 1
    }

    // Test 2: Delete non-existent key
    if !db.delete(store, "config:time") {
        println("   [PASS] db.delete(database, string)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.delete(database, string): deleted non-existent key")
        failed += 1
    }
    
    // ==================== db.save ====================
    println("  -- db.save --")
    
    // Test 1: Manual save to disk
		temp save_err error = db.save(store)
    if save_err == nil {
        println("   [PASS] db.save(database)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.save(database): unexpected error while saving to disk")
        println("Failed: ${save_err.message}")
        failed += 1
    }
    
    // ==================== db.sort ====================
    println("  -- db.sort --")

    // Create a fresh database for sort tests
    temp sort_store Database, sort_err error = db.open("sort_test.ezdb")
    if sort_err != nil {
        println("   [FAIL] db.sort: could not open test database")
        failed += 1
    } otherwise {
        // Add keys in non-alphabetical order
        db.set(sort_store, "zebra", "short")
        db.set(sort_store, "apple", "a")
        db.set(sort_store, "10", "ten")
        db.set(sort_store, "2", "two")
        db.set(sort_store, "banana", "medium val")

        // Test db.ALPHA - keys A-Z
        db.sort(sort_store, db.ALPHA)
        temp alpha_keys [string] = db.keys(sort_store)
        if alpha_keys[0] == "10" && alpha_keys[1] == "2" && alpha_keys[2] == "apple" {
            println("   [PASS] db.sort(db.ALPHA)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.ALPHA): incorrect order")
            failed += 1
        }

        // Test db.ALPHA_DESC - keys Z-A
        db.sort(sort_store, db.ALPHA_DESC)
        temp alpha_desc_keys [string] = db.keys(sort_store)
        if alpha_desc_keys[0] == "zebra" && alpha_desc_keys[1] == "banana" {
            println("   [PASS] db.sort(db.ALPHA_DESC)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.ALPHA_DESC): incorrect order")
            failed += 1
        }

        // Test db.VALUE_ALPHA - values A-Z
        db.sort(sort_store, db.VALUE_ALPHA)
        temp val_alpha_keys [string] = db.keys(sort_store)
        // "a" < "medium val" < "short" < "ten" < "two"
        if val_alpha_keys[0] == "apple" {
            println("   [PASS] db.sort(db.VALUE_ALPHA)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.VALUE_ALPHA): incorrect order")
            failed += 1
        }

        // Test db.KEY_LEN - shortest keys first
        db.sort(sort_store, db.KEY_LEN)
        temp key_len_keys [string] = db.keys(sort_store)
        // "2" (1), "10" (2), "apple" (5), "zebra" (5), "banana" (6)
        if key_len_keys[0] == "2" && key_len_keys[1] == "10" {
            println("   [PASS] db.sort(db.KEY_LEN)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.KEY_LEN): incorrect order")
            failed += 1
        }

        // Test db.VALUE_LEN - shortest values first
        db.sort(sort_store, db.VALUE_LEN)
        temp val_len_keys [string] = db.keys(sort_store)
        // "a" (1), "two" (3), "ten" (3), "short" (5), "medium val" (10)
        if val_len_keys[0] == "apple" {
            println("   [PASS] db.sort(db.VALUE_LEN)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.VALUE_LEN): incorrect order")
            failed += 1
        }

        // Test db.NUMERIC - numeric keys first, ascending
        db.sort(sort_store, db.NUMERIC)
        temp numeric_keys [string] = db.keys(sort_store)
        // 2, 10, then alpha: apple, banana, zebra
        if numeric_keys[0] == "2" && numeric_keys[1] == "10" && numeric_keys[2] == "apple" {
            println("   [PASS] db.sort(db.NUMERIC)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.NUMERIC): incorrect order")
            failed += 1
        }

        // Test db.NUMERIC_DESC - numeric keys descending
        db.sort(sort_store, db.NUMERIC_DESC)
        temp numeric_desc_keys [string] = db.keys(sort_store)
        // zebra, banana, apple, 10, 2 (alpha desc for non-numeric, then numeric desc)
        if numeric_desc_keys[len(numeric_desc_keys)-1] == "2" && numeric_desc_keys[len(numeric_desc_keys)-2] == "10" {
            println("   [PASS] db.sort(db.NUMERIC_DESC)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.NUMERIC_DESC): incorrect order")
            failed += 1
        }

        db.close(sort_store)
    }

    // ==================== db.close ====================
    println("  -- db.close --")

    temp close_err error = db.close(store)
    if close_err == nil {
        println("   [PASS] db.close(database)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.close(database): unexpected error while closing database")
        failed += 1
    }


    // ==================== Summary ====================
    println("")
    println("=== Summary ===")
    println("  Passed: ${passed}")
    println("  Failed: ${failed}")
    println("")

    if failed > 0 {
        println("SOME TESTS FAILED")
    } otherwise {
        println("ALL TESTS PASSED")
    }
}
