/*
 * db.ez - Test @db standard library with PROPER ASSERTIONS
 */

import @std, @db, @json
using std

const User struct {
	name string
	age  int
}

do main() {
    println("=== @db Standard Library Test ===")
    temp passed int = 0
    temp failed int = 0

    // ==================== db.open ====================
    println("  -- Opening --")

    // Test 1: opening database
    temp store Database, err error = db.open("mydb.ezdb")
    if err != nil {
        println("   [FAIL] db.open(string): unexpected error")
        failed += 1
    } otherwise {
        println("   [PASS] db.open(string)")
        passed += 1
    }
    
    // ==================== db.set ====================
    println("  -- Setting --")

    // Test 1: setting string and verifying it was stored
    db.set(store, "config:theme", "dark")
    temp theme_val, theme_found = db.get(store, "config:theme")
    if theme_found && theme_val == "dark" {
        println("   [PASS] db.set(database, string, string)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.set(database, string, string): value not stored correctly")
        failed += 1
    }

    // Test 2: setting json encoded string
    temp user1 User = User{name: "Alice", age: 30}
    temp user1data, _ = json.encode(user1)
    db.set(store, "user:1", user1data)

    temp user2 User = User{name: "Bob", age: 25}
    temp user2data, _ = json.encode(user2)
    db.set(store, "user:2", user2data)
    
    // ==================== db.get ====================
    println("  -- Getting --")

    // Test 1: getting value for existing key
    temp data, found = db.get(store, "user:1")
		if found {
				temp user, _ = json.decode(data, User)
        if user.name == "Alice" && user.age == 30 {
            println("   [PASS] db.get(database, string)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.get(database, string): stored incorrect value in database")
            failed += 1
        }
		} otherwise {
        println("   [FAIL] db.get(database, string): value not stored in database")
        failed += 1
    }

    // Test 2: getting value for non-existent key
    data, found = db.get(store, "user:3")
    if found {
        println("   [FAIL] db.get(database, string): expected `false`, got `true`")
        failed += 1
    } otherwise {
        println("   [PASS] db.get(database, string)")
        passed += 1
    }
    
    // ==================== db.has ====================
    println("  -- db.has --")

    // Test 1: checking for existing key
    if db.has (store, "user:2") {
        println("   [PASS] db.has(database, string)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.has(database, string): expected `true`, got `false`")
        failed += 1
    }

    // Test 2: checking for non-existent key
    if !db.has (store, "user:3") {
        println("   [PASS] db.has(database, string)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.has(database, string): expected `false`, got `true`")
        failed += 1
    }

    // ==================== db.keys ====================
    println("  -- db.keys --")

    // Test 1: Lising present keys
    temp expected_all_keys [string] = {"config:theme", "user:1", "user:2"}

		temp keys [string] = db.keys(store)

    temp unknown_key bool = false
    for i in range(0, len(keys)) {
        if keys[i] != expected_all_keys[i] {
            unknown_key = true
        }
    }

    if unknown_key {
        println("   [FAIL] db.keys(database): unknown key found in database")
        failed += 1
    } otherwise {
        println("   [PASS] db.keys(database)")
        passed += 1
    }
    
    // ==================== db.prefix ====================
    println("  -- db.prefix --")
    
    // Test 1: Listing keys with prefix
    temp expected_prefix_keys [string] = {"user:1", "user:2"}

    temp users [string] = db.prefix(store, "user:")

    temp unknown_prefix_key bool = false
    for i in range(0, len(users)) {
        if users[i] != expected_prefix_keys[i] {
            unknown_prefix_key = true
        }
    }

    if unknown_prefix_key {
        println("   [FAIL] db.prefix(database,string): unknown key found in database")
        failed += 1
    } otherwise {
        println("   [PASS] db.prefix(database,string)")
        passed += 1
    }

    // ==================== db.count ====================
    println("  -- db.count --")
    
    // Test 1: Count of all keys
    if db.count(store) == 3 {
        println("   [PASS] db.count(database)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.count(database): incorrect count of keys in database")
        failed += 1
    }

    // ==================== db.delete ====================
    println("  -- db.delete --")

    // Test 1: Delete existing key
    if db.delete(store, "config:theme") {
        println("   [PASS] db.delete(database, string)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.delete(database, string): could not delete existing key")
        failed += 1
    }

    // Test 2: Delete non-existent key
    if !db.delete(store, "config:time") {
        println("   [PASS] db.delete(database, string)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.delete(database, string): deleted non-existent key")
        failed += 1
    }
    
    // ==================== db.save ====================
    println("  -- db.save --")
    
    // Test 1: Manual save to disk
		temp save_err error = db.save(store)
    if save_err == nil {
        println("   [PASS] db.save(database)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.save(database): unexpected error while saving to disk")
        println("Failed: ${save_err.message}")
        failed += 1
    }
    
    // ==================== db.exists ====================
    println("  -- db.exists --")

    // Test 1: Check non-existent file
    if !db.exists("nonexistent_db_12345.ezdb") {
        println("   [PASS] db.exists(string) returns false for missing file")
        passed += 1
    } otherwise {
        println("   [FAIL] db.exists(string): should return false for missing file")
        failed += 1
    }

    // Test 2: Check existing file (mydb.ezdb was created earlier)
    if db.exists("mydb.ezdb") {
        println("   [PASS] db.exists(string) returns true for existing file")
        passed += 1
    } otherwise {
        println("   [FAIL] db.exists(string): should return true for existing file")
        failed += 1
    }

    // ==================== db.update_key_name ====================
    println("  -- db.update_key_name --")

    // Reopen the store for rename tests
    temp rename_store Database, rename_err error = db.open("rename_test.ezdb")
    if rename_err != nil {
        println("   [FAIL] db.update_key_name: could not open test database")
        failed += 1
    } otherwise {
        db.set(rename_store, "original_key", "test_value")

        // Test 1: Rename existing key
        if db.update_key_name(rename_store, "original_key", "renamed_key") {
            println("   [PASS] db.update_key_name() returns true")
            passed += 1
        } otherwise {
            println("   [FAIL] db.update_key_name(): should return true for existing key")
            failed += 1
        }

        // Test 2: Old key should not exist
        if !db.has(rename_store, "original_key") {
            println("   [PASS] db.update_key_name() old key removed")
            passed += 1
        } otherwise {
            println("   [FAIL] db.update_key_name(): old key should be removed")
            failed += 1
        }

        // Test 3: New key should have the value
        temp rename_val, rename_found = db.get(rename_store, "renamed_key")
        if rename_found && rename_val == "test_value" {
            println("   [PASS] db.update_key_name() new key has value")
            passed += 1
        } otherwise {
            println("   [FAIL] db.update_key_name(): new key should have the value")
            failed += 1
        }

        // Test 4: Rename non-existent key returns false
        if !db.update_key_name(rename_store, "missing_key", "whatever") {
            println("   [PASS] db.update_key_name() returns false for missing key")
            passed += 1
        } otherwise {
            println("   [FAIL] db.update_key_name(): should return false for missing key")
            failed += 1
        }

        db.close(rename_store)
    }

    // ==================== db.sort ====================
    println("  -- db.sort --")

    // Create a fresh database for sort tests
    temp sort_store Database, sort_err error = db.open("sort_test.ezdb")
    if sort_err != nil {
        println("   [FAIL] db.sort: could not open test database")
        failed += 1
    } otherwise {
        // Add keys in non-alphabetical order
        db.set(sort_store, "zebra", "short")
        db.set(sort_store, "apple", "a")
        db.set(sort_store, "10", "ten")
        db.set(sort_store, "2", "two")
        db.set(sort_store, "banana", "medium val")

        // Test db.ALPHA - keys A-Z
        db.sort(sort_store, db.ALPHA)
        temp alpha_keys [string] = db.keys(sort_store)
        if alpha_keys[0] == "10" && alpha_keys[1] == "2" && alpha_keys[2] == "apple" {
            println("   [PASS] db.sort(db.ALPHA)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.ALPHA): incorrect order")
            failed += 1
        }

        // Test db.ALPHA_DESC - keys Z-A
        db.sort(sort_store, db.ALPHA_DESC)
        temp alpha_desc_keys [string] = db.keys(sort_store)
        if alpha_desc_keys[0] == "zebra" && alpha_desc_keys[1] == "banana" {
            println("   [PASS] db.sort(db.ALPHA_DESC)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.ALPHA_DESC): incorrect order")
            failed += 1
        }

        // Test db.VALUE_ALPHA - values A-Z
        db.sort(sort_store, db.VALUE_ALPHA)
        temp val_alpha_keys [string] = db.keys(sort_store)
        // values: "a" < "medium val" < "short" < "ten" < "two"
        // keys:   apple, banana, zebra, 10, 2
        if val_alpha_keys[0] == "apple" && val_alpha_keys[1] == "banana" && val_alpha_keys[4] == "2" {
            println("   [PASS] db.sort(db.VALUE_ALPHA)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.VALUE_ALPHA): incorrect order")
            failed += 1
        }

        // Test db.KEY_LEN - shortest keys first
        db.sort(sort_store, db.KEY_LEN)
        temp key_len_keys [string] = db.keys(sort_store)
        // "2" (1), "10" (2), "apple" (5), "zebra" (5), "banana" (6)
        if key_len_keys[0] == "2" && key_len_keys[1] == "10" {
            println("   [PASS] db.sort(db.KEY_LEN)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.KEY_LEN): incorrect order")
            failed += 1
        }

        // Test db.VALUE_LEN - shortest values first
        db.sort(sort_store, db.VALUE_LEN)
        temp val_len_keys [string] = db.keys(sort_store)
        // value lengths: "a"(1), "ten"(3), "two"(3), "short"(5), "medium val"(10)
        // keys:          apple,  10,       2,        zebra,      banana
        if val_len_keys[0] == "apple" && val_len_keys[4] == "banana" {
            println("   [PASS] db.sort(db.VALUE_LEN)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.VALUE_LEN): incorrect order")
            failed += 1
        }

        // Test db.NUMERIC - numeric keys first, ascending
        db.sort(sort_store, db.NUMERIC)
        temp numeric_keys [string] = db.keys(sort_store)
        // 2, 10, then alpha: apple, banana, zebra
        if numeric_keys[0] == "2" && numeric_keys[1] == "10" && numeric_keys[2] == "apple" {
            println("   [PASS] db.sort(db.NUMERIC)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.NUMERIC): incorrect order")
            failed += 1
        }

        // Test db.NUMERIC_DESC - numeric keys descending
        db.sort(sort_store, db.NUMERIC_DESC)
        temp numeric_desc_keys [string] = db.keys(sort_store)
        // zebra, banana, apple, 10, 2 (alpha desc for non-numeric, then numeric desc)
        if numeric_desc_keys[len(numeric_desc_keys)-1] == "2" && numeric_desc_keys[len(numeric_desc_keys)-2] == "10" {
            println("   [PASS] db.sort(db.NUMERIC_DESC)")
            passed += 1
        } otherwise {
            println("   [FAIL] db.sort(db.NUMERIC_DESC): incorrect order")
            failed += 1
        }

        db.close(sort_store)
    }

    // ==================== db.close ====================
    println("  -- db.close --")

    temp close_err error = db.close(store)
    if close_err == nil {
        println("   [PASS] db.close(database)")
        passed += 1
    } otherwise {
        println("   [FAIL] db.close(database): unexpected error while closing database")
        failed += 1
    }


    // ==================== Summary ====================
    println("")
    println("=== Summary ===")
    println("  Passed: ${passed}")
    println("  Failed: ${failed}")
    println("")

    if failed > 0 {
        println("SOME TESTS FAILED")
    } otherwise {
        println("ALL TESTS PASSED")
    }
}
