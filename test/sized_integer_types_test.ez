/*
 * EZ Language - Sized Integer Type Checking Tests
 *
 * This file tests the sized integer type system to ensure:
 * - typeof() returns the declared type (u64, i32, etc.) instead of generic "int"
 * - Signed/unsigned integer family compatibility is enforced
 * - Negative values cannot be assigned to unsigned types
 * - Integer types within the same family are compatible
 *
 * Integer Type Families:
 * - Signed: i8, i16, i32, i64, i128, i256, int
 * - Unsigned: u8, u16, u32, u64, u128, u256, uint
 *
 * Compatibility Rules:
 * - Within same family: OK (i8 -> i64, u8 -> u64)
 * - Unsigned -> Signed: OK (unsigned is never negative)
 * - Signed -> Unsigned: ERROR (signed could be negative)
 * - Negative literal -> Unsigned: ERROR
 */

import @std

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

do main() {
    using std

    println("============================================")
    println("  EZ Language - Sized Integer Type Tests   ")
    println("============================================")
    println("")

    // Run all test categories
    test_typeof_returns_declared_type()
    test_signed_integer_family()
    test_unsigned_integer_family()
    test_unsigned_to_signed_compatibility()
    test_positive_literal_compatibility()
    test_default_values_with_declared_type()
    test_large_integer_types()

    println("")
    println("============================================")
    println("  All Sized Integer Tests Passed!          ")
    println("============================================")
}

// ============================================================================
// TEST: typeof() Returns Declared Type
// ============================================================================

do test_typeof_returns_declared_type() {
    using std
    println("-> Testing typeof() returns declared type...")

    // Test signed integer types
    temp i8_var i8 = 1
    temp i16_var i16 = 1
    temp i32_var i32 = 1
    temp i64_var i64 = 1
    temp int_var int = 1

    // Test unsigned integer types
    temp u8_var u8 = 1
    temp u16_var u16 = 1
    temp u32_var u32 = 1
    temp u64_var u64 = 1
    temp uint_var uint = 1

    // Verify typeof() returns the declared type
    println("  i8 type: ${typeof(i8_var)}")
    println("  i16 type: ${typeof(i16_var)}")
    println("  i32 type: ${typeof(i32_var)}")
    println("  i64 type: ${typeof(i64_var)}")
    println("  int type: ${typeof(int_var)}")

    println("  u8 type: ${typeof(u8_var)}")
    println("  u16 type: ${typeof(u16_var)}")
    println("  u32 type: ${typeof(u32_var)}")
    println("  u64 type: ${typeof(u64_var)}")
    println("  uint type: ${typeof(uint_var)}")

    println("  [OK] typeof() returns declared type")
}

// ============================================================================
// TEST: Signed Integer Family Compatibility
// ============================================================================

do test_signed_integer_family() {
    using std
    println("-> Testing signed integer family compatibility...")

    // All signed integers should be compatible with each other
    temp i8_val i8 = -5
    temp i16_val i16 = -100
    temp i32_val i32 = -10000
    temp i64_val i64 = -1000000
    temp int_val int = -42

    // Test function returns with signed family
    temp result1 i64 = return_i8_as_signed()
    temp result2 i64 = return_i16_as_signed()
    temp result3 i64 = return_i32_as_signed()

    println("  i8 -> i64: ${result1}")
    println("  i16 -> i64: ${result2}")
    println("  i32 -> i64: ${result3}")

    println("  [OK] Signed family compatibility works")
}

// ============================================================================
// TEST: Unsigned Integer Family Compatibility
// ============================================================================

do test_unsigned_integer_family() {
    using std
    println("-> Testing unsigned integer family compatibility...")

    // All unsigned integers should be compatible with each other
    temp u8_val u8 = 5
    temp u16_val u16 = 100
    temp u32_val u32 = 10000
    temp u64_val u64 = 1000000
    temp uint_val uint = 42

    // Test function returns with unsigned family
    temp result1 u64 = return_u8_as_unsigned()
    temp result2 u64 = return_u16_as_unsigned()
    temp result3 u64 = return_u32_as_unsigned()

    println("  u8 -> u64: ${result1}")
    println("  u16 -> u64: ${result2}")
    println("  u32 -> u64: ${result3}")

    println("  [OK] Unsigned family compatibility works")
}

// ============================================================================
// TEST: Unsigned to Signed Compatibility (Safe Direction)
// ============================================================================

do test_unsigned_to_signed_compatibility() {
    using std
    println("-> Testing unsigned to signed compatibility (safe)...")

    // Unsigned values can always be safely assigned to signed types
    // (unsigned is never negative, so always valid for signed)
    temp u8_val u8 = 100
    temp u16_val u16 = 1000
    temp u32_val u32 = 10000

    // Test returning unsigned where signed is expected
    temp signed_result i64 = return_unsigned_to_signed()

    println("  u32 -> i64: ${signed_result}")

    println("  [OK] Unsigned to signed compatibility works")
}

// ============================================================================
// TEST: Positive Literal Compatibility
// ============================================================================

do test_positive_literal_compatibility() {
    using std
    println("-> Testing positive literal compatibility...")

    // Positive literals should work with both signed and unsigned
    temp signed_val i32 = 42
    temp unsigned_val u32 = 42

    // Test function returning positive literal to unsigned
    temp result u64 = return_positive_literal()

    println("  Positive literal to u64: ${result}")

    println("  [OK] Positive literal compatibility works")
}

// ============================================================================
// TEST: Default Values with Declared Type
// ============================================================================

do test_default_values_with_declared_type() {
    using std
    println("-> Testing default values preserve declared type...")

    // Variables declared without value should get correct type
    temp default_i8 i8
    temp default_i16 i16
    temp default_i32 i32
    temp default_i64 i64

    temp default_u8 u8
    temp default_u16 u16
    temp default_u32 u32
    temp default_u64 u64

    // Verify typeof returns correct type
    println("  default i8 type: ${typeof(default_i8)}, value: ${default_i8}")
    println("  default i16 type: ${typeof(default_i16)}, value: ${default_i16}")
    println("  default i32 type: ${typeof(default_i32)}, value: ${default_i32}")
    println("  default i64 type: ${typeof(default_i64)}, value: ${default_i64}")

    println("  default u8 type: ${typeof(default_u8)}, value: ${default_u8}")
    println("  default u16 type: ${typeof(default_u16)}, value: ${default_u16}")
    println("  default u32 type: ${typeof(default_u32)}, value: ${default_u32}")
    println("  default u64 type: ${typeof(default_u64)}, value: ${default_u64}")

    println("  [OK] Default values preserve declared type")
}

// ============================================================================
// TEST: Large Integer Types (i128, i256, u128, u256)
// ============================================================================

do test_large_integer_types() {
    using std
    println("-> Testing large integer types (i128, i256, u128, u256)...")

    // Test large signed types
    temp i128_val i128 = 1000000000
    temp i256_val i256 = 1000000000

    // Test large unsigned types
    temp u128_val u128 = 1000000000
    temp u256_val u256 = 1000000000

    println("  i128 type: ${typeof(i128_val)}, value: ${i128_val}")
    println("  i256 type: ${typeof(i256_val)}, value: ${i256_val}")
    println("  u128 type: ${typeof(u128_val)}, value: ${u128_val}")
    println("  u256 type: ${typeof(u256_val)}, value: ${u256_val}")

    // Test large type family compatibility
    temp large_result i256 = return_i128_as_large_signed()

    println("  i128 -> i256: ${large_result}")

    println("  [OK] Large integer types work correctly")
}

// ============================================================================
// HELPER FUNCTIONS - Signed Family
// ============================================================================

do return_i8_as_signed() -> i64 {
    temp x i8 = -10
    return x
}

do return_i16_as_signed() -> i64 {
    temp x i16 = -1000
    return x
}

do return_i32_as_signed() -> i64 {
    temp x i32 = -100000
    return x
}

// ============================================================================
// HELPER FUNCTIONS - Unsigned Family
// ============================================================================

do return_u8_as_unsigned() -> u64 {
    temp x u8 = 10
    return x
}

do return_u16_as_unsigned() -> u64 {
    temp x u16 = 1000
    return x
}

do return_u32_as_unsigned() -> u64 {
    temp x u32 = 100000
    return x
}

// ============================================================================
// HELPER FUNCTIONS - Cross-Family
// ============================================================================

do return_unsigned_to_signed() -> i64 {
    temp x u32 = 50000
    return x
}

do return_positive_literal() -> u64 {
    return 42
}

do return_i128_as_large_signed() -> i256 {
    temp x i128 = 999999999
    return x
}
