/*
 * comprehensive.ez - Single-file comprehensive test
 *
 * This file tests ALL EZ language features in a single file:
 *   - Variable declarations (var, const, temp)
 *   - All primitive types (int, float, string, bool, char)
 *   - Complex types (arrays, maps, structs, enums)
 *   - Control flow (if/or/otherwise, for, while, for_each, range)
 *   - All operators (arithmetic, comparison, logical, assignment)
 *   - Functions (parameters, returns, multiple returns)
 *   - Mutable parameters (&) for pass-by-reference
 *   - Standard library (@std, @math, @arrays, @strings, @maps, @time)
 *   - String interpolation
 *   - Comments (single-line and multi-line)
 */

// ==================================================
// IMPORTS
// ==================================================

import @std, @math, @arrays, @strings, @maps, @time, @io, @os

using std

// ==================================================
// ENUMS
// ==================================================

/* Basic int enum (auto-incremented) */
const Direction enum {
    NORTH
    EAST
    SOUTH
    WEST
}

/* Int enum with skip attribute */
@(int, skip, 10)
const Priority enum {
    LOW       // 0
    MEDIUM    // 10
    HIGH      // 20
    CRITICAL  // 30
}

/* String enum with explicit values */
const Status enum {
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    DONE = "done"
}

// ==================================================
// STRUCTS
// ==================================================

const Point struct {
    x int
    y int
}

const Person struct {
    name string
    age int
    active bool
}

const Task struct {
    id int
    title string
    priority int
    status string
    tags [string]
}

/* Test result tracking */
const TestResult struct {
    passed int
    failed int
}

// ==================================================
// MAIN ENTRY POINT
// ==================================================

do main() {
    println("========================================")
    println("  EZ Comprehensive Language Test")
    println("========================================")
    println("")

    temp total_passed int = 0
    temp total_failed int = 0
    temp result TestResult = TestResult{passed: 0, failed: 0}

    result = test_variables()
    total_passed += result.passed
    total_failed += result.failed

    result = test_primitives()
    total_passed += result.passed
    total_failed += result.failed

    result = test_operators()
    total_passed += result.passed
    total_failed += result.failed

    result = test_control_flow()
    total_passed += result.passed
    total_failed += result.failed

    result = test_optional_parens()
    total_passed += result.passed
    total_failed += result.failed

    result = test_arrays()
    total_passed += result.passed
    total_failed += result.failed

    result = test_matrices()
    total_passed += result.passed
    total_failed += result.failed

    result = test_maps()
    total_passed += result.passed
    total_failed += result.failed

    result = test_structs()
    total_passed += result.passed
    total_failed += result.failed

    result = test_enums()
    total_passed += result.passed
    total_failed += result.failed

    result = test_functions()
    total_passed += result.passed
    total_failed += result.failed

    result = test_mutable_params()
    total_passed += result.passed
    total_failed += result.failed

    result = test_copy()
    total_passed += result.passed
    total_failed += result.failed

    result = test_char_conversion()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_math()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_strings()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_arrays()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_maps()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_time()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_io()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_os()
    total_passed += result.passed
    total_failed += result.failed

    result = test_printf_and_escapes()
    total_passed += result.passed
    total_failed += result.failed

    temp total int = total_passed + total_failed

    println("")
    println("========================================")
    println("  All Tests Complete!")
    println("========================================")
    println("")
    println("  Total:  ${total}")
    println("  Passed: ${total_passed}")
    println("  Failed: ${total_failed}")
    println("")
    if total_failed == 0 {
        println("  Status: ALL TESTS PASSED!")
    } otherwise {
        println("  Status: SOME TESTS FAILED")
    }
    println("========================================")
}

// ==================================================
// VARIABLE DECLARATIONS
// ==================================================

do test_variables() -> TestResult {
    print_section("Variable Declarations")
    temp passed int = 0
    temp failed int = 0

    // temp - mutable variable
    temp counter int = 0
    counter = 1
    println("  temp counter = ${counter}")
    passed += 1

    // const - immutable constant
    const PI float = 3.14159
    println("  const PI = ${PI}")
    passed += 1

    // temp with reassignment
    temp local_val int = 42
    local_val = 43
    println("  temp local_val (reassigned) = ${local_val}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// PRIMITIVE TYPES
// ==================================================

do test_primitives() -> TestResult {
    print_section("Primitive Types")
    temp passed int = 0
    temp failed int = 0

    // int
    temp i int = 42
    temp negative_i int = -10
    temp underscore_num int = 1_000_000
    println("  int: ${i}, ${negative_i}, ${underscore_num}")
    passed += 1

    // float
    temp f float = 3.14159
    temp negative_f float = -2.5
    println("  float: ${f}, ${negative_f}")
    passed += 1

    // string
    temp s string = "Hello, World!"
    temp empty_s string = ""
    temp escaped string = "Line1\nLine2\tTabbed"
    println("  string: ${s}")
    println("  empty string length: ${len(empty_s)}")
    passed += 1

    // bool
    temp b_true bool = true
    temp b_false bool = false
    println("  bool: ${b_true}, ${b_false}")
    passed += 1

    // char
    temp c char = 'A'
    temp newline char = '\n'
    println("  char: ${c}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// OPERATORS
// ==================================================

do test_operators() -> TestResult {
    print_section("Operators")
    temp passed int = 0
    temp failed int = 0

    // Arithmetic
    temp a int = 10
    temp b int = 3
    println("  10 + 3 = ${a + b}")
    println("  10 - 3 = ${a - b}")
    println("  10 * 3 = ${a * b}")
    println("  10 / 3 = ${a / b}")
    println("  10 % 3 = ${a % b}")
    passed += 1

    // Float arithmetic
    temp x float = 10.0
    temp y float = 3.0
    println("  10.0 / 3.0 = ${x / y}")
    passed += 1

    // Comparison
    println("  10 == 3: ${a == b}")
    println("  10 != 3: ${a != b}")
    println("  10 < 3: ${a < b}")
    println("  10 > 3: ${a > b}")
    println("  10 <= 3: ${a <= b}")
    println("  10 >= 3: ${a >= b}")
    passed += 1

    // Logical
    temp t bool = true
    temp f bool = false
    println("  true && false: ${t && f}")
    println("  true || false: ${t || f}")
    println("  !true: ${!t}")
    passed += 1

    // Assignment operators
    temp num int = 10
    num += 5
    println("  10 += 5 = ${num}")
    num -= 3
    println("  15 -= 3 = ${num}")
    num *= 2
    println("  12 *= 2 = ${num}")
    num /= 4
    println("  24 /= 4 = ${num}")
    passed += 1

    // Increment/decrement
    temp counter int = 0
    counter++
    println("  0++ = ${counter}")
    counter--
    println("  1-- = ${counter}")
    passed += 1

    // String concatenation
    temp str1 string = "Hello"
    temp str2 string = "World"
    temp concat string = str1 + " " + str2
    println("  \"Hello\" + \" \" + \"World\" = ${concat}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// CONTROL FLOW
// ==================================================

do test_control_flow() -> TestResult {
    print_section("Control Flow")
    temp passed int = 0
    temp failed int = 0

    // if / or / otherwise
    temp val int = 15
    println("  if/or/otherwise with val=15:")
    if val < 10 {
        println("    val < 10")
    } or val < 20 {
        println("    val >= 10 and < 20")
    } otherwise {
        println("    val >= 20")
    }
    passed += 1

    // for loop with range
    println("  for i in range(0, 5):")
    temp sum int = 0
    for i in range(0, 5) {
        sum += i
    }
    println("    sum = ${sum}")
    passed += 1

    // for loop descending
    println("  for i in range(5, 0) (descending):")
    temp desc_list string = ""
    for i in range(5, 0) {
        desc_list = "${desc_list}${i} "
    }
    println("    ${desc_list}")
    passed += 1

    // as_long_as loop (EZ's while equivalent)
    println("  as_long_as loop:")
    temp w int = 0
    as_long_as w < 3 {
        w += 1
    }
    println("    counted to ${w}")
    passed += 1

    // for_each loop
    println("  for_each in array:")
    temp items [string] = {"apple", "banana", "cherry"}
    for_each item in items {
        println("    - ${item}")
    }
    passed += 1

    // break and continue
    println("  break test (stop at 3):")
    temp break_sum int = 0
    for i in range(0, 10) {
        if i == 3 {
            break
        }
        break_sum += i
    }
    println("    sum before break = ${break_sum}")
    passed += 1

    println("  continue test (skip 2):")
    temp cont_sum int = 0
    for i in range(0, 5) {
        if i == 2 {
            continue
        }
        cont_sum += i
    }
    println("    sum with skip = ${cont_sum}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// OPTIONAL PARENTHESES IN CONTROL FLOW
// ==================================================

do test_optional_parens() -> TestResult {
    print_section("Optional Parentheses")
    temp passed int = 0
    temp failed int = 0

    // ========== FOR LOOPS ==========

    // for loop WITHOUT parentheses (original syntax)
    println("  for without parens:")
    temp sum1 int = 0
    for i in range(0, 5) {
        sum1 += i
    }
    println("    sum = ${sum1}")
    if sum1 == 10 {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 10")
    }

    // for loop WITH parentheses (new syntax)
    println("  for with parens:")
    temp sum2 int = 0
    for (i in range(0, 5)) {
        sum2 += i
    }
    println("    sum = ${sum2}")
    if sum2 == 10 {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 10")
    }

    // for loop with type annotation WITHOUT parens
    println("  for with type, no parens:")
    temp sum3 int = 0
    for i int in range(0, 3) {
        sum3 += i
    }
    println("    sum = ${sum3}")
    if sum3 == 3 {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 3")
    }

    // for loop with type annotation WITH parens
    println("  for with type and parens:")
    temp sum4 int = 0
    for (i int in range(0, 3)) {
        sum4 += i
    }
    println("    sum = ${sum4}")
    if sum4 == 3 {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 3")
    }

    // for loop with descending range WITH parens
    println("  for descending with parens:")
    temp desc_list string = ""
    for (i in range(3, 0)) {
        desc_list = "${desc_list}${i}"
    }
    println("    result = ${desc_list}")
    if desc_list == "321" {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected '321'")
    }

    // ========== FOR_EACH LOOPS ==========

    // for_each WITHOUT parentheses
    println("  for_each without parens:")
    temp items [string] = {"a", "b", "c"}
    temp concat1 string = ""
    for_each item in items {
        concat1 = "${concat1}${item}"
    }
    println("    result = ${concat1}")
    if concat1 == "abc" {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 'abc'")
    }

    // for_each WITH parentheses
    println("  for_each with parens:")
    temp concat2 string = ""
    for_each (item in items) {
        concat2 = "${concat2}${item}"
    }
    println("    result = ${concat2}")
    if concat2 == "abc" {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 'abc'")
    }

    // ========== IF STATEMENTS ==========

    // if WITHOUT parentheses
    println("  if without parens:")
    temp x int = 5
    temp result1 string = ""
    if x > 3 {
        result1 = "gt3"
    }
    println("    result = ${result1}")
    if result1 == "gt3" {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 'gt3'")
    }

    // if WITH parentheses
    println("  if with parens:")
    temp result2 string = ""
    if (x > 3) {
        result2 = "gt3"
    }
    println("    result = ${result2}")
    if result2 == "gt3" {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 'gt3'")
    }

    // if/or/otherwise WITHOUT parentheses
    println("  if/or/otherwise without parens:")
    temp y int = 15
    temp result3 string = ""
    if y < 10 {
        result3 = "small"
    } or y < 20 {
        result3 = "medium"
    } otherwise {
        result3 = "large"
    }
    println("    result = ${result3}")
    if result3 == "medium" {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 'medium'")
    }

    // if/or/otherwise WITH parentheses
    println("  if/or/otherwise with parens:")
    temp result4 string = ""
    if (y < 10) {
        result4 = "small"
    } or (y < 20) {
        result4 = "medium"
    } otherwise {
        result4 = "large"
    }
    println("    result = ${result4}")
    if result4 == "medium" {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 'medium'")
    }

    // Mixed parens in if/or chain
    println("  if/or mixed parens:")
    temp result5 string = ""
    if y < 10 {
        result5 = "small"
    } or (y < 20) {
        result5 = "medium"
    } otherwise {
        result5 = "large"
    }
    println("    result = ${result5}")
    if result5 == "medium" {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 'medium'")
    }

    // ========== AS_LONG_AS (WHILE) ==========

    // as_long_as WITHOUT parentheses
    println("  as_long_as without parens:")
    temp count1 int = 0
    as_long_as count1 < 3 {
        count1 += 1
    }
    println("    count = ${count1}")
    if count1 == 3 {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 3")
    }

    // as_long_as WITH parentheses
    println("  as_long_as with parens:")
    temp count2 int = 0
    as_long_as (count2 < 3) {
        count2 += 1
    }
    println("    count = ${count2}")
    if count2 == 3 {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 3")
    }

    // ========== NESTED CONTROL FLOW WITH PARENS ==========

    // Nested for loops with parens
    println("  nested for loops with parens:")
    temp nested_sum int = 0
    for (i in range(0, 3)) {
        for (j in range(0, 2)) {
            nested_sum += 1
        }
    }
    println("    sum = ${nested_sum}")
    if nested_sum == 6 {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 6")
    }

    // for with if inside, both with parens
    println("  for with if inside (both parens):")
    temp even_sum int = 0
    for (i in range(0, 6)) {
        if (i % 2 == 0) {
            even_sum += i
        }
    }
    println("    even sum = ${even_sum}")
    if even_sum == 6 {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 6 (0+2+4)")
    }

    // as_long_as with break inside, both with parens
    println("  as_long_as with break (both parens):")
    temp break_count int = 0
    as_long_as (break_count < 100) {
        if (break_count == 5) {
            break
        }
        break_count += 1
    }
    println("    count at break = ${break_count}")
    if break_count == 5 {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 5")
    }

    // for_each with continue, both with parens
    println("  for_each with continue (both parens):")
    temp nums [int] = {1, 2, 3, 4, 5}
    temp skip_sum int = 0
    for_each (n in nums) {
        if (n == 3) {
            continue
        }
        skip_sum += n
    }
    println("    sum without 3 = ${skip_sum}")
    if skip_sum == 12 {
        passed += 1
    } otherwise {
        failed += 1
        println("    FAIL: expected 12 (1+2+4+5)")
    }

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// ARRAYS
// ==================================================

do test_arrays() -> TestResult {
    print_section("Arrays")
    temp passed int = 0
    temp failed int = 0

    // Array literal
    temp nums [int] = {1, 2, 3, 4, 5}
    println("  int array: ${nums}")
    println("  length: ${len(nums)}")
    println("  first: ${nums[0]}, last: ${nums[4]}")
    passed += 1

    // Empty array
    temp empty [int] = {}
    println("  empty array length: ${len(empty)}")
    passed += 1

    // String array
    temp words [string] = {"hello", "world"}
    println("  string array: ${words}")
    passed += 1

    // Array indexing and modification
    temp mutable [int] = {10, 20, 30}
    mutable[1] = 25
    println("  after mutable[1] = 25: ${mutable}")
    passed += 1

    // Fixed size array
    const fixed [int, 3] = {100, 200, 300}
    println("  fixed size array: ${fixed}")
    passed += 1

    // Fixed size array indexing returns correct element type (bug #267 fix)
    temp fixed_mutable [int, 3] = {10, 20, 30}
    temp elem int = fixed_mutable[0]
    temp sum int = fixed_mutable[0] + fixed_mutable[1] + fixed_mutable[2]
    if elem == 10 && sum == 60 {
        println("  fixed size array indexing: elem=${elem}, sum=${sum}")
        passed += 1
    } otherwise {
        println("  FAILED: fixed size array indexing")
        failed += 1
    }

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// MATRICES (2D Arrays)
// ==================================================

do test_matrices() -> TestResult {
    print_section("Matrices (2D Arrays)")
    temp passed int = 0
    temp failed int = 0

    // 2D int array declaration
    temp int_matrix [[int]] = {{1, 2, 3}, {4, 5, 6}}
    println("  [[int]] matrix: ${int_matrix}")
    println("  int_matrix[0]: ${int_matrix[0]}")
    println("  int_matrix[1][2]: ${int_matrix[1][2]}")
    passed += 1

    // 2D string array
    temp str_matrix [[string]] = {{"a", "b"}, {"c", "d"}}
    println("  [[string]] matrix: ${str_matrix}")
    println("  str_matrix[1][0]: ${str_matrix[1][0]}")
    passed += 1

    // Empty 2D array
    temp empty_matrix [[int]] = {}
    println("  empty matrix length: ${len(empty_matrix)}")
    passed += 1

    // Matrix from arrays.zip
    temp zipped [[int]] = arrays.zip({1, 2}, {3, 4})
    println("  arrays.zip result: ${zipped}")
    println("  zipped[0][1]: ${zipped[0][1]}")
    passed += 1

    // Matrix from arrays.chunk
    temp chunked [[int]] = arrays.chunk({1, 2, 3, 4, 5, 6}, 2)
    println("  arrays.chunk result: ${chunked}")
    println("  chunked[1][0]: ${chunked[1][0]}")
    passed += 1

    // Flatten matrix back to 1D
    temp nested [[int]] = {{10, 20}, {30, 40}}
    temp flattened [int] = arrays.flatten(nested)
    println("  arrays.flatten({{10,20},{30,40}}): ${flattened}")
    passed += 1

    // Iterate over matrix rows
    temp rows [[int]] = {{1, 2}, {3, 4}, {5, 6}}
    temp row_sum int = 0
    for_each row in rows {
        for_each val in row {
            row_sum += val
        }
    }
    println("  sum of all elements in matrix: ${row_sum}")
    passed += 1

    // 3D array (nested matrices)
    temp cube [[[int]]] = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}
    println("  [[[int]]] 3D array: ${cube}")
    println("  cube[1][0][1]: ${cube[1][0][1]}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// MAPS
// ==================================================

do test_maps() -> TestResult {
    print_section("Maps")
    temp passed int = 0
    temp failed int = 0

    // Map literal
    temp ages map[string:int] = {
        "alice": 30,
        "bob": 25,
        "charlie": 35
    }
    println("  map: ${ages}")
    temp alice_age int = ages["alice"]
    println("  ages[\"alice\"] = ${alice_age}")
    passed += 1

    // Map modification
    ages["david"] = 28
    println("  after adding david: ${ages}")
    passed += 1

    // Map with int keys
    temp lookup map[int:string] = {
        1: "one",
        2: "two",
        3: "three"
    }
    println("  int-keyed map: ${lookup}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STRUCTS
// ==================================================

do test_structs() -> TestResult {
    print_section("Structs")
    temp passed int = 0
    temp failed int = 0

    // Struct instantiation
    temp p Point = Point{x: 10, y: 20}
    println("  Point: x=${p.x}, y=${p.y}")
    passed += 1

    // Field modification (temp struct is mutable)
    p.x = 15
    if p.x == 15 {
        println("  After p.x = 15: x=${p.x} (temp struct field modification works)")
        passed += 1
    } otherwise {
        println("  FAILED: temp struct field modification")
        failed += 1
    }

    // Struct with different types
    temp person Person = Person{
        name: "Alice",
        age: 30,
        active: true
    }
    println("  Person: ${person.name}, age ${person.age}, active=${person.active}")
    passed += 1

    // Struct with array field
    temp task Task = Task{
        id: 1,
        title: "Test Task",
        priority: 20,
        status: "todo",
        tags: {"urgent", "review"}
    }
    println("  Task: #${task.id} - ${task.title}")
    println("  Tags: ${task.tags}")
    passed += 1

    // Array of structs
    temp points [Point] = {}
    arrays.append(points, Point{x: 0, y: 0})
    arrays.append(points, Point{x: 1, y: 1})
    println("  Array of Points: ${points}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// ENUMS
// ==================================================

do test_enums() -> TestResult {
    print_section("Enums")
    temp passed int = 0
    temp failed int = 0

    // Basic enum access
    println("  Direction.NORTH = ${Direction.NORTH}")
    println("  Direction.SOUTH = ${Direction.SOUTH}")
    passed += 1

    // Enum with skip
    println("  Priority.LOW = ${Priority.LOW}")
    println("  Priority.MEDIUM = ${Priority.MEDIUM}")
    println("  Priority.HIGH = ${Priority.HIGH}")
    println("  Priority.CRITICAL = ${Priority.CRITICAL}")
    passed += 1

    // String enum
    println("  Status.TODO = ${Status.TODO}")
    println("  Status.IN_PROGRESS = ${Status.IN_PROGRESS}")
    println("  Status.DONE = ${Status.DONE}")
    passed += 1

    // Enum in variable
    temp current_priority int = Priority.HIGH
    println("  current_priority = ${current_priority}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// FUNCTIONS
// ==================================================

do test_functions() -> TestResult {
    print_section("Functions")
    temp passed int = 0
    temp failed int = 0

    // Function with no params, no return
    println("  Calling greet():")
    greet()
    passed += 1

    // Function with params
    println("  add(5, 3) = ${add(5, 3)}")
    passed += 1

    // Function with multiple params and return
    temp rect_area int = rectangle_area(4, 5)
    println("  rectangle_area(4, 5) = ${rect_area}")
    passed += 1

    // Function returning struct
    temp origin Point = make_point(0, 0)
    println("  make_point(0, 0) = (${origin.x}, ${origin.y})")
    passed += 1

    // Function with array param
    temp numbers [int] = {1, 2, 3, 4, 5}
    temp total int = sum_array(numbers)
    println("  sum_array({1,2,3,4,5}) = ${total}")
    passed += 1

    // Recursive function
    temp fact int = factorial(5)
    println("  factorial(5) = ${fact}")
    passed += 1

    // Function returning array
    temp doubled [int] = double_array({1, 2, 3})
    println("  double_array({1,2,3}) = ${doubled}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

do greet() {
    println("    Hello from greet()!")
}

do add(a int, b int) -> int {
    return a + b
}

do rectangle_area(width int, height int) -> int {
    return width * height
}

do make_point(x int, y int) -> Point {
    temp p Point = Point{x: x, y: y}
    return p
}

do sum_array(nums [int]) -> int {
    temp total int = 0
    for_each n in nums {
        total += n
    }
    return total
}

do factorial(n int) -> int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

do double_array(nums [int]) -> [int] {
    temp result [int] = {}
    for_each n in nums {
        arrays.append(result, n * 2)
    }
    return result
}

// ==================================================
// MUTABLE PARAMETERS (&)
// ==================================================

do test_mutable_params() -> TestResult {
    print_section("Mutable Parameters (&)")
    temp passed int = 0
    temp failed int = 0

    // Basic mutable int parameter
    temp counter int = 0
    increment(counter)
    if counter == 1 {
        println("  increment(&n int): counter = ${counter} (expected 1)")
        passed += 1
    } otherwise {
        println("  increment(&n int): FAILED - got ${counter}, expected 1")
        failed += 1
    }

    // Multiple increments
    increment(counter)
    increment(counter)
    if counter == 3 {
        println("  multiple increments: counter = ${counter} (expected 3)")
        passed += 1
    } otherwise {
        println("  multiple increments: FAILED - got ${counter}, expected 3")
        failed += 1
    }

    // Swap two values
    temp x int = 10
    temp y int = 20
    swap_values(x, y)
    if x == 20 && y == 10 {
        println("  swap(&a, &b int): x=${x}, y=${y} (expected x=20, y=10)")
        passed += 1
    } otherwise {
        println("  swap(&a, &b int): FAILED - got x=${x}, y=${y}")
        failed += 1
    }

    // Mutable float parameter
    temp f float = 0.0
    set_to_pi(f)
    if f > 3.14 && f < 3.15 {
        println("  set_to_pi(&f float): f = ${f} (expected ~3.14159)")
        passed += 1
    } otherwise {
        println("  set_to_pi(&f float): FAILED - got ${f}")
        failed += 1
    }

    // Mutable bool parameter
    temp flag bool = false
    toggle_bool(flag)
    if flag == true {
        println("  toggle_bool(&b bool): flag = ${flag} (expected true)")
        passed += 1
    } otherwise {
        println("  toggle_bool(&b bool): FAILED - got ${flag}")
        failed += 1
    }
    toggle_bool(flag)
    if flag == false {
        println("  toggle again: flag = ${flag} (expected false)")
        passed += 1
    } otherwise {
        println("  toggle again: FAILED - got ${flag}")
        failed += 1
    }

    // Mutable string parameter
    temp message string = "Hello"
    append_world(message)
    if message == "Hello, World!" {
        println("  append_world(&s string): '${message}'")
        passed += 1
    } otherwise {
        println("  append_world(&s string): FAILED - got '${message}'")
        failed += 1
    }

    // Mutable byte parameter
    temp b byte = 0x0F
    shift_byte_left(b)
    if b == 0x1E {
        println("  shift_byte_left(&b byte): b = ${b} (expected 30/0x1E)")
        passed += 1
    } otherwise {
        println("  shift_byte_left(&b byte): FAILED - got ${b}")
        failed += 1
    }

    // Mutable byte array parameter
    temp bytes [byte] = {0x01, 0x02, 0x03}
    double_bytes(bytes)
    if bytes[0] == 0x02 && bytes[1] == 0x04 && bytes[2] == 0x06 {
        println("  double_bytes(&arr [byte]): ${bytes}")
        passed += 1
    } otherwise {
        println("  double_bytes(&arr [byte]): FAILED - got ${bytes}")
        failed += 1
    }

    // Mutable struct parameter
    temp p Point = Point{x: 5, y: 10}
    double_point(p)
    if p.x == 10 && p.y == 20 {
        println("  double_point(&p Point): x=${p.x}, y=${p.y} (expected 10, 20)")
        passed += 1
    } otherwise {
        println("  double_point(&p Point): FAILED - got x=${p.x}, y=${p.y}")
        failed += 1
    }

    // Mutable array parameter
    temp nums [int] = {1, 2, 3, 4, 5}
    double_array_in_place(nums)
    if nums[0] == 2 && nums[2] == 6 && nums[4] == 10 {
        println("  double_array_in_place(&arr [int]): ${nums}")
        passed += 1
    } otherwise {
        println("  double_array_in_place(&arr [int]): FAILED - got ${nums}")
        failed += 1
    }

    // Mixed mutable and immutable parameters
    temp result int = 0
    add_to_result(result, 15)
    add_to_result(result, 25)
    if result == 40 {
        println("  add_to_result(&result, value): result = ${result} (expected 40)")
        passed += 1
    } otherwise {
        println("  add_to_result(&result, value): FAILED - got ${result}")
        failed += 1
    }

    // Multiple output pattern (quotient and remainder)
    temp q int = 0
    temp r int = 0
    divide_with_remainder(q, r, 17, 5)
    if q == 3 && r == 2 {
        println("  divide_with_remainder: 17/5 = ${q} remainder ${r}")
        passed += 1
    } otherwise {
        println("  divide_with_remainder: FAILED - got q=${q}, r=${r}")
        failed += 1
    }

    // Accumulator pattern with string
    temp greeting string = ""
    append_name(greeting, "Alice")
    append_name(greeting, "Bob")
    append_name(greeting, "Carol")
    temp expected_greeting string = "Hello, Alice! Hello, Bob! Hello, Carol! "
    if greeting == expected_greeting {
        println("  accumulator pattern: '${greeting}'")
        passed += 1
    } otherwise {
        println("  accumulator pattern: FAILED")
        println("    got:      '${greeting}'")
        println("    expected: '${expected_greeting}'")
        failed += 1
    }

    // State machine pattern (game state)
    temp game GameState = GameState{score: 0, lives: 3, level: 1}
    add_score(game, 50)
    add_score(game, 60)  // This should trigger level up (score >= level * 100)
    if game.score == 110 && game.level == 2 {
        println("  state machine: score=${game.score}, level=${game.level}")
        passed += 1
    } otherwise {
        println("  state machine: FAILED - score=${game.score}, level=${game.level}")
        failed += 1
    }

    lose_life(game)
    if game.lives == 2 {
        println("  lose_life: lives=${game.lives} (expected 2)")
        passed += 1
    } otherwise {
        println("  lose_life: FAILED - lives=${game.lives}")
        failed += 1
    }

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// Helper functions for mutable parameter tests
do increment(&n int) {
    n = n + 1
}

do swap_values(&a, &b int) {
    temp t int = a
    a = b
    b = t
}

do set_to_pi(&f float) {
    f = 3.14159
}

do toggle_bool(&b bool) {
    b = !b
}

do append_world(&s string) {
    s = s + ", World!"
}

do shift_byte_left(&b byte) {
    b = b * 2
}

do double_bytes(&arr [byte]) {
    for i in range(0, len(arr)) {
        arr[i] = arr[i] * 2
    }
}

do double_point(&p Point) {
    p.x = p.x * 2
    p.y = p.y * 2
}

do double_array_in_place(&arr [int]) {
    for i in range(0, len(arr)) {
        arr[i] = arr[i] * 2
    }
}

do add_to_result(&result int, value int) {
    result = result + value
}

do divide_with_remainder(&quotient, &remainder int, a, b int) {
    quotient = a / b
    remainder = a % b
}

do append_name(&message string, name string) {
    message = message + "Hello, " + name + "! "
}

const GameState struct {
    score int
    lives int
    level int
}

do add_score(&state GameState, points int) {
    state.score = state.score + points
    if state.score >= state.level * 100 {
        state.level = state.level + 1
    }
}

do lose_life(&state GameState) {
    state.lives = state.lives - 1
}

// ==================================================
// COPY BUILTIN
// ==================================================

const CopyInner struct {
    val int
}

const CopyOuter struct {
    inner CopyInner
}

do test_copy() -> TestResult {
    print_section("copy() Builtin")
    temp passed int = 0
    temp failed int = 0

    // Test copy with primitives
    temp original_int int = 42
    temp copied_int int = copy(original_int)
    if copied_int == 42 {
        println("  copy(int): ${copied_int} (expected 42)")
        passed += 1
    } otherwise {
        println("  copy(int): FAILED - got ${copied_int}")
        failed += 1
    }

    temp original_string string = "hello"
    temp copied_string string = copy(original_string)
    if copied_string == "hello" {
        println("  copy(string): '${copied_string}' (expected 'hello')")
        passed += 1
    } otherwise {
        println("  copy(string): FAILED - got '${copied_string}'")
        failed += 1
    }

    // Test copy with struct - verify deep copy
    temp a Person = Person{name: "Alice", age: 30, active: true}
    temp b Person = copy(a)
    b.age = 31
    if a.age == 30 && b.age == 31 {
        println("  copy(struct): original.age=${a.age}, copied.age=${b.age} (expected 30, 31)")
        passed += 1
    } otherwise {
        println("  copy(struct): FAILED - original.age=${a.age}, copied.age=${b.age}")
        failed += 1
    }

    // Test copy with array - verify deep copy
    temp arr1 [int] = {1, 2, 3}
    temp arr2 [int] = copy(arr1)
    arr2[0] = 100
    if arr1[0] == 1 && arr2[0] == 100 {
        println("  copy(array): original[0]=${arr1[0]}, copied[0]=${arr2[0]} (expected 1, 100)")
        passed += 1
    } otherwise {
        println("  copy(array): FAILED - original[0]=${arr1[0]}, copied[0]=${arr2[0]}")
        failed += 1
    }

    // Test copy with map - verify deep copy
    temp m1 map[string:int] = {"a": 1, "b": 2}
    temp m2 map[string:int] = copy(m1)
    m2["a"] = 100
    if m1["a"] == 1 && m2["a"] == 100 {
        println("  copy(map): original['a']=${m1["a"]}, copied['a']=${m2["a"]} (expected 1, 100)")
        passed += 1
    } otherwise {
        println("  copy(map): FAILED - original['a']=${m1["a"]}, copied['a']=${m2["a"]}")
        failed += 1
    }

    // Test copy with nil
    temp nil_copy = copy(nil)
    if nil_copy == nil {
        println("  copy(nil): ${nil_copy} (expected nil)")
        passed += 1
    } otherwise {
        println("  copy(nil): FAILED - got ${nil_copy}")
        failed += 1
    }

    // Test copy with nested struct - verify deep copy
    temp outer1 CopyOuter = CopyOuter{inner: CopyInner{val: 42}}
    temp outer2 CopyOuter = copy(outer1)
    outer2.inner.val = 99
    if outer1.inner.val == 42 && outer2.inner.val == 99 {
        println("  copy(nested struct): original.inner.val=${outer1.inner.val}, copied.inner.val=${outer2.inner.val} (expected 42, 99)")
        passed += 1
    } otherwise {
        println("  copy(nested struct): FAILED - original.inner.val=${outer1.inner.val}, copied.inner.val=${outer2.inner.val}")
        failed += 1
    }

    // Test copy with nested array - verify deep copy
    temp nested1 [[int]] = {{1, 2}, {3, 4}}
    temp nested2 [[int]] = copy(nested1)
    nested2[0][0] = 100
    if nested1[0][0] == 1 && nested2[0][0] == 100 {
        println("  copy(nested array): original[0][0]=${nested1[0][0]}, copied[0][0]=${nested2[0][0]} (expected 1, 100)")
        passed += 1
    } otherwise {
        println("  copy(nested array): FAILED - original[0][0]=${nested1[0][0]}, copied[0][0]=${nested2[0][0]}")
        failed += 1
    }

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// CHAR CONVERSION
// ==================================================

do test_char_conversion() -> TestResult {
    print_section("char() Type Conversion")
    temp passed int = 0
    temp failed int = 0

    // Test int to char (ASCII)
    temp c1 char = char(65)
    if c1 == 'A' {
        println("  char(65): '${c1}' (expected 'A')")
        passed += 1
    } otherwise {
        println("  char(65): FAILED - got '${c1}'")
        failed += 1
    }

    // Test int to char (lowercase)
    temp c2 char = char(97)
    if c2 == 'a' {
        println("  char(97): '${c2}' (expected 'a')")
        passed += 1
    } otherwise {
        println("  char(97): FAILED - got '${c2}'")
        failed += 1
    }

    // Test char to char (identity)
    temp original char = 'Z'
    temp c3 char = char(original)
    if c3 == 'Z' {
        println("  char('Z'): '${c3}' (expected 'Z')")
        passed += 1
    } otherwise {
        println("  char('Z'): FAILED - got '${c3}'")
        failed += 1
    }

    // Test float to char (truncates)
    temp c4 char = char(66.9)
    if c4 == 'B' {
        println("  char(66.9): '${c4}' (expected 'B')")
        passed += 1
    } otherwise {
        println("  char(66.9): FAILED - got '${c4}'")
        failed += 1
    }

    // Test byte to char
    temp b byte = byte(67)
    temp c5 char = char(b)
    if c5 == 'C' {
        println("  char(byte(67)): '${c5}' (expected 'C')")
        passed += 1
    } otherwise {
        println("  char(byte(67)): FAILED - got '${c5}'")
        failed += 1
    }

    // Test string to char (single character)
    temp c6 char = char("D")
    if c6 == 'D' {
        println("  char(\"D\"): '${c6}' (expected 'D')")
        passed += 1
    } otherwise {
        println("  char(\"D\"): FAILED - got '${c6}'")
        failed += 1
    }

    // Test digit char
    temp c7 char = char(48)
    if c7 == '0' {
        println("  char(48): '${c7}' (expected '0')")
        passed += 1
    } otherwise {
        println("  char(48): FAILED - got '${c7}'")
        failed += 1
    }

    // Test special char (newline)
    temp c8 char = char(10)
    if int(c8) == 10 {
        println("  char(10): newline character (expected newline)")
        passed += 1
    } otherwise {
        println("  char(10): FAILED")
        failed += 1
    }

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @math
// ==================================================

do test_stdlib_math() -> TestResult {
    print_section("Standard Library: @math")
    temp passed int = 0
    temp failed int = 0

    println("  math.abs(-5) = ${math.abs(-5)}")
    println("  math.abs(-3.14) = ${math.abs(-3.14)}")
    passed += 1

    println("  math.sqrt(16) = ${math.sqrt(16.0)}")
    println("  math.pow(2, 8) = ${math.pow(2.0, 8.0)}")
    passed += 1

    println("  math.floor(3.7) = ${math.floor(3.7)}")
    println("  math.ceil(3.2) = ${math.ceil(3.2)}")
    println("  math.round(3.5) = ${math.round(3.5)}")
    passed += 1

    println("  math.min(5, 3) = ${math.min(5, 3)}")
    println("  math.max(5, 3) = ${math.max(5, 3)}")
    passed += 1

    // Constants
    println("  math.PI = ${math.PI}")
    println("  math.TAU = ${math.TAU}")
    println("  math.E = ${math.E}")
    println("  math.INF = ${math.INF}")
    println("  math.NEG_INF = ${math.NEG_INF}")
    passed += 1

    // Trigonometry
    println("  math.sin(0) = ${math.sin(0.0)}")
    println("  math.cos(0) = ${math.cos(0.0)}")
    passed += 1

    // Random
    temp rand_int int = math.random(100)
    println("  math.random(100) = ${rand_int}")
    passed += 1

    // Special value checks
    println("  math.is_inf(math.INF) = ${math.is_inf(math.INF)}")
    println("  math.is_inf(3.14) = ${math.is_inf(3.14)}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @strings
// ==================================================

do test_stdlib_strings() -> TestResult {
    print_section("Standard Library: @strings")
    temp passed int = 0
    temp failed int = 0

    temp s string = "  Hello, World!  "

    println("  Original: '${s}'")
    println("  strings.trim(s) = '${strings.trim(s)}'")
    println("  strings.upper(s) = '${strings.upper(s)}'")
    println("  strings.lower(s) = '${strings.lower(s)}'")
    println("  len(s) = ${len(s)}")
    passed += 1

    temp csv string = "apple,banana,cherry"
    temp parts [string] = strings.split(csv, ",")
    println("  strings.split('apple,banana,cherry', ',') = ${parts}")
    passed += 1

    temp joined string = strings.join(parts, " | ")
    println("  strings.join with ' | ' = '${joined}'")
    passed += 1

    temp hello_world string = "hello world"
    temp hello string = "hello"
    temp contains_result bool = strings.contains(hello_world, "world")
    println("  strings.contains('hello world', 'world') = ${contains_result}")
    passed += 1

    temp starts_result bool = strings.starts_with(hello, "he")
    println("  strings.starts_with('hello', 'he') = ${starts_result}")
    passed += 1

    temp ends_result bool = strings.ends_with(hello, "lo")
    println("  strings.ends_with('hello', 'lo') = ${ends_result}")
    passed += 1

    temp replace_result string = strings.replace(hello, "l", "L")
    println("  strings.replace('hello', 'l', 'L') = '${replace_result}'")
    passed += 1

    temp index_result int = strings.index(hello, "l")
    println("  strings.index('hello', 'l') = ${index_result}")
    passed += 1

    // trim_left and trim_right
    temp padded string = "   test   "
    println("  strings.trim_left('   test   ') = '${strings.trim_left(padded)}'")
    println("  strings.trim_right('   test   ') = '${strings.trim_right(padded)}'")
    passed += 1

    // pad_left and pad_right
    temp num string = "42"
    println("  strings.pad_left('42', 5) = '${strings.pad_left(num, 5)}'")
    println("  strings.pad_right('42', 5) = '${strings.pad_right(num, 5)}'")
    println("  strings.pad_left('42', 5, '0') = '${strings.pad_left(num, 5, "0")}'")
    passed += 1

    // reverse
    println("  strings.reverse('hello') = '${strings.reverse(hello)}'")
    passed += 1

    // count
    temp repeat_str string = "banana"
    println("  strings.count('banana', 'a') = ${strings.count(repeat_str, "a")}")
    passed += 1

    // is_empty
    println("  strings.is_empty('') = ${strings.is_empty("")}")
    println("  strings.is_empty('   ') = ${strings.is_empty("   ")}")
    println("  strings.is_empty('hello') = ${strings.is_empty(hello)}")
    passed += 1

    // chars and from_chars
    temp char_arr = strings.chars("EZ")
    println("  strings.chars('EZ') = ${char_arr}")
    println("  strings.from_chars(chars) = '${strings.from_chars(char_arr)}'")
    passed += 1

    // last_index
    temp repeat_hello string = "hello world hello"
    println("  strings.last_index('hello world hello', 'hello') = ${strings.last_index(repeat_hello, "hello")}")
    passed += 1

    // capitalize and title
    println("  strings.capitalize('hello world') = '${strings.capitalize(hello_world)}'")
    println("  strings.title('hello world') = '${strings.title(hello_world)}'")
    passed += 1

    // repeat
    println("  strings.repeat('ab', 3) = '${strings.repeat("ab", 3)}'")
    passed += 1

    // slice
    println("  strings.slice('hello world', 0, 5) = '${strings.slice(hello_world, 0, 5)}'")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @arrays
// ==================================================

do test_stdlib_arrays() -> TestResult {
    print_section("Standard Library: @arrays")
    temp passed int = 0
    temp failed int = 0

    temp arr [int] = {3, 1, 4, 1, 5, 9, 2, 6}
    println("  Original: ${arr}")
    println("  len(arr) = ${len(arr)}")
    passed += 1

    // Append/pop
    temp push_arr [int] = {1, 2, 3}
    arrays.append(push_arr, 4)
    println("  arrays.append({1,2,3}, 4) = ${push_arr}")
    passed += 1

    temp popped int = arrays.pop(push_arr)
    println("  arrays.pop() returned ${popped}, arr = ${push_arr}")
    passed += 1

    // First/last
    println("  arrays.first({3,1,4,1,5,9,2,6}) = ${arrays.first(arr)}")
    println("  arrays.last({3,1,4,1,5,9,2,6}) = ${arrays.last(arr)}")
    passed += 1

    // Reverse
    temp to_reverse [int] = {1, 2, 3}
    temp reversed [int] = arrays.reverse(to_reverse)
    println("  arrays.reverse({1,2,3}) = ${reversed}")
    passed += 1

    // Slice
    temp sliced [int] = arrays.slice(arr, 2, 5)
    println("  arrays.slice(arr, 2, 5) = ${sliced}")
    passed += 1

    // Contains
    println("  arrays.contains({1,2,3}, 2) = ${arrays.contains({1, 2, 3}, 2)}")
    println("  arrays.contains({1,2,3}, 5) = ${arrays.contains({1, 2, 3}, 5)}")
    passed += 1

    // Chunk
    temp to_chunk [int] = {1, 2, 3, 4, 5, 6, 7}
    temp chunked = arrays.chunk(to_chunk, 3)
    println("  arrays.chunk({1,2,3,4,5,6,7}, 3) = ${chunked}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @maps
// ==================================================

do test_stdlib_maps() -> TestResult {
    print_section("Standard Library: @maps")
    temp passed int = 0
    temp failed int = 0

    temp m map[string:int] = {"a": 1, "b": 2, "c": 3}
    println("  Original map: ${m}")
    passed += 1

    // Keys and values
    temp keys [string] = maps.keys(m)
    println("  maps.keys(m) = ${keys}")
    passed += 1

    temp values [int] = maps.values(m)
    println("  maps.values(m) = ${values}")
    passed += 1

    // Has key
    temp has_a bool = maps.has(m, "a")
    temp has_z bool = maps.has(m, "z")
    println("  maps.has(m, 'a') = ${has_a}")
    println("  maps.has(m, 'z') = ${has_z}")
    passed += 1

    // Length
    println("  len(m) = ${len(m)}")
    passed += 1

    // Delete
    temp del_map map[string:int] = {"x": 10, "y": 20}
    maps.delete(del_map, "x")
    println("  after maps.delete(m, 'x'): ${del_map}")
    passed += 1

    // Clear
    temp clear_map map[string:int] = {"a": 1, "b": 2}
    maps.clear(clear_map)
    println("  after maps.clear(): ${clear_map}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @time
// ==================================================

do test_stdlib_time() -> TestResult {
    print_section("Standard Library: @time")
    temp passed int = 0
    temp failed int = 0

    // Current time
    temp now int = time.now()
    println("  time.now() = ${now}")
    passed += 1

    // Date string
    temp date string = time.date()
    println("  time.date() = ${date}")
    passed += 1

    // ISO format
    temp iso string = time.iso()
    println("  time.iso() = ${iso}")
    passed += 1

    // Year/month/day
    println("  time.year() = ${time.year()}")
    println("  time.month() = ${time.month()}")
    println("  time.day() = ${time.day()}")
    passed += 1

    // Hour/minute/second
    println("  time.hour() = ${time.hour()}")
    println("  time.minute() = ${time.minute()}")
    println("  time.second() = ${time.second()}")
    passed += 1

    // Time formatting
    temp dateFmt string = "YYYY-MM-DD"
    temp timeFmt string = "HH:mm:ss"
    println("  time.format(dateFmt) = ${time.format(dateFmt)}")
    println("  time.format(timeFmt, now) = ${time.format(timeFmt, now)}")
    passed += 1

    // Time math
    temp future int = time.add_days(now, 7)
    temp diff int = (future - now) / 86400
    println("  time.add_days(now, 7) - now = ${diff} days")
    passed += 1

    // New time arithmetic
    temp week_later int = time.add_weeks(now, 1)
    temp month_later int = time.add_months(now, 1)
    temp year_later int = time.add_years(now, 1)
    println("  time.add_weeks(now, 1) adds 7 days: ${time.diff_days(week_later, now)}")
    println("  time.add_months(now, 1) works: ${time.month(month_later)}")
    println("  time.add_years(now, 1) works: ${time.year(year_later)}")
    passed += 1

    // New time differences
    temp five_hours int = time.add_hours(now, 5)
    println("  time.diff_hours(+5h, now) = ${time.diff_hours(five_hours, now)}")
    println("  time.diff_minutes(+5h, now) = ${time.diff_minutes(five_hours, now)}")
    passed += 1

    // Calendar utilities
    println("  time.quarter() = Q${time.quarter()}")
    println("  time.week_of_year() = ${time.week_of_year()}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: printf and escape sequences
// ==================================================

do test_printf_and_escapes() -> TestResult {
    print_section("Printf and Escape Sequences")
    temp passed int = 0
    temp failed int = 0

    // Test std.printf (no automatic newline)
    std.printf("  printf test: ")
    std.printf("Hello")
    std.printf(" World\n")
    passed += 1

    // Test escape sequences in strings
    temp tab_str string = "A\tB"
    println("  Tab escape: '${tab_str}'")
    passed += 1

    temp newline_str string = "Line1\nLine2"
    println("  Newline escape (in variable):")
    println("${newline_str}")
    passed += 1

    // Test carriage return
    temp cr_str string = "Hello\rWorld"
    println("  Carriage return: '${cr_str}'")
    passed += 1

    // Test escaped backslash
    temp backslash_str string = "Path\\to\\file"
    println("  Escaped backslash: '${backslash_str}'")
    passed += 1

    // Test escaped quotes
    temp quote_str string = "She said \"Hello\""
    println("  Escaped quotes: ${quote_str}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @io
// ==================================================

do test_stdlib_io() -> TestResult {
    print_section("Standard Library: @io")
    temp passed int = 0
    temp failed int = 0

    // Create a test directory for our IO tests
    temp test_dir string = io.path_join(".", "ez_io_test_temp")

    // Test mkdir (use multi-return without type annotations)
    temp mkdir_ok, mkdir_err = io.mkdir(test_dir)
    if mkdir_err == nil {
        println("  io.mkdir('${test_dir}') = success")
        passed += 1
    } otherwise {
        println("  io.mkdir failed (may already exist)")
        passed += 1
    }

    // Test exists
    temp dir_exists bool = io.exists(test_dir)
    println("  io.exists('${test_dir}') = ${dir_exists}")
    passed += 1

    // Test is_dir
    temp is_directory bool = io.is_dir(test_dir)
    println("  io.is_dir('${test_dir}') = ${is_directory}")
    passed += 1

    // Test write_file
    temp test_file string = io.path_join(test_dir, "test.txt")
    temp content string = "Hello from EZ IO test!\nThis is line 2."
    temp write_ok, write_err = io.write_file(test_file, content)
    if write_err == nil {
        println("  io.write_file() = success")
        passed += 1
    } otherwise {
        println("  io.write_file() = FAILED")
        failed += 1
    }

    // Test is_file
    temp is_regular_file bool = io.is_file(test_file)
    println("  io.is_file('${test_file}') = ${is_regular_file}")
    passed += 1

    // Test read_file
    temp read_content, read_err = io.read_file(test_file)
    if read_err == nil {
        println("  io.read_file() = success (${len(read_content)} bytes)")
        passed += 1
    } otherwise {
        println("  io.read_file() = FAILED")
        failed += 1
    }

    // Test append_file
    temp append_ok, append_err = io.append_file(test_file, "\nAppended line.")
    if append_err == nil {
        println("  io.append_file() = success")
        passed += 1
    } otherwise {
        println("  io.append_file() = FAILED")
        failed += 1
    }

    // Verify append worked
    temp updated_content, @ignore = io.read_file(test_file)
    temp has_append bool = strings.contains(updated_content, "Appended line")
    println("  Append verification: ${has_append}")
    passed += 1

    // Test file_size
    temp size, size_err = io.file_size(test_file)
    if size_err == nil {
        println("  io.file_size('${test_file}') = ${size} bytes")
        passed += 1
    } otherwise {
        println("  io.file_size() = FAILED")
        failed += 1
    }

    // Test file_mod_time
    temp mod_time, mod_err = io.file_mod_time(test_file)
    if mod_err == nil {
        println("  io.file_mod_time() = ${mod_time} (Unix timestamp)")
        passed += 1
    } otherwise {
        println("  io.file_mod_time() = FAILED")
        failed += 1
    }

    // Test copy
    temp copy_dest string = io.path_join(test_dir, "copy.txt")
    temp copy_ok, copy_err = io.copy(test_file, copy_dest)
    if copy_err == nil {
        println("  io.copy() = success")
        passed += 1
    } otherwise {
        println("  io.copy() = FAILED")
        failed += 1
    }

    // Test rename
    temp rename_dest string = io.path_join(test_dir, "renamed.txt")
    temp rename_ok, rename_err = io.rename(copy_dest, rename_dest)
    if rename_err == nil {
        println("  io.rename() = success")
        passed += 1
    } otherwise {
        println("  io.rename() = FAILED")
        failed += 1
    }

    // Test mkdir_all (nested directories)
    temp nested_dir string = io.path_join(test_dir, "a", "b", "c")
    temp mkdirall_ok, mkdirall_err = io.mkdir_all(nested_dir)
    if mkdirall_err == nil {
        println("  io.mkdir_all('${nested_dir}') = success")
        passed += 1
    } otherwise {
        println("  io.mkdir_all() = FAILED")
        failed += 1
    }

    // Test read_dir
    temp entries, readdir_err = io.read_dir(test_dir)
    if readdir_err == nil {
        println("  io.read_dir() returned ${len(entries)} entries:")
        for_each entry in entries {
            println("    - ${entry}")
        }
        passed += 1
    } otherwise {
        println("  io.read_dir() = FAILED")
        failed += 1
    }

    // Test path utilities
    println("")
    println("  Path Utilities:")
    temp sample_path string = io.path_join("home", "user", "docs", "file.txt")
    println("  io.path_join('home', 'user', 'docs', 'file.txt') = '${sample_path}'")
    passed += 1

    temp base string = io.path_base(sample_path)
    println("  io.path_base('${sample_path}') = '${base}'")
    passed += 1

    temp dir string = io.path_dir(sample_path)
    println("  io.path_dir('${sample_path}') = '${dir}'")
    passed += 1

    temp ext string = io.path_ext(sample_path)
    println("  io.path_ext('${sample_path}') = '${ext}'")
    passed += 1

    temp separator string = io.path_separator()
    println("  io.path_separator() = '${separator}'")
    passed += 1

    temp clean_path string = io.path_clean("./foo/../bar//baz")
    println("  io.path_clean('./foo/../bar//baz') = '${clean_path}'")
    passed += 1

    temp abs_path, abs_err = io.path_abs(".")
    if abs_err == nil {
        println("  io.path_abs('.') = '${abs_path}'")
        passed += 1
    } otherwise {
        println("  io.path_abs() = FAILED")
        failed += 1
    }

    // Test error handling - non-existent file
    println("")
    println("  Error Handling:")
    temp not_found_content, not_found_err = io.read_file("nonexistent_file_12345.txt")
    if not_found_err != nil {
        println("  io.read_file(nonexistent) correctly returned error")
        passed += 1
    } otherwise {
        println("  Expected error but got nil")
        failed += 1
    }

    // Cleanup - remove test files and directories
    println("")
    println("  Cleanup:")

    // Remove files first
    temp rm1_ok, rm1_err = io.remove(test_file)
    temp rm2_ok, rm2_err = io.remove(rename_dest)
    println("  Removed test files")

    // Remove nested directory recursively
    temp rmall_ok, rmall_err = io.remove_all(test_dir)
    if rmall_err == nil {
        println("  io.remove_all('${test_dir}') = success")
        passed += 1
    } otherwise {
        println("  io.remove_all() = FAILED")
        failed += 1
    }

    // Verify cleanup
    temp still_exists bool = io.exists(test_dir)
    if !still_exists {
        println("  Cleanup verified - directory removed")
        passed += 1
    } otherwise {
        println("  Cleanup incomplete")
        failed += 1
    }

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

do test_stdlib_os() -> TestResult {
    print_section("Standard Library: @os")
    temp passed int = 0
    temp failed int = 0

    // ============================================================================
    // Environment Variables
    // ============================================================================
    println("  Environment Variables:")

    // Test os.get_env - this should work on any system
    temp path_value = os.get_env("PATH")
    if path_value != nil {
        println("  os.get_env('PATH') = [value present, ${len(path_value)} chars]")
        passed += 1
    } otherwise {
        println("  os.get_env('PATH') = nil (unexpected)")
        failed += 1
    }

    // Test os.get_env for non-existent variable
    temp nonexistent = os.get_env("EZ_NONEXISTENT_VAR_12345")
    if nonexistent == nil {
        println("  os.get_env('EZ_NONEXISTENT_VAR_12345') = nil (correct)")
        passed += 1
    } otherwise {
        println("  os.get_env('EZ_NONEXISTENT_VAR_12345') should be nil")
        failed += 1
    }

    // Test os.set_env
    temp set_ok, set_err = os.set_env("EZ_TEST_VAR", "test_value_123")
    if set_err == nil {
        println("  os.set_env('EZ_TEST_VAR', 'test_value_123') = success")
        passed += 1

        // Verify it was set
        temp verify_value = os.get_env("EZ_TEST_VAR")
        if verify_value == "test_value_123" {
            println("  os.get_env('EZ_TEST_VAR') = '${verify_value}' (verified)")
            passed += 1
        } otherwise {
            println("  Verification failed")
            failed += 1
        }
    } otherwise {
        println("  os.set_env() = FAILED")
        failed += 1
    }

    // Test os.unset_env
    temp unset_ok, unset_err = os.unset_env("EZ_TEST_VAR")
    if unset_err == nil {
        println("  os.unset_env('EZ_TEST_VAR') = success")
        passed += 1

        // Verify it was unset
        temp after_unset = os.get_env("EZ_TEST_VAR")
        if after_unset == nil {
            println("  Variable correctly unset (verified)")
            passed += 1
        } otherwise {
            println("  Variable should have been unset")
            failed += 1
        }
    } otherwise {
        println("  os.unset_env() = FAILED")
        failed += 1
    }

    // Test os.env - get all environment variables
    temp all_env = os.env()
    temp env_count int = len(all_env)
    if env_count > 0 {
        println("  os.env() = [map with ${env_count} entries]")
        passed += 1
    } otherwise {
        println("  os.env() returned empty map (unexpected)")
        failed += 1
    }

    // Test os.args
    temp args = os.args()
    println("  os.args() = [array with ${len(args)} entries]")
    passed += 1

    // ============================================================================
    // Process / System
    // ============================================================================
    println("")
    println("  Process / System:")

    // Test os.cwd
    temp cwd, cwd_err = os.cwd()
    if cwd_err == nil {
        println("  os.cwd() = '${cwd}'")
        passed += 1
    } otherwise {
        println("  os.cwd() = FAILED")
        failed += 1
    }

    // Test os.hostname
    temp hostname, host_err = os.hostname()
    if host_err == nil {
        println("  os.hostname() = '${hostname}'")
        passed += 1
    } otherwise {
        println("  os.hostname() = FAILED")
        failed += 1
    }

    // Test os.username
    temp username, user_err = os.username()
    if user_err == nil {
        println("  os.username() = '${username}'")
        passed += 1
    } otherwise {
        println("  os.username() = FAILED")
        failed += 1
    }

    // Test os.home_dir
    temp home, home_err = os.home_dir()
    if home_err == nil {
        println("  os.home_dir() = '${home}'")
        passed += 1
    } otherwise {
        println("  os.home_dir() = FAILED")
        failed += 1
    }

    // Test os.temp_dir
    temp temp_dir string = os.temp_dir()
    println("  os.temp_dir() = '${temp_dir}'")
    passed += 1

    // Test os.pid
    temp pid int = os.pid()
    println("  os.pid() = ${pid}")
    passed += 1

    // Test os.ppid
    temp ppid int = os.ppid()
    println("  os.ppid() = ${ppid}")
    passed += 1

    // ============================================================================
    // OS Constants
    // ============================================================================
    println("")
    println("  OS Constants:")

    // Test that constants have expected values
    println("  os.MAC_OS = ${os.MAC_OS}")
    println("  os.LINUX = ${os.LINUX}")
    println("  os.WINDOWS = ${os.WINDOWS}")
    println("  os.CURRENT_OS = ${os.CURRENT_OS}")
    passed += 1

    // Test CURRENT_OS matches one of the constants
    if os.CURRENT_OS == os.MAC_OS {
        println("  os.CURRENT_OS == os.MAC_OS (correct for macOS)")
        passed += 1
    }
    if os.CURRENT_OS == os.LINUX {
        println("  os.CURRENT_OS == os.LINUX (correct for Linux)")
        passed += 1
    }
    if os.CURRENT_OS == os.WINDOWS {
        println("  os.CURRENT_OS == os.WINDOWS (correct for Windows)")
        passed += 1
    }

    // ============================================================================
    // Platform Detection
    // ============================================================================
    println("")
    println("  Platform Detection:")

    // Test os.platform
    temp platform string = os.platform()
    println("  os.platform() = '${platform}'")
    passed += 1

    // Test os.arch
    temp arch string = os.arch()
    println("  os.arch() = '${arch}'")
    passed += 1

    // Test os.is_windows
    temp is_win bool = os.is_windows()
    println("  os.is_windows() = ${is_win}")
    passed += 1

    // Test os.is_linux
    temp is_lin bool = os.is_linux()
    println("  os.is_linux() = ${is_lin}")
    passed += 1

    // Test os.is_macos
    temp is_mac bool = os.is_macos()
    println("  os.is_macos() = ${is_mac}")
    passed += 1

    // Verify platform consistency
    temp platform_verified bool = false
    if platform == "darwin" && is_mac {
        println("  Platform consistency: darwin == is_macos (verified)")
        platform_verified = true
    }
    if platform == "linux" && is_lin {
        println("  Platform consistency: linux == is_linux (verified)")
        platform_verified = true
    }
    if platform == "windows" && is_win {
        println("  Platform consistency: windows == is_windows (verified)")
        platform_verified = true
    }
    if !platform_verified {
        println("  Platform consistency check: passed")
    }
    passed += 1

    // Test os.num_cpu
    temp num_cpus int = os.num_cpu()
    if num_cpus > 0 {
        println("  os.num_cpu() = ${num_cpus}")
        passed += 1
    } otherwise {
        println("  os.num_cpu() should be > 0")
        failed += 1
    }

    // ============================================================================
    // Platform Constants
    // ============================================================================
    println("")
    println("  Platform Constants:")

    // Test os.line_separator - just check that it returns a non-empty string
    temp line_sep string = os.line_separator()
    temp line_sep_len int = len(line_sep)
    if line_sep_len > 0 && line_sep_len <= 2 {
        println("  os.line_separator() = [${line_sep_len} char(s)]")
        passed += 1
    } otherwise {
        println("  os.line_separator() unexpected length: ${line_sep_len}")
        failed += 1
    }

    // Test os.dev_null
    temp dev_null string = os.dev_null()
    temp dev_null_ok bool = false
    if is_win && dev_null == "NUL" {
        println("  os.dev_null() = '${dev_null}' (Windows)")
        dev_null_ok = true
    }
    if !is_win && dev_null == "/dev/null" {
        println("  os.dev_null() = '${dev_null}' (Unix)")
        dev_null_ok = true
    }
    if dev_null_ok {
        passed += 1
    } otherwise {
        println("  os.dev_null() = '${dev_null}' (unexpected value for platform)")
        failed += 1
    }

    // ============================================================================
    // Test os.chdir (carefully - restore original directory)
    // ============================================================================
    println("")
    println("  Directory Operations:")

    temp original_dir, @ignore = os.cwd()
    temp target_dir string = os.temp_dir()

    temp chdir_ok, chdir_err = os.chdir(target_dir)
    if chdir_err == nil {
        temp new_cwd, new_cwd_err = os.cwd()
        println("  os.chdir('${target_dir}') = success")
        println("  Current dir after chdir: '${new_cwd}'")
        passed += 1

        // Restore original directory
        temp restore_ok, restore_err = os.chdir(original_dir)
        temp restored_cwd, restored_err = os.cwd()
        println("  Restored to: '${restored_cwd}'")
        passed += 1
    } otherwise {
        println("  os.chdir() = FAILED")
        failed += 1
    }

    // Test chdir to invalid directory
    temp bad_chdir_ok, bad_chdir_err = os.chdir("/nonexistent/path/12345")
    if bad_chdir_err != nil {
        println("  os.chdir(invalid) correctly returned error")
        passed += 1
    } otherwise {
        println("  os.chdir(invalid) should have returned error")
        failed += 1
    }

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// HELPER FUNCTIONS
// ==================================================

do print_section(title string) {
    println("")
    println("------------------------------------------")
    println("  ${title}")
    println("------------------------------------------")
}
