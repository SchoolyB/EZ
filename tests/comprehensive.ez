/*
 * comprehensive.ez - Single-file comprehensive test
 *
 * This file tests ALL EZ language features in a single file:
 *   - Variable declarations (var, const, temp)
 *   - All primitive types (int, float, string, bool, char)
 *   - Complex types (arrays, maps, structs, enums)
 *   - Control flow (if/or/otherwise, for, while, for_each, range)
 *   - All operators (arithmetic, comparison, logical, assignment)
 *   - Functions (parameters, returns, multiple returns)
 *   - Standard library (@std, @math, @arrays, @strings, @maps, @time)
 *   - String interpolation
 *   - Comments (single-line and multi-line)
 */

// ==================================================
// IMPORTS
// ==================================================

import @std, @math, @arrays, @strings, @maps, @time, @io

using std

// ==================================================
// ENUMS
// ==================================================

/* Basic int enum (auto-incremented) */
const Direction enum {
    NORTH
    EAST
    SOUTH
    WEST
}

/* Int enum with skip attribute */
@(int, skip, 10)
const Priority enum {
    LOW       // 0
    MEDIUM    // 10
    HIGH      // 20
    CRITICAL  // 30
}

/* String enum with explicit values */
const Status enum {
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    DONE = "done"
}

// ==================================================
// STRUCTS
// ==================================================

const Point struct {
    x int
    y int
}

const Person struct {
    name string
    age int
    active bool
}

const Task struct {
    id int
    title string
    priority int
    status string
    tags [string]
}

/* Test result tracking */
const TestResult struct {
    passed int
    failed int
}

// ==================================================
// MAIN ENTRY POINT
// ==================================================

do main() {
    println("========================================")
    println("  EZ Comprehensive Language Test")
    println("========================================")
    println("")

    temp total_passed int = 0
    temp total_failed int = 0
    temp result TestResult = TestResult{passed: 0, failed: 0}

    result = test_variables()
    total_passed += result.passed
    total_failed += result.failed

    result = test_primitives()
    total_passed += result.passed
    total_failed += result.failed

    result = test_operators()
    total_passed += result.passed
    total_failed += result.failed

    result = test_control_flow()
    total_passed += result.passed
    total_failed += result.failed

    result = test_arrays()
    total_passed += result.passed
    total_failed += result.failed

    result = test_maps()
    total_passed += result.passed
    total_failed += result.failed

    result = test_structs()
    total_passed += result.passed
    total_failed += result.failed

    result = test_enums()
    total_passed += result.passed
    total_failed += result.failed

    result = test_functions()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_math()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_strings()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_arrays()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_maps()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_time()
    total_passed += result.passed
    total_failed += result.failed

    result = test_stdlib_io()
    total_passed += result.passed
    total_failed += result.failed

    result = test_printf_and_escapes()
    total_passed += result.passed
    total_failed += result.failed

    temp total int = total_passed + total_failed

    println("")
    println("========================================")
    println("  All Tests Complete!")
    println("========================================")
    println("")
    println("  Total:  ${total}")
    println("  Passed: ${total_passed}")
    println("  Failed: ${total_failed}")
    println("")
    if total_failed == 0 {
        println("  Status: ALL TESTS PASSED!")
    } otherwise {
        println("  Status: SOME TESTS FAILED")
    }
    println("========================================")
}

// ==================================================
// VARIABLE DECLARATIONS
// ==================================================

do test_variables() -> TestResult {
    print_section("Variable Declarations")
    temp passed int = 0
    temp failed int = 0

    // temp - mutable variable
    temp counter int = 0
    counter = 1
    println("  temp counter = ${counter}")
    passed += 1

    // const - immutable constant
    const PI float = 3.14159
    println("  const PI = ${PI}")
    passed += 1

    // temp with reassignment
    temp local_val int = 42
    local_val = 43
    println("  temp local_val (reassigned) = ${local_val}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// PRIMITIVE TYPES
// ==================================================

do test_primitives() -> TestResult {
    print_section("Primitive Types")
    temp passed int = 0
    temp failed int = 0

    // int
    temp i int = 42
    temp negative_i int = -10
    temp underscore_num int = 1_000_000
    println("  int: ${i}, ${negative_i}, ${underscore_num}")
    passed += 1

    // float
    temp f float = 3.14159
    temp negative_f float = -2.5
    println("  float: ${f}, ${negative_f}")
    passed += 1

    // string
    temp s string = "Hello, World!"
    temp empty_s string = ""
    temp escaped string = "Line1\nLine2\tTabbed"
    println("  string: ${s}")
    println("  empty string length: ${len(empty_s)}")
    passed += 1

    // bool
    temp b_true bool = true
    temp b_false bool = false
    println("  bool: ${b_true}, ${b_false}")
    passed += 1

    // char
    temp c char = 'A'
    temp newline char = '\n'
    println("  char: ${c}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// OPERATORS
// ==================================================

do test_operators() -> TestResult {
    print_section("Operators")
    temp passed int = 0
    temp failed int = 0

    // Arithmetic
    temp a int = 10
    temp b int = 3
    println("  10 + 3 = ${a + b}")
    println("  10 - 3 = ${a - b}")
    println("  10 * 3 = ${a * b}")
    println("  10 / 3 = ${a / b}")
    println("  10 % 3 = ${a % b}")
    passed += 1

    // Float arithmetic
    temp x float = 10.0
    temp y float = 3.0
    println("  10.0 / 3.0 = ${x / y}")
    passed += 1

    // Comparison
    println("  10 == 3: ${a == b}")
    println("  10 != 3: ${a != b}")
    println("  10 < 3: ${a < b}")
    println("  10 > 3: ${a > b}")
    println("  10 <= 3: ${a <= b}")
    println("  10 >= 3: ${a >= b}")
    passed += 1

    // Logical
    temp t bool = true
    temp f bool = false
    println("  true && false: ${t && f}")
    println("  true || false: ${t || f}")
    println("  !true: ${!t}")
    passed += 1

    // Assignment operators
    temp num int = 10
    num += 5
    println("  10 += 5 = ${num}")
    num -= 3
    println("  15 -= 3 = ${num}")
    num *= 2
    println("  12 *= 2 = ${num}")
    num /= 4
    println("  24 /= 4 = ${num}")
    passed += 1

    // Increment/decrement
    temp counter int = 0
    counter++
    println("  0++ = ${counter}")
    counter--
    println("  1-- = ${counter}")
    passed += 1

    // String concatenation
    temp str1 string = "Hello"
    temp str2 string = "World"
    temp concat string = str1 + " " + str2
    println("  \"Hello\" + \" \" + \"World\" = ${concat}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// CONTROL FLOW
// ==================================================

do test_control_flow() -> TestResult {
    print_section("Control Flow")
    temp passed int = 0
    temp failed int = 0

    // if / or / otherwise
    temp val int = 15
    println("  if/or/otherwise with val=15:")
    if val < 10 {
        println("    val < 10")
    } or val < 20 {
        println("    val >= 10 and < 20")
    } otherwise {
        println("    val >= 20")
    }
    passed += 1

    // for loop with range
    println("  for i in range(0, 5):")
    temp sum int = 0
    for i in range(0, 5) {
        sum += i
    }
    println("    sum = ${sum}")
    passed += 1

    // for loop descending
    println("  for i in range(5, 0) (descending):")
    temp desc_list string = ""
    for i in range(5, 0) {
        desc_list = "${desc_list}${i} "
    }
    println("    ${desc_list}")
    passed += 1

    // as_long_as loop (EZ's while equivalent)
    println("  as_long_as loop:")
    temp w int = 0
    as_long_as w < 3 {
        w += 1
    }
    println("    counted to ${w}")
    passed += 1

    // for_each loop
    println("  for_each in array:")
    temp items [string] = {"apple", "banana", "cherry"}
    for_each item in items {
        println("    - ${item}")
    }
    passed += 1

    // break and continue
    println("  break test (stop at 3):")
    temp break_sum int = 0
    for i in range(0, 10) {
        if i == 3 {
            break
        }
        break_sum += i
    }
    println("    sum before break = ${break_sum}")
    passed += 1

    println("  continue test (skip 2):")
    temp cont_sum int = 0
    for i in range(0, 5) {
        if i == 2 {
            continue
        }
        cont_sum += i
    }
    println("    sum with skip = ${cont_sum}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// ARRAYS
// ==================================================

do test_arrays() -> TestResult {
    print_section("Arrays")
    temp passed int = 0
    temp failed int = 0

    // Array literal
    temp nums [int] = {1, 2, 3, 4, 5}
    println("  int array: ${nums}")
    println("  length: ${len(nums)}")
    println("  first: ${nums[0]}, last: ${nums[4]}")
    passed += 1

    // Empty array
    temp empty [int] = {}
    println("  empty array length: ${len(empty)}")
    passed += 1

    // String array
    temp words [string] = {"hello", "world"}
    println("  string array: ${words}")
    passed += 1

    // Array indexing and modification
    temp mutable [int] = {10, 20, 30}
    mutable[1] = 25
    println("  after mutable[1] = 25: ${mutable}")
    passed += 1

    // NOTE: 2D arrays [[int]] not supported - see GitHub issue #47

    // Fixed size array
    const fixed [int, 3] = {100, 200, 300}
    println("  fixed size array: ${fixed}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// MAPS
// ==================================================

do test_maps() -> TestResult {
    print_section("Maps")
    temp passed int = 0
    temp failed int = 0

    // Map literal
    temp ages map[string:int] = {
        "alice": 30,
        "bob": 25,
        "charlie": 35
    }
    println("  map: ${ages}")
    temp alice_age int = ages["alice"]
    println("  ages[\"alice\"] = ${alice_age}")
    passed += 1

    // Map modification
    ages["david"] = 28
    println("  after adding david: ${ages}")
    passed += 1

    // Map with int keys
    temp lookup map[int:string] = {
        1: "one",
        2: "two",
        3: "three"
    }
    println("  int-keyed map: ${lookup}")
    passed += 1

    // NOTE: Empty map {} not yet supported

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STRUCTS
// ==================================================

do test_structs() -> TestResult {
    print_section("Structs")
    temp passed int = 0
    temp failed int = 0

    // Struct instantiation
    temp p Point = Point{x: 10, y: 20}
    println("  Point: x=${p.x}, y=${p.y}")
    passed += 1

    // Field modification
    p.x = 15
    println("  After p.x = 15: x=${p.x}")
    passed += 1

    // Struct with different types
    temp person Person = Person{
        name: "Alice",
        age: 30,
        active: true
    }
    println("  Person: ${person.name}, age ${person.age}, active=${person.active}")
    passed += 1

    // Struct with array field
    temp task Task = Task{
        id: 1,
        title: "Test Task",
        priority: 20,
        status: "todo",
        tags: {"urgent", "review"}
    }
    println("  Task: #${task.id} - ${task.title}")
    println("  Tags: ${task.tags}")
    passed += 1

    // Array of structs
    temp points [Point] = {}
    arrays.append(points, Point{x: 0, y: 0})
    arrays.append(points, Point{x: 1, y: 1})
    println("  Array of Points: ${points}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// ENUMS
// ==================================================

do test_enums() -> TestResult {
    print_section("Enums")
    temp passed int = 0
    temp failed int = 0

    // Basic enum access
    println("  Direction.NORTH = ${Direction.NORTH}")
    println("  Direction.SOUTH = ${Direction.SOUTH}")
    passed += 1

    // Enum with skip
    println("  Priority.LOW = ${Priority.LOW}")
    println("  Priority.MEDIUM = ${Priority.MEDIUM}")
    println("  Priority.HIGH = ${Priority.HIGH}")
    println("  Priority.CRITICAL = ${Priority.CRITICAL}")
    passed += 1

    // String enum
    println("  Status.TODO = ${Status.TODO}")
    println("  Status.IN_PROGRESS = ${Status.IN_PROGRESS}")
    println("  Status.DONE = ${Status.DONE}")
    passed += 1

    // Enum in variable
    temp current_priority int = Priority.HIGH
    println("  current_priority = ${current_priority}")
    passed += 1

    // NOTE: Enum comparison in if statement not yet supported

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// FUNCTIONS
// ==================================================

do test_functions() -> TestResult {
    print_section("Functions")
    temp passed int = 0
    temp failed int = 0

    // Function with no params, no return
    println("  Calling greet():")
    greet()
    passed += 1

    // Function with params
    println("  add(5, 3) = ${add(5, 3)}")
    passed += 1

    // Function with multiple params and return
    temp rect_area int = rectangle_area(4, 5)
    println("  rectangle_area(4, 5) = ${rect_area}")
    passed += 1

    // Function returning struct
    temp origin Point = make_point(0, 0)
    println("  make_point(0, 0) = (${origin.x}, ${origin.y})")
    passed += 1

    // Function with array param
    temp numbers [int] = {1, 2, 3, 4, 5}
    temp total int = sum_array(numbers)
    println("  sum_array({1,2,3,4,5}) = ${total}")
    passed += 1

    // Recursive function
    temp fact int = factorial(5)
    println("  factorial(5) = ${fact}")
    passed += 1

    // Function returning array
    temp doubled [int] = double_array({1, 2, 3})
    println("  double_array({1,2,3}) = ${doubled}")
    passed += 1

    // NOTE: Multiple return values not yet supported

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

do greet() {
    println("    Hello from greet()!")
}

do add(a int, b int) -> int {
    return a + b
}

do rectangle_area(width int, height int) -> int {
    return width * height
}

do make_point(x int, y int) -> Point {
    temp p Point = Point{x: x, y: y}
    return p
}

do sum_array(nums [int]) -> int {
    temp total int = 0
    for_each n in nums {
        total += n
    }
    return total
}

do factorial(n int) -> int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

do double_array(nums [int]) -> [int] {
    temp result [int] = {}
    for_each n in nums {
        arrays.append(result, n * 2)
    }
    return result
}

// NOTE: min_max with multiple returns removed - not yet supported

// ==================================================
// STDLIB: @math
// ==================================================

do test_stdlib_math() -> TestResult {
    print_section("Standard Library: @math")
    temp passed int = 0
    temp failed int = 0

    println("  math.abs(-5) = ${math.abs(-5)}")
    println("  math.abs(-3.14) = ${math.abs(-3.14)}")
    passed += 1

    println("  math.sqrt(16) = ${math.sqrt(16.0)}")
    println("  math.pow(2, 8) = ${math.pow(2.0, 8.0)}")
    passed += 1

    println("  math.floor(3.7) = ${math.floor(3.7)}")
    println("  math.ceil(3.2) = ${math.ceil(3.2)}")
    println("  math.round(3.5) = ${math.round(3.5)}")
    passed += 1

    println("  math.min(5, 3) = ${math.min(5, 3)}")
    println("  math.max(5, 3) = ${math.max(5, 3)}")
    passed += 1

    // Constants
    println("  math.PI = ${math.PI}")
    println("  math.TAU = ${math.TAU}")
    println("  math.E = ${math.E}")
    println("  math.INF = ${math.INF}")
    println("  math.NEG_INF = ${math.NEG_INF}")
    passed += 1

    // Trigonometry
    println("  math.sin(0) = ${math.sin(0.0)}")
    println("  math.cos(0) = ${math.cos(0.0)}")
    passed += 1

    // Random
    temp rand_int int = math.random(100)
    println("  math.random(100) = ${rand_int}")
    passed += 1

    // Special value checks
    println("  math.is_inf(math.INF) = ${math.is_inf(math.INF)}")
    println("  math.is_inf(3.14) = ${math.is_inf(3.14)}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @strings
// ==================================================

do test_stdlib_strings() -> TestResult {
    print_section("Standard Library: @strings")
    temp passed int = 0
    temp failed int = 0

    temp s string = "  Hello, World!  "

    println("  Original: '${s}'")
    println("  strings.trim(s) = '${strings.trim(s)}'")
    println("  strings.upper(s) = '${strings.upper(s)}'")
    println("  strings.lower(s) = '${strings.lower(s)}'")
    println("  len(s) = ${len(s)}")
    passed += 1

    temp csv string = "apple,banana,cherry"
    temp parts [string] = strings.split(csv, ",")
    println("  strings.split('apple,banana,cherry', ',') = ${parts}")
    passed += 1

    temp joined string = strings.join(parts, " | ")
    println("  strings.join with ' | ' = '${joined}'")
    passed += 1

    temp hello_world string = "hello world"
    temp hello string = "hello"
    temp contains_result bool = strings.contains(hello_world, "world")
    println("  strings.contains('hello world', 'world') = ${contains_result}")
    passed += 1

    temp starts_result bool = strings.starts_with(hello, "he")
    println("  strings.starts_with('hello', 'he') = ${starts_result}")
    passed += 1

    temp ends_result bool = strings.ends_with(hello, "lo")
    println("  strings.ends_with('hello', 'lo') = ${ends_result}")
    passed += 1

    temp replace_result string = strings.replace(hello, "l", "L")
    println("  strings.replace('hello', 'l', 'L') = '${replace_result}'")
    passed += 1

    temp index_result int = strings.index(hello, "l")
    println("  strings.index('hello', 'l') = ${index_result}")
    passed += 1

    // trim_left and trim_right
    temp padded string = "   test   "
    println("  strings.trim_left('   test   ') = '${strings.trim_left(padded)}'")
    println("  strings.trim_right('   test   ') = '${strings.trim_right(padded)}'")
    passed += 1

    // pad_left and pad_right
    temp num string = "42"
    println("  strings.pad_left('42', 5) = '${strings.pad_left(num, 5)}'")
    println("  strings.pad_right('42', 5) = '${strings.pad_right(num, 5)}'")
    println("  strings.pad_left('42', 5, '0') = '${strings.pad_left(num, 5, "0")}'")
    passed += 1

    // reverse
    println("  strings.reverse('hello') = '${strings.reverse(hello)}'")
    passed += 1

    // count
    temp repeat_str string = "banana"
    println("  strings.count('banana', 'a') = ${strings.count(repeat_str, "a")}")
    passed += 1

    // is_empty
    println("  strings.is_empty('') = ${strings.is_empty("")}")
    println("  strings.is_empty('   ') = ${strings.is_empty("   ")}")
    println("  strings.is_empty('hello') = ${strings.is_empty(hello)}")
    passed += 1

    // chars and from_chars
    temp char_arr = strings.chars("EZ")
    println("  strings.chars('EZ') = ${char_arr}")
    println("  strings.from_chars(chars) = '${strings.from_chars(char_arr)}'")
    passed += 1

    // last_index
    temp repeat_hello string = "hello world hello"
    println("  strings.last_index('hello world hello', 'hello') = ${strings.last_index(repeat_hello, "hello")}")
    passed += 1

    // capitalize and title
    println("  strings.capitalize('hello world') = '${strings.capitalize(hello_world)}'")
    println("  strings.title('hello world') = '${strings.title(hello_world)}'")
    passed += 1

    // repeat
    println("  strings.repeat('ab', 3) = '${strings.repeat("ab", 3)}'")
    passed += 1

    // slice
    println("  strings.slice('hello world', 0, 5) = '${strings.slice(hello_world, 0, 5)}'")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @arrays
// ==================================================

do test_stdlib_arrays() -> TestResult {
    print_section("Standard Library: @arrays")
    temp passed int = 0
    temp failed int = 0

    temp arr [int] = {3, 1, 4, 1, 5, 9, 2, 6}
    println("  Original: ${arr}")
    println("  len(arr) = ${len(arr)}")
    passed += 1

    // Append/pop
    temp push_arr [int] = {1, 2, 3}
    arrays.append(push_arr, 4)
    println("  arrays.append({1,2,3}, 4) = ${push_arr}")
    passed += 1

    temp popped int = arrays.pop(push_arr)
    println("  arrays.pop() returned ${popped}, arr = ${push_arr}")
    passed += 1

    // First/last
    println("  arrays.first({3,1,4,1,5,9,2,6}) = ${arrays.first(arr)}")
    println("  arrays.last({3,1,4,1,5,9,2,6}) = ${arrays.last(arr)}")
    passed += 1

    // Reverse
    temp to_reverse [int] = {1, 2, 3}
    temp reversed [int] = arrays.reverse(to_reverse)
    println("  arrays.reverse({1,2,3}) = ${reversed}")
    passed += 1

    // Slice
    temp sliced [int] = arrays.slice(arr, 2, 5)
    println("  arrays.slice(arr, 2, 5) = ${sliced}")
    passed += 1

    // Contains
    println("  arrays.contains({1,2,3}, 2) = ${arrays.contains({1, 2, 3}, 2)}")
    println("  arrays.contains({1,2,3}, 5) = ${arrays.contains({1, 2, 3}, 5)}")
    passed += 1

    // Chunk
    temp to_chunk [int] = {1, 2, 3, 4, 5, 6, 7}
    temp chunked = arrays.chunk(to_chunk, 3)
    println("  arrays.chunk({1,2,3,4,5,6,7}, 3) = ${chunked}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @maps
// ==================================================

do test_stdlib_maps() -> TestResult {
    print_section("Standard Library: @maps")
    temp passed int = 0
    temp failed int = 0

    temp m map[string:int] = {"a": 1, "b": 2, "c": 3}
    println("  Original map: ${m}")
    passed += 1

    // Keys and values
    temp keys [string] = maps.keys(m)
    println("  maps.keys(m) = ${keys}")
    passed += 1

    temp values [int] = maps.values(m)
    println("  maps.values(m) = ${values}")
    passed += 1

    // Has key
    temp has_a bool = maps.has(m, "a")
    temp has_z bool = maps.has(m, "z")
    println("  maps.has(m, 'a') = ${has_a}")
    println("  maps.has(m, 'z') = ${has_z}")
    passed += 1

    // Length
    println("  len(m) = ${len(m)}")
    passed += 1

    // Delete
    temp del_map map[string:int] = {"x": 10, "y": 20}
    maps.delete(del_map, "x")
    println("  after maps.delete(m, 'x'): ${del_map}")
    passed += 1

    // Clear
    temp clear_map map[string:int] = {"a": 1, "b": 2}
    maps.clear(clear_map)
    println("  after maps.clear(): ${clear_map}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @time
// ==================================================

do test_stdlib_time() -> TestResult {
    print_section("Standard Library: @time")
    temp passed int = 0
    temp failed int = 0

    // Current time
    temp now int = time.now()
    println("  time.now() = ${now}")
    passed += 1

    // Date string
    temp date string = time.date()
    println("  time.date() = ${date}")
    passed += 1

    // ISO format
    temp iso string = time.iso()
    println("  time.iso() = ${iso}")
    passed += 1

    // Year/month/day
    println("  time.year() = ${time.year()}")
    println("  time.month() = ${time.month()}")
    println("  time.day() = ${time.day()}")
    passed += 1

    // Hour/minute/second
    println("  time.hour() = ${time.hour()}")
    println("  time.minute() = ${time.minute()}")
    println("  time.second() = ${time.second()}")
    passed += 1

    // Time formatting
    temp dateFmt string = "YYYY-MM-DD"
    temp timeFmt string = "HH:mm:ss"
    println("  time.format(dateFmt) = ${time.format(dateFmt)}")
    println("  time.format(timeFmt, now) = ${time.format(timeFmt, now)}")
    passed += 1

    // Time math
    temp future int = time.add_days(now, 7)
    temp diff int = (future - now) / 86400
    println("  time.add_days(now, 7) - now = ${diff} days")
    passed += 1

    // New time arithmetic
    temp week_later int = time.add_weeks(now, 1)
    temp month_later int = time.add_months(now, 1)
    temp year_later int = time.add_years(now, 1)
    println("  time.add_weeks(now, 1) adds 7 days: ${time.diff_days(week_later, now)}")
    println("  time.add_months(now, 1) works: ${time.month(month_later)}")
    println("  time.add_years(now, 1) works: ${time.year(year_later)}")
    passed += 1

    // New time differences
    temp five_hours int = time.add_hours(now, 5)
    println("  time.diff_hours(+5h, now) = ${time.diff_hours(five_hours, now)}")
    println("  time.diff_minutes(+5h, now) = ${time.diff_minutes(five_hours, now)}")
    passed += 1

    // Calendar utilities
    println("  time.quarter() = Q${time.quarter()}")
    println("  time.week_of_year() = ${time.week_of_year()}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: printf and escape sequences
// ==================================================

do test_printf_and_escapes() -> TestResult {
    print_section("Printf and Escape Sequences")
    temp passed int = 0
    temp failed int = 0

    // Test std.printf (no automatic newline)
    std.printf("  printf test: ")
    std.printf("Hello")
    std.printf(" World\n")
    passed += 1

    // Test escape sequences in strings
    temp tab_str string = "A\tB"
    println("  Tab escape: '${tab_str}'")
    passed += 1

    temp newline_str string = "Line1\nLine2"
    println("  Newline escape (in variable):")
    println("${newline_str}")
    passed += 1

    // Test carriage return
    temp cr_str string = "Hello\rWorld"
    println("  Carriage return: '${cr_str}'")
    passed += 1

    // Test escaped backslash
    temp backslash_str string = "Path\\to\\file"
    println("  Escaped backslash: '${backslash_str}'")
    passed += 1

    // Test escaped quotes
    temp quote_str string = "She said \"Hello\""
    println("  Escaped quotes: ${quote_str}")
    passed += 1

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// STDLIB: @io
// ==================================================

do test_stdlib_io() -> TestResult {
    print_section("Standard Library: @io")
    temp passed int = 0
    temp failed int = 0

    // Create a test directory for our IO tests
    temp test_dir string = io.path_join(".", "ez_io_test_temp")

    // Test mkdir (use multi-return without type annotations)
    temp mkdir_ok, mkdir_err = io.mkdir(test_dir)
    if mkdir_err == nil {
        println("  io.mkdir('${test_dir}') = success")
        passed += 1
    } otherwise {
        println("  io.mkdir failed (may already exist)")
        passed += 1
    }

    // Test exists
    temp dir_exists bool = io.exists(test_dir)
    println("  io.exists('${test_dir}') = ${dir_exists}")
    passed += 1

    // Test is_dir
    temp is_directory bool = io.is_dir(test_dir)
    println("  io.is_dir('${test_dir}') = ${is_directory}")
    passed += 1

    // Test write_file
    temp test_file string = io.path_join(test_dir, "test.txt")
    temp content string = "Hello from EZ IO test!\nThis is line 2."
    temp write_ok, write_err = io.write_file(test_file, content)
    if write_err == nil {
        println("  io.write_file() = success")
        passed += 1
    } otherwise {
        println("  io.write_file() = FAILED")
        failed += 1
    }

    // Test is_file
    temp is_regular_file bool = io.is_file(test_file)
    println("  io.is_file('${test_file}') = ${is_regular_file}")
    passed += 1

    // Test read_file
    temp read_content, read_err = io.read_file(test_file)
    if read_err == nil {
        println("  io.read_file() = success (${len(read_content)} bytes)")
        passed += 1
    } otherwise {
        println("  io.read_file() = FAILED")
        failed += 1
    }

    // Test append_file
    temp append_ok, append_err = io.append_file(test_file, "\nAppended line.")
    if append_err == nil {
        println("  io.append_file() = success")
        passed += 1
    } otherwise {
        println("  io.append_file() = FAILED")
        failed += 1
    }

    // Verify append worked
    temp updated_content, @ignore = io.read_file(test_file)
    temp has_append bool = strings.contains(updated_content, "Appended line")
    println("  Append verification: ${has_append}")
    passed += 1

    // Test file_size
    temp size, size_err = io.file_size(test_file)
    if size_err == nil {
        println("  io.file_size('${test_file}') = ${size} bytes")
        passed += 1
    } otherwise {
        println("  io.file_size() = FAILED")
        failed += 1
    }

    // Test file_mod_time
    temp mod_time, mod_err = io.file_mod_time(test_file)
    if mod_err == nil {
        println("  io.file_mod_time() = ${mod_time} (Unix timestamp)")
        passed += 1
    } otherwise {
        println("  io.file_mod_time() = FAILED")
        failed += 1
    }

    // Test copy
    temp copy_dest string = io.path_join(test_dir, "copy.txt")
    temp copy_ok, copy_err = io.copy(test_file, copy_dest)
    if copy_err == nil {
        println("  io.copy() = success")
        passed += 1
    } otherwise {
        println("  io.copy() = FAILED")
        failed += 1
    }

    // Test rename
    temp rename_dest string = io.path_join(test_dir, "renamed.txt")
    temp rename_ok, rename_err = io.rename(copy_dest, rename_dest)
    if rename_err == nil {
        println("  io.rename() = success")
        passed += 1
    } otherwise {
        println("  io.rename() = FAILED")
        failed += 1
    }

    // Test mkdir_all (nested directories)
    temp nested_dir string = io.path_join(test_dir, "a", "b", "c")
    temp mkdirall_ok, mkdirall_err = io.mkdir_all(nested_dir)
    if mkdirall_err == nil {
        println("  io.mkdir_all('${nested_dir}') = success")
        passed += 1
    } otherwise {
        println("  io.mkdir_all() = FAILED")
        failed += 1
    }

    // Test read_dir
    temp entries, readdir_err = io.read_dir(test_dir)
    if readdir_err == nil {
        println("  io.read_dir() returned ${len(entries)} entries:")
        for_each entry in entries {
            println("    - ${entry}")
        }
        passed += 1
    } otherwise {
        println("  io.read_dir() = FAILED")
        failed += 1
    }

    // Test path utilities
    println("")
    println("  Path Utilities:")
    temp sample_path string = io.path_join("home", "user", "docs", "file.txt")
    println("  io.path_join('home', 'user', 'docs', 'file.txt') = '${sample_path}'")
    passed += 1

    temp base string = io.path_base(sample_path)
    println("  io.path_base('${sample_path}') = '${base}'")
    passed += 1

    temp dir string = io.path_dir(sample_path)
    println("  io.path_dir('${sample_path}') = '${dir}'")
    passed += 1

    temp ext string = io.path_ext(sample_path)
    println("  io.path_ext('${sample_path}') = '${ext}'")
    passed += 1

    temp separator string = io.path_separator()
    println("  io.path_separator() = '${separator}'")
    passed += 1

    temp clean_path string = io.path_clean("./foo/../bar//baz")
    println("  io.path_clean('./foo/../bar//baz') = '${clean_path}'")
    passed += 1

    temp abs_path, abs_err = io.path_abs(".")
    if abs_err == nil {
        println("  io.path_abs('.') = '${abs_path}'")
        passed += 1
    } otherwise {
        println("  io.path_abs() = FAILED")
        failed += 1
    }

    // Test error handling - non-existent file
    println("")
    println("  Error Handling:")
    temp not_found_content, not_found_err = io.read_file("nonexistent_file_12345.txt")
    if not_found_err != nil {
        println("  io.read_file(nonexistent) correctly returned error")
        passed += 1
    } otherwise {
        println("  Expected error but got nil")
        failed += 1
    }

    // Cleanup - remove test files and directories
    println("")
    println("  Cleanup:")

    // Remove files first
    temp rm1_ok, rm1_err = io.remove(test_file)
    temp rm2_ok, rm2_err = io.remove(rename_dest)
    println("  Removed test files")

    // Remove nested directory recursively
    temp rmall_ok, rmall_err = io.remove_all(test_dir)
    if rmall_err == nil {
        println("  io.remove_all('${test_dir}') = success")
        passed += 1
    } otherwise {
        println("  io.remove_all() = FAILED")
        failed += 1
    }

    // Verify cleanup
    temp still_exists bool = io.exists(test_dir)
    if !still_exists {
        println("  Cleanup verified - directory removed")
        passed += 1
    } otherwise {
        println("  Cleanup incomplete")
        failed += 1
    }

    println("  PASSED: ${passed}, FAILED: ${failed}")
    return TestResult{passed: passed, failed: failed}
}

// ==================================================
// HELPER FUNCTIONS
// ==================================================

do print_section(title string) {
    println("")
    println("------------------------------------------")
    println("  ${title}")
    println("------------------------------------------")
}
