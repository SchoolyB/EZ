// Test os.exec and os.exec_output functions

import @std, @os

using std

do main() {
    // Test os.exec() - successful command returns exit code 0
    temp exitCode, execErr = os.exec("echo hello")
    if execErr != nil {
        println("FAIL: os.exec('echo hello') returned error")
        exit(1)
    }
    if exitCode != 0 {
        println("FAIL: os.exec('echo hello') should return exit code 0, got " + string(exitCode))
        exit(1)
    }

    // Test os.exec() - command with non-zero exit code
    temp exitCode2, execErr2 = os.exec("exit 42")
    if execErr2 != nil {
        println("FAIL: os.exec('exit 42') should not return error (just non-zero exit)")
        exit(1)
    }
    if exitCode2 != 42 {
        println("FAIL: os.exec('exit 42') should return exit code 42, got " + string(exitCode2))
        exit(1)
    }

    // Test os.exec_output() - capture output
    temp output, outputErr = os.exec_output("echo test_output")
    if outputErr != nil {
        println("FAIL: os.exec_output('echo test_output') returned error")
        exit(1)
    }
    if output != "test_output" {
        println("FAIL: os.exec_output('echo test_output') should return 'test_output', got '" + output + "'")
        exit(1)
    }

    // Test os.exec_output() - output is trimmed
    temp output2, err2 = os.exec_output("printf 'trimmed\\n\\n'")
    if output2 != "trimmed" {
        println("FAIL: os.exec_output should trim trailing whitespace, got '" + output2 + "'")
        exit(1)
    }

    // Test os.exec_output() - capture multi-line output
    temp output3, err3 = os.exec_output("printf 'line1\\nline2'")
    if output3 != "line1\nline2" {
        println("FAIL: os.exec_output should preserve internal newlines")
        exit(1)
    }

    println("PASS: All os.exec tests passed")
}
